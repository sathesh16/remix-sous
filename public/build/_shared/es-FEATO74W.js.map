{
  "version": 3,
  "sources": ["../../../node_modules/classnames/index.js", "../../../node_modules/fast-formula-parser/grammar/type/collection.js", "../../../node_modules/fast-formula-parser/formulas/helpers.js", "../../../node_modules/fast-formula-parser/formulas/error.js", "../../../node_modules/fast-formula-parser/ssf/ssf.js", "../../../node_modules/bahttext/src/index.js", "../../../node_modules/fast-formula-parser/formulas/functions/text.js", "../../../node_modules/fast-formula-parser/formulas/operators.js", "../../../node_modules/fast-formula-parser/formulas/functions/math.js", "../../../node_modules/fast-formula-parser/formulas/functions/trigonometry.js", "../../../node_modules/fast-formula-parser/formulas/functions/logical.js", "../../../node_modules/bessel/bessel.js", "../../../node_modules/jstat/dist/jstat.js", "../../../node_modules/fast-formula-parser/formulas/functions/engineering.js", "../../../node_modules/fast-formula-parser/formulas/functions/reference.js", "../../../node_modules/fast-formula-parser/formulas/functions/information.js", "../../../node_modules/fast-formula-parser/formulas/functions/distribution.js", "../../../node_modules/fast-formula-parser/formulas/functions/statistical.js", "../../../node_modules/fast-formula-parser/formulas/functions/date.js", "../../../node_modules/fast-formula-parser/formulas/functions/web.js", "../../../node_modules/chevrotain/src/version.ts", "../../../node_modules/chevrotain/src/utils/utils.ts", "../../../node_modules/regexp-to-ast/lib/regexp-to-ast.js", "../../../node_modules/chevrotain/src/scan/reg_exp_parser.ts", "../../../node_modules/chevrotain/src/scan/reg_exp.ts", "../../../node_modules/chevrotain/src/scan/lexer.ts", "../../../node_modules/chevrotain/src/scan/tokens.ts", "../../../node_modules/chevrotain/src/scan/lexer_errors_public.ts", "../../../node_modules/chevrotain/src/scan/lexer_public.ts", "../../../node_modules/chevrotain/src/scan/tokens_public.ts", "../../../node_modules/chevrotain/src/parse/grammar/gast/gast_public.ts", "../../../node_modules/chevrotain/src/parse/grammar/rest.ts", "../../../node_modules/chevrotain/src/parse/grammar/gast/gast_visitor_public.ts", "../../../node_modules/chevrotain/src/parse/grammar/gast/gast.ts", "../../../node_modules/chevrotain/src/parse/grammar/first.ts", "../../../node_modules/chevrotain/src/parse/constants.ts", "../../../node_modules/chevrotain/src/parse/grammar/follow.ts", "../../../node_modules/chevrotain/src/parse/errors_public.ts", "../../../node_modules/chevrotain/src/parse/grammar/resolver.ts", "../../../node_modules/chevrotain/src/parse/grammar/interpreter.ts", "../../../node_modules/chevrotain/src/parse/grammar/lookahead.ts", "../../../node_modules/chevrotain/src/parse/grammar/checks.ts", "../../../node_modules/chevrotain/src/parse/grammar/gast/gast_resolver_public.ts", "../../../node_modules/chevrotain/src/parse/exceptions_public.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/recoverable.ts", "../../../node_modules/chevrotain/src/parse/grammar/keys.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/looksahead.ts", "../../../node_modules/chevrotain/src/parse/cst/cst.ts", "../../../node_modules/chevrotain/src/lang/lang_extensions.ts", "../../../node_modules/chevrotain/src/parse/cst/cst_visitor.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/tree_builder.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/lexer_adapter.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/recognizer_api.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/recognizer_engine.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/error_handler.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/context_assist.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/gast_recorder.ts", "../../../node_modules/chevrotain/src/parse/parser/traits/perf_tracer.ts", "../../../node_modules/chevrotain/src/parse/parser/parser.ts", "../../../node_modules/chevrotain/src/diagrams/render_public.ts", "../../../node_modules/chevrotain/src/generate/generate.ts", "../../../node_modules/chevrotain/src/generate/generate_public.ts", "../../../node_modules/chevrotain/src/api.ts", "../../../node_modules/fast-formula-parser/grammar/lexing.js", "../../../node_modules/fast-formula-parser/grammar/parsing.js", "../../../node_modules/fast-formula-parser/grammar/utils.js", "../../../node_modules/fast-formula-parser/grammar/hooks.js", "../../../node_modules/fast-formula-parser/grammar/dependency/utils.js", "../../../node_modules/fast-formula-parser/grammar/dependency/hooks.js", "../../../node_modules/fast-formula-parser/index.js", "../../../node_modules/use-context-selector/src/index.ts", "../../../node_modules/react-spreadsheet/node_modules/style-inject/dist/style-inject.es.js"],
  "sourcesContent": ["/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n", "/**\r\n * Represents unions.\r\n * (A1, A1:C5, ...)\r\n */\r\nclass Collection {\r\n\r\n    constructor(data, refs) {\r\n        if (data == null && refs == null) {\r\n            this._data = [];\r\n            this._refs = [];\r\n        } else {\r\n            if (data.length !== refs.length)\r\n                throw Error('Collection: data length should match references length.');\r\n            this._data = data;\r\n            this._refs = refs;\r\n        }\r\n    }\r\n\r\n    get data() {\r\n        return this._data;\r\n    }\r\n\r\n    get refs() {\r\n        return this._refs;\r\n    }\r\n\r\n    get length() {\r\n        return this._data.length;\r\n    }\r\n\r\n    /**\r\n     * Add data and references to this collection.\r\n     * @param {{}} obj - data\r\n     * @param {{}} ref - reference\r\n     */\r\n    add(obj, ref) {\r\n        this._data.push(obj);\r\n        this._refs.push(ref);\r\n    }\r\n}\r\n\r\nmodule.exports = Collection;\r\n", "const FormulaError = require('./error');\r\nconst Collection = require('../grammar/type/collection');\r\n\r\nconst Types = {\r\n    NUMBER: 0,\r\n    ARRAY: 1,\r\n    BOOLEAN: 2,\r\n    STRING: 3,\r\n    RANGE_REF: 4, // can be 'A:C' or '1:4', not only 'A1:C3'\r\n    CELL_REF: 5,\r\n    COLLECTIONS: 6, // Unions of references\r\n    NUMBER_NO_BOOLEAN: 10,\r\n};\r\n\r\nconst Factorials = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000, 121645100408832000, 2432902008176640000, 51090942171709440000, 1124000727777607680000, 25852016738884976640000, 620448401733239439360000, 15511210043330985984000000, 403291461126605635584000000, 10888869450418352160768000000, 304888344611713860501504000000, 8841761993739701954543616000000, 265252859812191058636308480000000, 8222838654177922817725562880000000, 263130836933693530167218012160000000, 8683317618811886495518194401280000000, 295232799039604140847618609643520000000, 10333147966386144929666651337523200000000, 371993326789901217467999448150835200000000, 13763753091226345046315979581580902400000000, 523022617466601111760007224100074291200000000, 20397882081197443358640281739902897356800000000, 815915283247897734345611269596115894272000000000, 33452526613163807108170062053440751665152000000000, 1405006117752879898543142606244511569936384000000000, 60415263063373835637355132068513997507264512000000000, 2658271574788448768043625811014615890319638528000000000, 119622220865480194561963161495657715064383733760000000000, 5502622159812088949850305428800254892961651752960000000000, 258623241511168180642964355153611979969197632389120000000000, 12413915592536072670862289047373375038521486354677760000000000, 608281864034267560872252163321295376887552831379210240000000000, 30414093201713378043612608166064768844377641568960512000000000000, 1551118753287382280224243016469303211063259720016986112000000000000, 80658175170943878571660636856403766975289505440883277824000000000000, 4274883284060025564298013753389399649690343788366813724672000000000000, 230843697339241380472092742683027581083278564571807941132288000000000000, 12696403353658275925965100847566516959580321051449436762275840000000000000, 710998587804863451854045647463724949736497978881168458687447040000000000000, 40526919504877216755680601905432322134980384796226602145184481280000000000000, 2350561331282878571829474910515074683828862318181142924420699914240000000000000, 138683118545689835737939019720389406345902876772687432540821294940160000000000000, 8320987112741390144276341183223364380754172606361245952449277696409600000000000000, 507580213877224798800856812176625227226004528988036003099405939480985600000000000000, 31469973260387937525653122354950764088012280797258232192163168247821107200000000000000, 1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000, 126886932185884164103433389335161480802865516174545192198801894375214704230400000000000000, 8247650592082470666723170306785496252186258551345437492922123134388955774976000000000000000, 544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000, 36471110918188685288249859096605464427167635314049524593701628500267962436943872000000000000000, 2480035542436830599600990418569171581047399201355367672371710738018221445712183296000000000000000, 171122452428141311372468338881272839092270544893520369393648040923257279754140647424000000000000000, 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000, 850478588567862317521167644239926010288584608120796235886430763388588680378079017697280000000000000000, 61234458376886086861524070385274672740778091784697328983823014963978384987221689274204160000000000000000, 4470115461512684340891257138125051110076800700282905015819080092370422104067183317016903680000000000000000, 330788544151938641225953028221253782145683251820934971170611926835411235700971565459250872320000000000000000, 24809140811395398091946477116594033660926243886570122837795894512655842677572867409443815424000000000000000000, 1885494701666050254987932260861146558230394535379329335672487982961844043495537923117729972224000000000000000000, 145183092028285869634070784086308284983740379224208358846781574688061991349156420080065207861248000000000000000000, 11324281178206297831457521158732046228731749579488251990048962825668835325234200766245086213177344000000000000000000, 894618213078297528685144171539831652069808216779571907213868063227837990693501860533361810841010176000000000000000000, 71569457046263802294811533723186532165584657342365752577109445058227039255480148842668944867280814080000000000000000000, 5797126020747367985879734231578109105412357244731625958745865049716390179693892056256184534249745940480000000000000000000, 475364333701284174842138206989404946643813294067993328617160934076743994734899148613007131808479167119360000000000000000000, 39455239697206586511897471180120610571436503407643446275224357528369751562996629334879591940103770870906880000000000000000000, 3314240134565353266999387579130131288000666286242049487118846032383059131291716864129885722968716753156177920000000000000000000, 281710411438055027694947944226061159480056634330574206405101912752560026159795933451040286452340924018275123200000000000000000000, 24227095383672732381765523203441259715284870552429381750838764496720162249742450276789464634901319465571660595200000000000000000000, 2107757298379527717213600518699389595229783738061356212322972511214654115727593174080683423236414793504734471782400000000000000000000, 185482642257398439114796845645546284380220968949399346684421580986889562184028199319100141244804501828416633516851200000000000000000000, 16507955160908461081216919262453619309839666236496541854913520707833171034378509739399912570787600662729080382999756800000000000000000000, 1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000, 135200152767840296255166568759495142147586866476906677791741734597153670771559994765685283954750449427751168336768008192000000000000000000000, 12438414054641307255475324325873553077577991715875414356840239582938137710983519518443046123837041347353107486982656753664000000000000000000000, 1156772507081641574759205162306240436214753229576413535186142281213246807121467315215203289516844845303838996289387078090752000000000000000000000, 108736615665674308027365285256786601004186803580182872307497374434045199869417927630229109214583415458560865651202385340530688000000000000000000000, 10329978488239059262599702099394727095397746340117372869212250571234293987594703124871765375385424468563282236864226607350415360000000000000000000000, 991677934870949689209571401541893801158183648651267795444376054838492222809091499987689476037000748982075094738965754305639874560000000000000000000000, 96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000, 9426890448883247745626185743057242473809693764078951663494238777294707070023223798882976159207729119823605850588608460429412647567360000000000000000000000, 933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000, 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000];\r\n\r\nconst ReversedTypes = {};\r\nObject.keys(Types).forEach((key) => {\r\n    ReversedTypes[Types[key]] = key;\r\n});\r\n\r\n/**\r\n * Formula helpers.\r\n */\r\nclass FormulaHelpers {\r\n    constructor() {\r\n        this.Types = Types;\r\n        this.type2Number = {\r\n            number: Types.NUMBER,\r\n            boolean: Types.BOOLEAN,\r\n            string: Types.STRING,\r\n            object: -1\r\n        };\r\n    }\r\n\r\n    checkFunctionResult(result) {\r\n        const type = typeof result;\r\n        // number\r\n        if (type === 'number') {\r\n            if (isNaN(result)) {\r\n                return FormulaError.VALUE;\r\n            } else if (!isFinite(result)) {\r\n                return FormulaError.NUM;\r\n            }\r\n        }\r\n        if (result === undefined || result === null)\r\n            return FormulaError.NULL;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Flatten an array\r\n     * @param {Array} arr1\r\n     * @returns {*}\r\n     */\r\n    flattenDeep(arr1) {\r\n        return arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(this.flattenDeep(val)) : acc.concat(val), []);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param obj\r\n     * @param isArray - if it is an array: [1,2,3], will extract the first element\r\n     * @param allowBoolean - Allow parse boolean into number\r\n     * @returns {number|FormulaError}\r\n     */\r\n    acceptNumber(obj, isArray = true, allowBoolean = true) {\r\n        // check error\r\n        if (obj instanceof FormulaError)\r\n            return obj;\r\n        let number;\r\n\r\n        if (typeof obj === 'number')\r\n            number = obj;\r\n        // TRUE -> 1, FALSE -> 0\r\n        else if (typeof obj === 'boolean') {\r\n            if (allowBoolean) {\r\n                number = Number(obj);\r\n            } else {\r\n                throw FormulaError.VALUE;\r\n            }\r\n        }\r\n        // \"123\" -> 123\r\n        else if (typeof obj === 'string') {\r\n            if (obj.length === 0) {\r\n                throw FormulaError.VALUE;\r\n            }\r\n            number = Number(obj);\r\n            // Note: the unique never-equal-to-itself characteristic of NaN\r\n            if (number !== number) {\r\n                throw FormulaError.VALUE;\r\n            }\r\n        } else if (Array.isArray(obj)) {\r\n            if (!isArray) {\r\n                // for range ref, only allow single column range ref\r\n                if (obj[0].length === 1) {\r\n                    number = this.acceptNumber(obj[0][0]);\r\n                } else {\r\n                    throw FormulaError.VALUE;\r\n                }\r\n            } else {\r\n                number = this.acceptNumber(obj[0][0]);\r\n            }\r\n\r\n        } else {\r\n            throw Error('Unknown type in FormulaHelpers.acceptNumber')\r\n        }\r\n        return number;\r\n    }\r\n\r\n    /**\r\n     * Flatten parameters to 1D array.\r\n     * @see {@link FormulaHelpers.accept}\r\n     * @param {Array} params - Parameter that needs to flatten.\r\n     * @param {Types|null} valueType - The type each item should be,\r\n     *                          null if allows any type. This only applies to literals.\r\n     * @param {boolean} allowUnion - Allow union, e.g. (A1:C1, E4:F3)\r\n     * @param {function} hook - Invoked after parsing each item.\r\n     *                         of the array.\r\n     * @param {*} [defValue=null] - The value if an param is omitted. i.e. SUM(1,2,,,,,)\r\n     * @param {number} [minSize=1] - The minimum size of the parameters\r\n     */\r\n    flattenParams(params, valueType, allowUnion, hook, defValue = null, minSize = 1) {\r\n        if (params.length < minSize)\r\n            throw FormulaError.ARG_MISSING([valueType]);\r\n        if (defValue == null) {\r\n            defValue = valueType === Types.NUMBER ? 0 : valueType == null ? null : '';\r\n        }\r\n        params.forEach(param => {\r\n            const {isCellRef, isRangeRef, isArray} = param;\r\n            const isUnion = param.value instanceof Collection;\r\n            const isLiteral = !isCellRef && !isRangeRef && !isArray && !isUnion;\r\n            const info = {isLiteral, isCellRef, isRangeRef, isArray, isUnion};\r\n\r\n            // single element\r\n            if (isLiteral) {\r\n                if (param.omitted)\r\n                    param = defValue;\r\n                else\r\n                    param = this.accept(param, valueType, defValue);\r\n                hook(param, info);\r\n            }\r\n            // cell reference of single range reference (A1:A1)\r\n            else if (isCellRef) {\r\n                hook(param.value, info);\r\n            }\r\n            // union\r\n            else if (isUnion) {\r\n                if (!allowUnion) throw FormulaError.VALUE;\r\n                param = param.value.data;\r\n                param = this.flattenDeep(param);\r\n                param.forEach(item => {\r\n                    hook(item, info);\r\n                })\r\n            } else if (isRangeRef || isArray) {\r\n                param = this.flattenDeep(param.value);\r\n                param.forEach(item => {\r\n                    hook(item, info);\r\n                })\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if the param valid, return the parsed param.\r\n     * If type is not given, return the un-parsed param.\r\n     * @param {*} param\r\n     * @param {number|null} [type] - The expected type\r\n     *           NUMBER: Expect a single number,\r\n     *           ARRAY: Expect an flatten array,\r\n     *           BOOLEAN: Expect a single boolean,\r\n     *           STRING: Expect a single string,\r\n     *           COLLECTIONS: Expect an Array of the above types\r\n     *           null: Do not parse the value, return it directly.\r\n     *           The collection is not a flatted array.\r\n     * @param {*} [defValue] - Default value if the param is not given.\r\n     *               if undefined, this param is required, a Error will throw if not given.\r\n     *               if null, and param is undefined, null will be returned.\r\n     * @param {boolean} [flat=true] - If the array should be flattened,\r\n     *                      only applicable when type is ARRAY.\r\n     *                      If false, collection is disallowed.\r\n     * @param {boolean} allowSingleValue - If pack single value into 2d array,\r\n     *                     only applicable when type is ARRAY.\r\n     * @return {string|number|boolean|{}|Array}\r\n     */\r\n    accept(param, type = null, defValue, flat = true, allowSingleValue = false) {\r\n        // TODO: remove this array check\r\n        if (Array.isArray(type))\r\n            type = type[0];\r\n        if (param == null && defValue === undefined) {\r\n            throw FormulaError.ARG_MISSING([type]);\r\n        } else if (param == null)\r\n            return defValue;\r\n\r\n        if (typeof param !== \"object\" || Array.isArray(param))\r\n            return param;\r\n\r\n        const isArray = param.isArray;\r\n        if (param.value != null) param = param.value;\r\n\r\n        // return an un-parsed type.\r\n        if (type == null)\r\n            return param;\r\n\r\n        if (param instanceof FormulaError)\r\n            throw param;\r\n\r\n        if (type === Types.ARRAY) {\r\n            if (Array.isArray(param)) {\r\n                return flat ? this.flattenDeep(param) : param;\r\n            } else if (param instanceof Collection) {\r\n                throw FormulaError.VALUE;\r\n            } else if (allowSingleValue) {\r\n                return flat ? [param] : [[param]];\r\n            }\r\n            throw FormulaError.VALUE;\r\n        } else if (type === Types.COLLECTIONS) {\r\n            return param;\r\n        }\r\n\r\n        // the only possible type for expectSingle=true are: string, boolean, number;\r\n        // If array encountered, extract the first element.\r\n        // extract first element from array\r\n        if (isArray) {\r\n            param = param[0][0];\r\n        }\r\n        const paramType = this.type(param);\r\n        if (type === Types.STRING) {\r\n            if (paramType === Types.BOOLEAN)\r\n                param = param ? 'TRUE' : 'FALSE';\r\n            else\r\n                param = `${param}`\r\n        } else if (type === Types.BOOLEAN) {\r\n            if (paramType === Types.STRING)\r\n                throw FormulaError.VALUE;\r\n            if (paramType === Types.NUMBER)\r\n                param = Boolean(param);\r\n        } else if (type === Types.NUMBER) {\r\n            param = this.acceptNumber(param, false);\r\n        } else if (type === Types.NUMBER_NO_BOOLEAN) {\r\n            param = this.acceptNumber(param, false, false);\r\n        } else {\r\n            throw FormulaError.VALUE;\r\n        }\r\n        return param;\r\n    }\r\n\r\n    type(variable) {\r\n        let type = this.type2Number[typeof variable];\r\n        if (type === -1) {\r\n            if (Array.isArray(variable))\r\n                type = Types.ARRAY;\r\n            else if (variable.ref) {\r\n                if (variable.ref.from) {\r\n                    type = Types.RANGE_REF;\r\n                } else {\r\n                    type = Types.CELL_REF;\r\n                }\r\n            } else if (variable instanceof Collection)\r\n                type = Types.COLLECTIONS;\r\n        }\r\n        return type;\r\n    }\r\n\r\n    isRangeRef(param) {\r\n        return param.ref && param.ref.from;\r\n    }\r\n\r\n    isCellRef(param) {\r\n        return param.ref && !param.ref.from;\r\n    }\r\n\r\n    /**\r\n     * Helper function for SUMIF, AVERAGEIF,...\r\n     * @param context\r\n     * @param range1\r\n     * @param range2\r\n     */\r\n    retrieveRanges(context, range1, range2) {\r\n        // process args\r\n        range2 = Address.extend(range1, range2);\r\n\r\n        // retrieve values\r\n        range1 = this.retrieveArg(context, range1);\r\n        range1 = H.accept(range1, Types.ARRAY, undefined, false, true);\r\n\r\n        if (range2 !== range1) {\r\n            range2 = this.retrieveArg(context, range2);\r\n            range2 = H.accept(range2, Types.ARRAY, undefined, false, true);\r\n        } else\r\n            range2 = range1;\r\n\r\n        return [range1, range2];\r\n    }\r\n\r\n    retrieveArg(context, arg) {\r\n        if (arg === null)\r\n            return {value: 0, isArray: false, omitted: true};\r\n        const res = context.utils.extractRefValue(arg);\r\n        return {value: res.val, isArray: res.isArray, ref: arg.ref};\r\n    }\r\n}\r\n\r\nconst H = new FormulaHelpers();\r\n\r\nconst WildCard = {\r\n    /**\r\n     * @param {string|*} obj\r\n     * @returns {*}\r\n     */\r\n    isWildCard: obj => {\r\n        if (typeof obj === \"string\")\r\n            return /[*?]/.test(obj);\r\n        return false;\r\n    },\r\n\r\n    toRegex: (lookupText, flags) => {\r\n        return RegExp(lookupText.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // escape the special char for js regex\r\n            .replace(/([^~]??)[?]/g, '$1.') // ? => .\r\n            .replace(/([^~]??)[*]/g, '$1.*') // * => .*\r\n            .replace(/~([?*])/g, '$1'), flags); // ~* => * and ~? => ?\r\n    }\r\n};\r\n\r\nconst Criteria = {\r\n    /**\r\n     * Parse criteria, support comparison and wild card match.\r\n     * @param {string|number} criteria\r\n     * @return {{op: string, value: string|number|boolean|RegExp, match: boolean|undefined}} - The parsed criteria.\r\n     */\r\n    parse: (criteria) => {\r\n        const type = typeof criteria;\r\n        if (type === \"string\") {\r\n            // criteria = 'TRUE' or 'FALSE'\r\n            const upper = criteria.toUpperCase();\r\n            if (upper === 'TRUE' || upper === 'FALSE') {\r\n                // excel boolean\r\n                return {op: '=', value: upper === 'TRUE'};\r\n            }\r\n\r\n            const res = criteria.match(/(<>|>=|<=|>|<|=)(.*)/);\r\n            // is comparison\r\n            if (res) {\r\n                // [\">10\", \">\", \"10\", index: 0, input: \">10\", groups: undefined]\r\n                let op = res[1], value;\r\n\r\n                // string or boolean or error\r\n                if (isNaN(res[2])) {\r\n                    const upper = res[2].toUpperCase();\r\n                    if (upper === 'TRUE' || upper === 'FALSE') {\r\n                        // excel boolean\r\n                        value = upper === 'TRUE';\r\n                    } else if (/#NULL!|#DIV\\/0!|#VALUE!|#NAME\\?|#NUM!|#N\\/A|#REF!/.test(res[2])) {\r\n                        // formula error\r\n                        value = new FormulaError(res[2]);\r\n                    } else {\r\n                        // string, can be wildcard\r\n                        value = res[2];\r\n                        if (WildCard.isWildCard(value)) {\r\n                            return {op: 'wc', value: WildCard.toRegex(value), match: op === '='}\r\n                        }\r\n                    }\r\n                } else {\r\n                    // number\r\n                    value = Number(res[2])\r\n                }\r\n                return {op, value};\r\n\r\n            } else if (WildCard.isWildCard(criteria)) {\r\n                return {op: 'wc', value: WildCard.toRegex(criteria), match: true}\r\n            } else {\r\n                return {op: '=', value: criteria}\r\n            }\r\n        } else if (type === \"boolean\" || type === 'number' || (Array.isArray(criteria)\r\n            || criteria instanceof FormulaError)) {\r\n            return {op: '=', value: criteria}\r\n        } else {\r\n            throw Error(`Criteria.parse: type ${typeof criteria} not support`)\r\n        }\r\n    }\r\n};\r\n\r\nconst Address = {\r\n\r\n    columnNumberToName: (number) => {\r\n        let dividend = number;\r\n        let name = '';\r\n        let modulo = 0;\r\n\r\n        while (dividend > 0) {\r\n            modulo = (dividend - 1) % 26;\r\n            name = String.fromCharCode('A'.charCodeAt(0) + modulo) + name;\r\n            dividend = Math.floor((dividend - modulo) / 26);\r\n        }\r\n\r\n        return name;\r\n    },\r\n\r\n    columnNameToNumber: (columnName) => {\r\n        columnName = columnName.toUpperCase();\r\n        const len = columnName.length;\r\n        let number = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            const code = columnName.charCodeAt(i);\r\n            if (!isNaN(code)) {\r\n                number += (code - 64) * 26 ** (len - i - 1)\r\n            }\r\n        }\r\n        return number;\r\n    },\r\n\r\n    /**\r\n     * Extend range2 to match with the dimension in range1.\r\n     * @param {{ref: {}}} range1\r\n     * @param {{ref: {}}} [range2]\r\n     */\r\n    extend: (range1, range2) => {\r\n        if (range2 == null) {\r\n            return range1;\r\n        }\r\n        let rowOffset, colOffset;\r\n        if (H.isCellRef(range1)) {\r\n            rowOffset = 0;\r\n            colOffset = 0;\r\n        } else if (H.isRangeRef(range1)) {\r\n            rowOffset = range1.ref.to.row - range1.ref.from.row;\r\n            colOffset = range1.ref.to.col - range1.ref.from.col;\r\n        } else throw Error('Address.extend should not reach here.');\r\n        // if range2 is a cell reference\r\n        if (H.isCellRef(range2)) {\r\n            if (rowOffset > 0 || colOffset > 0)\r\n                range2 = {\r\n                    ref: {\r\n                        from: {col: range2.ref.col, row: range2.ref.row},\r\n                        to: {row: range2.ref.row + rowOffset, col: range2.ref.col + colOffset}\r\n                    }\r\n                };\r\n        } else {\r\n            // range2 is a range reference\r\n            range2.ref.to.row = range2.ref.from.row + rowOffset;\r\n            range2.ref.to.col = range2.ref.from.col + colOffset;\r\n        }\r\n        return range2;\r\n    },\r\n};\r\n\r\nmodule.exports = {\r\n    FormulaHelpers: H,\r\n    Types,\r\n    ReversedTypes,\r\n    Factorials,\r\n    WildCard,\r\n    Criteria,\r\n    Address,\r\n};\r\n", "/**\r\n * Formula Error.\r\n */\r\nclass FormulaError extends Error {\r\n\r\n    /**\r\n     * @param {string} error - error code, i.e. #NUM!\r\n     * @param {string} [msg] - detailed error message\r\n     * @param {object|Error} [details]\r\n     * @returns {FormulaError}\r\n     */\r\n    constructor(error, msg, details) {\r\n        super(msg);\r\n        if (msg == null && details == null && FormulaError.errorMap.has(error))\r\n            return FormulaError.errorMap.get(error);\r\n        else if (msg == null && details == null) {\r\n            this._error = error;\r\n            FormulaError.errorMap.set(error, this);\r\n        } else {\r\n            this._error = error;\r\n        }\r\n        this.details = details;\r\n    }\r\n\r\n    /**\r\n     * Get the error name.\r\n     * @returns {string} formula error\r\n     */\r\n    get error() {\r\n        return this._error;\r\n    }\r\n    get name() {\r\n        return this._error;\r\n    }\r\n\r\n    /**\r\n     * Return true if two errors are same.\r\n     * @param {FormulaError} err\r\n     * @returns {boolean} if two errors are same.\r\n     */\r\n    equals(err) {\r\n        return err instanceof FormulaError && err._error === this._error;\r\n    }\r\n\r\n    /**\r\n     * Return the formula error in string representation.\r\n     * @returns {string} the formula error in string representation.\r\n     */\r\n    toString() {\r\n        return this._error;\r\n    }\r\n}\r\n\r\nFormulaError.errorMap = new Map();\r\n\r\n/**\r\n * DIV0 error\r\n * @type {FormulaError}\r\n */\r\nFormulaError.DIV0 = new FormulaError(\"#DIV/0!\");\r\n\r\n/**\r\n * NA error\r\n * @type {FormulaError}\r\n */\r\nFormulaError.NA = new FormulaError(\"#N/A\");\r\n\r\n/**\r\n * NAME error\r\n * @type {FormulaError}\r\n */\r\nFormulaError.NAME = new FormulaError(\"#NAME?\");\r\n\r\n/**\r\n * NULL error\r\n * @type {FormulaError}\r\n */\r\nFormulaError.NULL = new FormulaError(\"#NULL!\");\r\n\r\n/**\r\n * NUM error\r\n * @type {FormulaError}\r\n */\r\nFormulaError.NUM = new FormulaError(\"#NUM!\");\r\n\r\n/**\r\n * REF error\r\n * @type {FormulaError}\r\n */\r\nFormulaError.REF = new FormulaError(\"#REF!\");\r\n\r\n/**\r\n * VALUE error\r\n * @type {FormulaError}\r\n */\r\nFormulaError.VALUE = new FormulaError(\"#VALUE!\");\r\n\r\n/**\r\n * NOT_IMPLEMENTED error\r\n * @param {string} functionName - the name of the not implemented function\r\n * @returns {FormulaError}\r\n * @constructor\r\n */\r\nFormulaError.NOT_IMPLEMENTED = (functionName) => {\r\n    return new FormulaError(\"#NAME?\", `Function ${functionName} is not implemented.`)\r\n};\r\n\r\n/**\r\n * TOO_MANY_ARGS error\r\n * @param functionName - the name of the errored function\r\n * @returns {FormulaError}\r\n * @constructor\r\n */\r\nFormulaError.TOO_MANY_ARGS = (functionName) => {\r\n    return new FormulaError(\"#N/A\", `Function ${functionName} has too many arguments.`)\r\n};\r\n\r\n/**\r\n * ARG_MISSING error\r\n * @param args - the name of the errored function\r\n * @returns {FormulaError}\r\n * @constructor\r\n */\r\nFormulaError.ARG_MISSING = (args) => {\r\n    const {Types} = require('./helpers');\r\n    return new FormulaError(\"#N/A\", `Argument type ${args.map(arg => Types[arg]).join(', ')} is missing.`)\r\n};\r\n\r\n/**\r\n * #ERROR!\r\n * Parse/Lex error or other unexpected errors\r\n * @param {string} msg\r\n * @param {object|Error} [details]\r\n * @return {FormulaError}\r\n * @constructor\r\n */\r\nFormulaError.ERROR = (msg, details) => {\r\n    return new FormulaError('#ERROR!', msg, details);\r\n}\r\n\r\nmodule.exports = FormulaError;\r\n", "// https://github.com/looker/ssf/blob/master/ssf.js\n/* ssf.js (C) 2013-present SheetJS -- http://sheetjs.com */\n\n/**\n * Spreadsheet formatter.\n * @type {{}}\n */\nclass SSF {\n}\n\n/**\n * The version of SSF.\n * @type {string}\n */\nSSF.version = '0.10.3';\n\nfunction _strrev(x) {\n    let o = \"\", i = x.length - 1;\n    while (i >= 0) o += x.charAt(i--);\n    return o;\n}\n\nfunction fill(c, l) {\n    let o = \"\";\n    while (o.length < l) o += c;\n    return o;\n}\n\nfunction pad0(v, d) {\n    let t = \"\" + v;\n    return t.length >= d ? t : fill('0', d - t.length) + t;\n}\n\nfunction pad_(v, d) {\n    let t = \"\" + v;\n    return t.length >= d ? t : fill(' ', d - t.length) + t;\n}\n\nfunction rpad_(v, d) {\n    let t = \"\" + v;\n    return t.length >= d ? t : t + fill(' ', d - t.length);\n}\n\nfunction pad0r1(v, d) {\n    let t = \"\" + Math.round(v);\n    return t.length >= d ? t : fill('0', d - t.length) + t;\n}\n\nfunction pad0r2(v, d) {\n    let t = \"\" + v;\n    return t.length >= d ? t : fill('0', d - t.length) + t;\n}\n\nconst p2_32 = Math.pow(2, 32);\n\nfunction pad0r(v, d) {\n    if (v > p2_32 || v < -p2_32) return pad0r1(v, d);\n    const i = Math.round(v);\n    return pad0r2(i, d);\n}\n\nfunction isgeneral(s, i) {\n    i = i || 0;\n    return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;\n}\n\nconst days = [\n    ['Sun', 'Sunday'],\n    ['Mon', 'Monday'],\n    ['Tue', 'Tuesday'],\n    ['Wed', 'Wednesday'],\n    ['Thu', 'Thursday'],\n    ['Fri', 'Friday'],\n    ['Sat', 'Saturday']\n];\nconst months = [\n    ['J', 'Jan', 'January'],\n    ['F', 'Feb', 'February'],\n    ['M', 'Mar', 'March'],\n    ['A', 'Apr', 'April'],\n    ['M', 'May', 'May'],\n    ['J', 'Jun', 'June'],\n    ['J', 'Jul', 'July'],\n    ['A', 'Aug', 'August'],\n    ['S', 'Sep', 'September'],\n    ['O', 'Oct', 'October'],\n    ['N', 'Nov', 'November'],\n    ['D', 'Dec', 'December']\n];\n\nfunction init_table(t) {\n    t[0] = 'General';\n    t[1] = '0';\n    t[2] = '0.00';\n    t[3] = '#,##0';\n    t[4] = '#,##0.00';\n    t[9] = '0%';\n    t[10] = '0.00%';\n    t[11] = '0.00E+00';\n    t[12] = '# ?/?';\n    t[13] = '# ??/??';\n    t[14] = 'm/d/yy';\n    t[15] = 'd-mmm-yy';\n    t[16] = 'd-mmm';\n    t[17] = 'mmm-yy';\n    t[18] = 'h:mm AM/PM';\n    t[19] = 'h:mm:ss AM/PM';\n    t[20] = 'h:mm';\n    t[21] = 'h:mm:ss';\n    t[22] = 'm/d/yy h:mm';\n    t[37] = '#,##0 ;(#,##0)';\n    t[38] = '#,##0 ;[Red](#,##0)';\n    t[39] = '#,##0.00;(#,##0.00)';\n    t[40] = '#,##0.00;[Red](#,##0.00)';\n    t[45] = 'mm:ss';\n    t[46] = '[h]:mm:ss';\n    t[47] = 'mmss.0';\n    t[48] = '##0.0E+0';\n    t[49] = '@';\n    t[56] = '\"\u4E0A\u5348/\u4E0B\u5348 \"hh\"\u6642\"mm\"\u5206\"ss\"\u79D2 \"';\n    t[65535] = 'General';\n}\n\nconst table_fmt = {};\ninit_table(table_fmt);\n\nfunction frac(x, D, mixed) {\n    const sgn = x < 0 ? -1 : 1;\n    let B = x * sgn;\n    let P_2 = 0, P_1 = 1, P = 0;\n    let Q_2 = 1, Q_1 = 0, Q = 0;\n    let A = Math.floor(B);\n    while (Q_1 < D) {\n        A = Math.floor(B);\n        P = A * P_1 + P_2;\n        Q = A * Q_1 + Q_2;\n        if ((B - A) < 0.00000005) break;\n        B = 1 / (B - A);\n        P_2 = P_1;\n        P_1 = P;\n        Q_2 = Q_1;\n        Q_1 = Q;\n    }\n    if (Q > D) {\n        if (Q_1 > D) {\n            Q = Q_2;\n            P = P_2;\n        } else {\n            Q = Q_1;\n            P = P_1;\n        }\n    }\n    if (!mixed) return [0, sgn * P, Q];\n    const q = Math.floor(sgn * P / Q);\n    return [q, sgn * P - q * Q, Q];\n}\n\nfunction parse_date_code(v, opts, b2) {\n    if (v > 2958465 || v < 0) return null;\n    let date = (v | 0), time = Math.floor(86400 * (v - date)), dow = 0;\n    let dout = [];\n    const out = {D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0};\n    if (Math.abs(out.u) < 1e-6) out.u = 0;\n    if (opts && opts.date1904) date += 1462;\n    if (out.u > 0.9999) {\n        out.u = 0;\n        if (++time === 86400) {\n            out.T = time = 0;\n            ++date;\n            ++out.D;\n        }\n    }\n    if (date === 60) {\n        dout = b2 ? [1317, 10, 29] : [1900, 2, 29];\n        dow = 3;\n    } else if (date === 0) {\n        dout = b2 ? [1317, 8, 29] : [1900, 1, 0];\n        dow = 6;\n    } else {\n        if (date > 60) --date;\n        /* 1 = Jan 1 1900 in Gregorian */\n        const d = new Date(1900, 0, 1);\n        d.setDate(d.getDate() + date - 1);\n        dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];\n        dow = d.getDay();\n        if (date < 60) dow = (dow + 6) % 7;\n        if (b2) dow = fix_hijri(d, dout);\n    }\n    out.y = dout[0];\n    out.m = dout[1];\n    out.d = dout[2];\n    out.S = time % 60;\n    time = Math.floor(time / 60);\n    out.M = time % 60;\n    time = Math.floor(time / 60);\n    out.H = time;\n    out.q = dow;\n    return out;\n}\n\nSSF.parse_date_code = parse_date_code;\nconst basedate = new Date(1899, 11, 31, 0, 0, 0);\nconst dnthresh = basedate.getTime();\nconst base1904 = new Date(1900, 2, 1, 0, 0, 0);\n\nfunction datenum_local(v, date1904) {\n    let epoch = v.getTime();\n    if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1000;\n    else if (v >= base1904) epoch += 24 * 60 * 60 * 1000;\n    return (epoch - (dnthresh + (v.getTimezoneOffset() - basedate.getTimezoneOffset()) * 60000)) / (24 * 60 * 60 * 1000);\n}\n\nfunction general_fmt_int(v) {\n    return v.toString(10);\n}\n\nSSF._general_int = general_fmt_int;\nconst general_fmt_num = (function make_general_fmt_num() {\n    const gnr1 = /\\.(\\d*[1-9])0+$/, gnr2 = /\\.0*$/, gnr4 = /\\.(\\d*[1-9])0+/, gnr5 = /\\.0*[Ee]/,\n        gnr6 = /(E[+-])(\\d)$/;\n\n    function gfn2(v) {\n        const w = (v < 0 ? 12 : 11);\n        let o = gfn5(v.toFixed(12));\n        if (o.length <= w) return o;\n        o = v.toPrecision(10);\n        if (o.length <= w) return o;\n        return v.toExponential(5);\n    }\n\n    function gfn3(v) {\n        let o = v.toFixed(11).replace(gnr1, \".$1\");\n        if (o.length > (v < 0 ? 12 : 11)) o = v.toPrecision(6);\n        return o;\n    }\n\n    function gfn4(o) {\n        for (let i = 0; i !== o.length; ++i) if ((o.charCodeAt(i) | 0x20) === 101) return o.replace(gnr4, \".$1\").replace(gnr5, \"E\").replace(\"e\", \"E\").replace(gnr6, \"$10$2\");\n        return o;\n    }\n\n    function gfn5(o) {\n        return o.indexOf(\".\") > -1 ? o.replace(gnr2, \"\").replace(gnr1, \".$1\") : o;\n    }\n\n    return function general_fmt_num(v) {\n        let V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;\n        if (V >= -4 && V <= -1) o = v.toPrecision(10 + V);\n        else if (Math.abs(V) <= 9) o = gfn2(v);\n        else if (V === 10) o = v.toFixed(10).substr(0, 12);\n        else o = gfn3(v);\n        return gfn5(gfn4(o));\n    };\n})();\nSSF._general_num = general_fmt_num;\n\nfunction general_fmt(v, opts) {\n    switch (typeof v) {\n        case 'string':\n            return v;\n        case 'boolean':\n            return v ? \"TRUE\" : \"FALSE\";\n        case 'number':\n            return (v | 0) === v ? general_fmt_int(v) : general_fmt_num(v);\n        case 'undefined':\n            return \"\";\n        case 'object':\n            if (v == null) return \"\";\n            if (v instanceof Date) return format(14, datenum_local(v, opts && opts.date1904), opts);\n    }\n    throw new Error(\"unsupported value in General format: \" + v);\n}\n\nSSF._general = general_fmt;\n\nfunction fix_hijri() {\n    return 0;\n}\n\n/*jshint -W086 */\nfunction write_date(type, fmt, val, ss0) {\n    let o = \"\", ss = 0, tt = 0, y = val.y, out, outl = 0;\n    switch (type) {\n        case 98: /* 'b' buddhist year */\n            y = val.y + 543;\n        /* falls through */\n        case 121: /* 'y' year */\n            switch (fmt.length) {\n                case 1:\n                case 2:\n                    out = y % 100;\n                    outl = 2;\n                    break;\n                default:\n                    out = y % 10000;\n                    outl = 4;\n                    break;\n            }\n            break;\n        case 109: /* 'm' month */\n            switch (fmt.length) {\n                case 1:\n                case 2:\n                    out = val.m;\n                    outl = fmt.length;\n                    break;\n                case 3:\n                    return months[val.m - 1][1];\n                case 5:\n                    return months[val.m - 1][0];\n                default:\n                    return months[val.m - 1][2];\n            }\n            break;\n        case 100: /* 'd' day */\n            switch (fmt.length) {\n                case 1:\n                case 2:\n                    out = val.d;\n                    outl = fmt.length;\n                    break;\n                case 3:\n                    return days[val.q][0];\n                default:\n                    return days[val.q][1];\n            }\n            break;\n        case 104: /* 'h' 12-hour */\n            switch (fmt.length) {\n                case 1:\n                case 2:\n                    out = 1 + (val.H + 11) % 12;\n                    outl = fmt.length;\n                    break;\n                default:\n                    throw 'bad hour format: ' + fmt;\n            }\n            break;\n        case 72: /* 'H' 24-hour */\n            switch (fmt.length) {\n                case 1:\n                case 2:\n                    out = val.H;\n                    outl = fmt.length;\n                    break;\n                default:\n                    throw 'bad hour format: ' + fmt;\n            }\n            break;\n        case 77: /* 'M' minutes */\n            switch (fmt.length) {\n                case 1:\n                case 2:\n                    out = val.M;\n                    outl = fmt.length;\n                    break;\n                default:\n                    throw 'bad minute format: ' + fmt;\n            }\n            break;\n        case 115: /* 's' seconds */\n            if (fmt !== 's' && fmt !== 'ss' && fmt !== '.0' && fmt !== '.00' && fmt !== '.000') throw 'bad second format: ' + fmt;\n            if (val.u === 0 && (fmt === \"s\" || fmt === \"ss\")) return pad0(val.S, fmt.length);\n            if (ss0 >= 2) tt = ss0 === 3 ? 1000 : 100;\n            else tt = ss0 === 1 ? 10 : 1;\n            ss = Math.round((tt) * (val.S + val.u));\n            if (ss >= 60 * tt) ss = 0;\n            if (fmt === 's') return ss === 0 ? \"0\" : \"\" + ss / tt;\n            o = pad0(ss, 2 + ss0);\n            if (fmt === 'ss') return o.substr(0, 2);\n            return \".\" + o.substr(2, fmt.length - 1);\n        case 90: /* 'Z' absolute time */\n            switch (fmt) {\n                case '[h]':\n                case '[hh]':\n                    out = val.D * 24 + val.H;\n                    break;\n                case '[m]':\n                case '[mm]':\n                    out = (val.D * 24 + val.H) * 60 + val.M;\n                    break;\n                case '[s]':\n                case '[ss]':\n                    out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);\n                    break;\n                default:\n                    throw 'bad abstime format: ' + fmt;\n            }\n            outl = fmt.length === 3 ? 1 : 2;\n            break;\n        case 101: /* 'e' era */\n            out = y;\n            outl = 1;\n    }\n    if (outl > 0) return pad0(out, outl); else return \"\";\n}\n\n/*jshint +W086 */\nfunction commaify(s) {\n    const w = 3;\n    if (s.length <= w) return s;\n    let j = (s.length % w), o = s.substr(0, j);\n    for (; j !== s.length; j += w) o += (o.length > 0 ? \",\" : \"\") + s.substr(j, w);\n    return o;\n}\n\nconst write_num = (function make_write_num() {\n    const pct1 = /%/g;\n\n    function write_num_pct(type, fmt, val) {\n        const sfmt = fmt.replace(pct1, \"\"), mul = fmt.length - sfmt.length;\n        return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill(\"%\", mul);\n    }\n\n    function write_num_cm(type, fmt, val) {\n        let idx = fmt.length - 1;\n        while (fmt.charCodeAt(idx - 1) === 44) --idx;\n        return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));\n    }\n\n    function write_num_exp(fmt, val) {\n        let o;\n        let idx = fmt.indexOf(\"E\") - fmt.indexOf(\".\") - 1;\n        if (fmt.match(/^#+0.0E\\+0$/)) {\n            if (val === 0) return \"0.0E+0\";\n            else if (val < 0) return \"-\" + write_num_exp(fmt, -val);\n            let period = fmt.indexOf(\".\");\n            if (period === -1) period = fmt.indexOf('E');\n            let ee = Math.floor(Math.log(val) * Math.LOG10E) % period;\n            if (ee < 0) ee += period;\n            o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);\n            if (o.indexOf(\"e\") === -1) {\n                const fakee = Math.floor(Math.log(val) * Math.LOG10E);\n                if (o.indexOf(\".\") === -1) o = o.charAt(0) + \".\" + o.substr(1) + \"E+\" + (fakee - o.length + ee);\n                else o += \"E+\" + (fakee - ee);\n                while (o.substr(0, 2) === \"0.\") {\n                    o = o.charAt(0) + o.substr(2, period) + \".\" + o.substr(2 + period);\n                    o = o.replace(/^0+([1-9])/, \"$1\").replace(/^0+\\./, \"0.\");\n                }\n                o = o.replace(/\\+-/, \"-\");\n            }\n            o = o.replace(/^([+-]?)(\\d*)\\.(\\d*)[Ee]/, function ($$, $1, $2, $3) {\n                return $1 + $2 + $3.substr(0, (period + ee) % period) + \".\" + $3.substr(ee) + \"E\";\n            });\n        } else o = val.toExponential(idx);\n        if (fmt.match(/E\\+00$/) && o.match(/e[+-]\\d$/)) o = o.substr(0, o.length - 1) + \"0\" + o.charAt(o.length - 1);\n        if (fmt.match(/E\\-/) && o.match(/e\\+/)) o = o.replace(/e\\+/, \"e\");\n        return o.replace(\"e\", \"E\");\n    }\n\n    const frac1 = /# (\\?+)( ?)\\/( ?)(\\d+)/;\n\n    function write_num_f1(r, aval, sign) {\n        const den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);\n        let myn = (rr - base * den), myd = den;\n        return sign + (base === 0 ? \"\" : \"\" + base) + \" \" + (myn === 0 ? fill(\" \", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + \"/\" + r[3] + pad0(myd, r[4].length));\n    }\n\n    function write_num_f2(r, aval, sign) {\n        return sign + (aval === 0 ? \"\" : \"\" + aval) + fill(\" \", r[1].length + 2 + r[4].length);\n    }\n\n    const dec1 = /^#*0*\\.([0#]+)/;\n    const closeparen = /\\).*[0#]/;\n    const phone = /\\(###\\) ###\\\\?-####/;\n\n    function hashq(str) {\n        let o = \"\", cc;\n        for (let i = 0; i !== str.length; ++i) switch ((cc = str.charCodeAt(i))) {\n            case 35:\n                break;\n            case 63:\n                o += \" \";\n                break;\n            case 48:\n                o += \"0\";\n                break;\n            default:\n                o += String.fromCharCode(cc);\n        }\n        return o;\n    }\n\n    function rnd(val, d) {\n        const dd = Math.pow(10, d);\n        return \"\" + (Math.round(val * dd) / dd);\n    }\n\n    function dec(val, d) {\n        if (d < ('' + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {\n            return 0;\n        }\n        return Math.round((val - Math.floor(val)) * Math.pow(10, d));\n    }\n\n    function carry(val, d) {\n        if (d < ('' + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {\n            return 1;\n        }\n        return 0;\n    }\n\n    function flr(val) {\n        if (val < 2147483647 && val > -2147483648) return \"\" + (val >= 0 ? (val | 0) : (val - 1 | 0));\n        return \"\" + Math.floor(val);\n    }\n\n    function write_num_flt(type, fmt, val) {\n        if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {\n            const ffmt = fmt.replace(/\\( */, \"\").replace(/ \\)/, \"\").replace(/\\)/, \"\");\n            if (val >= 0) return write_num_flt('n', ffmt, val);\n            return '(' + write_num_flt('n', ffmt, -val) + ')';\n        }\n        if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);\n        if (fmt.indexOf('%') !== -1) return write_num_pct(type, fmt, val);\n        if (fmt.indexOf('E') !== -1) return write_num_exp(fmt, val);\n        if (fmt.charCodeAt(0) === 36) return \"$\" + write_num_flt(type, fmt.substr(fmt.charAt(1) == ' ' ? 2 : 1), val);\n        let o;\n        let r, ri, ff, aval = Math.abs(val), sign = val < 0 ? \"-\" : \"\";\n        if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);\n        if (fmt.match(/^[#?]+$/)) {\n            o = pad0r(val, 0);\n            if (o === \"0\") o = \"\";\n            return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;\n        }\n        if ((r = fmt.match(frac1))) return write_num_f1(r, aval, sign);\n        if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf(\"0\"));\n        if ((r = fmt.match(dec1))) {\n            o = rnd(val, r[1].length).replace(/^([^\\.]+)$/, \"$1.\" + hashq(r[1])).replace(/\\.$/, \".\" + hashq(r[1])).replace(/\\.(\\d*)$/, function ($$, $1) {\n                return \".\" + $1 + fill(\"0\", hashq(r[1]).length - $1.length);\n            });\n            return fmt.indexOf(\"0.\") !== -1 ? o : o.replace(/^0\\./, \".\");\n        }\n        fmt = fmt.replace(/^#+([0.])/, \"$1\");\n        if ((r = fmt.match(/^(0*)\\.(#*)$/))) {\n            return sign + rnd(aval, r[2].length).replace(/\\.(\\d*[1-9])0*$/, \".$1\").replace(/^(-?\\d*)$/, \"$1.\").replace(/^0\\./, r[1].length ? \"0.\" : \".\");\n        }\n        if ((r = fmt.match(/^#{1,3},##0(\\.?)$/))) return sign + commaify(pad0r(aval, 0));\n        if ((r = fmt.match(/^#,##0\\.([#0]*0)$/))) {\n            return val < 0 ? \"-\" + write_num_flt(type, fmt, -val) : commaify(\"\" + (Math.floor(val) + carry(val, r[1].length))) + \".\" + pad0(dec(val, r[1].length), r[1].length);\n        }\n        if ((r = fmt.match(/^#,#*,#0/))) return write_num_flt(type, fmt.replace(/^#,#*,/, \"\"), val);\n        if ((r = fmt.match(/^([0#]+)(\\\\?-([0#]+))+$/))) {\n            o = _strrev(write_num_flt(type, fmt.replace(/[\\\\-]/g, \"\"), val));\n            ri = 0;\n            return _strrev(_strrev(fmt.replace(/\\\\/g, \"\")).replace(/[0#]/g, function (x) {\n                return ri < o.length ? o.charAt(ri++) : x === '0' ? '0' : \"\";\n            }));\n        }\n        if (fmt.match(phone)) {\n            o = write_num_flt(type, \"##########\", val);\n            return \"(\" + o.substr(0, 3) + \") \" + o.substr(3, 3) + \"-\" + o.substr(6);\n        }\n        let oa = \"\";\n        if ((r = fmt.match(/^([#0?]+)( ?)\\/( ?)([#0?]+)/))) {\n            ri = Math.min(r[4].length, 7);\n            ff = frac(aval, Math.pow(10, ri) - 1, false);\n            o = \"\" + sign;\n            oa = write_num(\"n\", r[1], ff[1]);\n            if (oa.charAt(oa.length - 1) === \" \") oa = oa.substr(0, oa.length - 1) + \"0\";\n            o += oa + r[2] + \"/\" + r[3];\n            oa = rpad_(ff[2], ri);\n            if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;\n            o += oa;\n            return o;\n        }\n        if ((r = fmt.match(/^# ([#0?]+)( ?)\\/( ?)([#0?]+)/))) {\n            ri = Math.min(Math.max(r[1].length, r[4].length), 7);\n            ff = frac(aval, Math.pow(10, ri) - 1, true);\n            return sign + (ff[0] || (ff[1] ? \"\" : \"0\")) + \" \" + (ff[1] ? pad_(ff[1], ri) + r[2] + \"/\" + r[3] + rpad_(ff[2], ri) : fill(\" \", 2 * ri + 1 + r[2].length + r[3].length));\n        }\n        if ((r = fmt.match(/^[#0?]+$/))) {\n            o = pad0r(val, 0);\n            if (fmt.length <= o.length) return o;\n            return hashq(fmt.substr(0, fmt.length - o.length)) + o;\n        }\n        if ((r = fmt.match(/^([#0?]+)\\.([#0]+)$/))) {\n            o = \"\" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, \"$1\");\n            ri = o.indexOf(\".\");\n            const lres = fmt.indexOf(\".\") - ri, rres = fmt.length - o.length - lres;\n            return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));\n        }\n        if ((r = fmt.match(/^00,000\\.([#0]*0)$/))) {\n            ri = dec(val, r[1].length);\n            return val < 0 ? \"-\" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\\d,\\d{3}$/, \"0$&\").replace(/^\\d*$/, function ($$) {\n                return \"00,\" + ($$.length < 3 ? pad0(0, 3 - $$.length) : \"\") + $$;\n            }) + \".\" + pad0(ri, r[1].length);\n        }\n        switch (fmt) {\n            case \"###,##0.00\":\n                return write_num_flt(type, \"#,##0.00\", val);\n            case \"###,###\":\n            case \"##,###\":\n            case \"#,###\":\n                const x = commaify(pad0r(aval, 0));\n                return x !== \"0\" ? sign + x : \"\";\n            case \"###,###.00\":\n                return write_num_flt(type, \"###,##0.00\", val).replace(/^0\\./, \".\");\n            case \"#,###.00\":\n                return write_num_flt(type, \"#,##0.00\", val).replace(/^0\\./, \".\");\n            default:\n        }\n        throw new Error(\"unsupported format |\" + fmt + \"|\");\n    }\n\n    function write_num_cm2(type, fmt, val) {\n        let idx = fmt.length - 1;\n        while (fmt.charCodeAt(idx - 1) === 44) --idx;\n        return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));\n    }\n\n    function write_num_pct2(type, fmt, val) {\n        const sfmt = fmt.replace(pct1, \"\"), mul = fmt.length - sfmt.length;\n        return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill(\"%\", mul);\n    }\n\n    function write_num_exp2(fmt, val) {\n        let o;\n        let idx = fmt.indexOf(\"E\") - fmt.indexOf(\".\") - 1;\n        if (fmt.match(/^#+0.0E\\+0$/)) {\n            if (val === 0) return \"0.0E+0\";\n            else if (val < 0) return \"-\" + write_num_exp2(fmt, -val);\n            let period = fmt.indexOf(\".\");\n            if (period === -1) period = fmt.indexOf('E');\n            let ee = Math.floor(Math.log(val) * Math.LOG10E) % period;\n            if (ee < 0) ee += period;\n            o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);\n            if (!o.match(/[Ee]/)) {\n                const fakee = Math.floor(Math.log(val) * Math.LOG10E);\n                if (o.indexOf(\".\") === -1) o = o.charAt(0) + \".\" + o.substr(1) + \"E+\" + (fakee - o.length + ee);\n                else o += \"E+\" + (fakee - ee);\n                o = o.replace(/\\+-/, \"-\");\n            }\n            o = o.replace(/^([+-]?)(\\d*)\\.(\\d*)[Ee]/, function ($$, $1, $2, $3) {\n                return $1 + $2 + $3.substr(0, (period + ee) % period) + \".\" + $3.substr(ee) + \"E\";\n            });\n        } else o = val.toExponential(idx);\n        if (fmt.match(/E\\+00$/) && o.match(/e[+-]\\d$/)) o = o.substr(0, o.length - 1) + \"0\" + o.charAt(o.length - 1);\n        if (fmt.match(/E\\-/) && o.match(/e\\+/)) o = o.replace(/e\\+/, \"e\");\n        return o.replace(\"e\", \"E\");\n    }\n\n    function write_num_int(type, fmt, val) {\n        if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {\n            const ffmt = fmt.replace(/\\( */, \"\").replace(/ \\)/, \"\").replace(/\\)/, \"\");\n            if (val >= 0) return write_num_int('n', ffmt, val);\n            return '(' + write_num_int('n', ffmt, -val) + ')';\n        }\n        if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);\n        if (fmt.indexOf('%') !== -1) return write_num_pct2(type, fmt, val);\n        if (fmt.indexOf('E') !== -1) return write_num_exp2(fmt, val);\n        if (fmt.charCodeAt(0) === 36) return \"$\" + write_num_int(type, fmt.substr(fmt.charAt(1) == ' ' ? 2 : 1), val);\n        let o;\n        let r, ri, ff, aval = Math.abs(val), sign = val < 0 ? \"-\" : \"\";\n        if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);\n        if (fmt.match(/^[#?]+$/)) {\n            o = (\"\" + val);\n            if (val === 0) o = \"\";\n            return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;\n        }\n        if ((r = fmt.match(frac1))) return write_num_f2(r, aval, sign);\n        if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf(\"0\"));\n        if ((r = fmt.match(dec1))) {\n            o = (\"\" + val).replace(/^([^\\.]+)$/, \"$1.\" + hashq(r[1])).replace(/\\.$/, \".\" + hashq(r[1]));\n            o = o.replace(/\\.(\\d*)$/, function ($$, $1) {\n                return \".\" + $1 + fill(\"0\", hashq(r[1]).length - $1.length);\n            });\n            return fmt.indexOf(\"0.\") !== -1 ? o : o.replace(/^0\\./, \".\");\n        }\n        fmt = fmt.replace(/^#+([0.])/, \"$1\");\n        if ((r = fmt.match(/^(0*)\\.(#*)$/))) {\n            return sign + (\"\" + aval).replace(/\\.(\\d*[1-9])0*$/, \".$1\").replace(/^(-?\\d*)$/, \"$1.\").replace(/^0\\./, r[1].length ? \"0.\" : \".\");\n        }\n        if ((r = fmt.match(/^#{1,3},##0(\\.?)$/))) return sign + commaify((\"\" + aval));\n        if ((r = fmt.match(/^#,##0\\.([#0]*0)$/))) {\n            return val < 0 ? \"-\" + write_num_int(type, fmt, -val) : commaify((\"\" + val)) + \".\" + fill('0', r[1].length);\n        }\n        if ((r = fmt.match(/^#,#*,#0/))) return write_num_int(type, fmt.replace(/^#,#*,/, \"\"), val);\n        if ((r = fmt.match(/^([0#]+)(\\\\?-([0#]+))+$/))) {\n            o = _strrev(write_num_int(type, fmt.replace(/[\\\\-]/g, \"\"), val));\n            ri = 0;\n            return _strrev(_strrev(fmt.replace(/\\\\/g, \"\")).replace(/[0#]/g, function (x) {\n                return ri < o.length ? o.charAt(ri++) : x === '0' ? '0' : \"\";\n            }));\n        }\n        if (fmt.match(phone)) {\n            o = write_num_int(type, \"##########\", val);\n            return \"(\" + o.substr(0, 3) + \") \" + o.substr(3, 3) + \"-\" + o.substr(6);\n        }\n        let oa = \"\";\n        if ((r = fmt.match(/^([#0?]+)( ?)\\/( ?)([#0?]+)/))) {\n            ri = Math.min(r[4].length, 7);\n            ff = frac(aval, Math.pow(10, ri) - 1, false);\n            o = \"\" + sign;\n            oa = write_num(\"n\", r[1], ff[1]);\n            if (oa.charAt(oa.length - 1) == \" \") oa = oa.substr(0, oa.length - 1) + \"0\";\n            o += oa + r[2] + \"/\" + r[3];\n            oa = rpad_(ff[2], ri);\n            if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;\n            o += oa;\n            return o;\n        }\n        if ((r = fmt.match(/^# ([#0?]+)( ?)\\/( ?)([#0?]+)/))) {\n            ri = Math.min(Math.max(r[1].length, r[4].length), 7);\n            ff = frac(aval, Math.pow(10, ri) - 1, true);\n            return sign + (ff[0] || (ff[1] ? \"\" : \"0\")) + \" \" + (ff[1] ? pad_(ff[1], ri) + r[2] + \"/\" + r[3] + rpad_(ff[2], ri) : fill(\" \", 2 * ri + 1 + r[2].length + r[3].length));\n        }\n        if ((r = fmt.match(/^[#0?]+$/))) {\n            o = \"\" + val;\n            if (fmt.length <= o.length) return o;\n            return hashq(fmt.substr(0, fmt.length - o.length)) + o;\n        }\n        if ((r = fmt.match(/^([#0]+)\\.([#0]+)$/))) {\n            o = \"\" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, \"$1\");\n            ri = o.indexOf(\".\");\n            let lres = fmt.indexOf(\".\") - ri, rres = fmt.length - o.length - lres;\n            return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));\n        }\n        if ((r = fmt.match(/^00,000\\.([#0]*0)$/))) {\n            return val < 0 ? \"-\" + write_num_int(type, fmt, -val) : commaify(\"\" + val).replace(/^\\d,\\d{3}$/, \"0$&\").replace(/^\\d*$/, function ($$) {\n                return \"00,\" + ($$.length < 3 ? pad0(0, 3 - $$.length) : \"\") + $$;\n            }) + \".\" + pad0(0, r[1].length);\n        }\n        switch (fmt) {\n            case \"###,###\":\n            case \"##,###\":\n            case \"#,###\":\n                const x = commaify(\"\" + aval);\n                return x !== \"0\" ? sign + x : \"\";\n            default:\n                if (fmt.match(/\\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(\".\")), val) + hashq(fmt.slice(fmt.lastIndexOf(\".\")));\n        }\n        throw new Error(\"unsupported format |\" + fmt + \"|\");\n    }\n\n    return function write_num(type, fmt, val) {\n        return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);\n    };\n})();\n\nfunction split_fmt(fmt) {\n    const out = [];\n    let in_str = false, j = 0;\n    for (let i = 0; i < fmt.length; ++i) switch ((/*cc=*/fmt.charCodeAt(i))) {\n        case 34: /* '\"' */\n            in_str = !in_str;\n            break;\n        case 95:\n        case 42:\n        case 92: /* '_' '*' '\\\\' */\n            ++i;\n            break;\n        case 59: /* ';' */\n            out[out.length] = fmt.substr(j, i - j);\n            j = i + 1;\n    }\n    out[out.length] = fmt.substr(j);\n    if (in_str === true) throw new Error(\"Format |\" + fmt + \"| unterminated string \");\n    return out;\n}\n\nSSF._split = split_fmt;\nconst abstime = /\\[[HhMmSs]*\\]/;\n\nfunction fmt_is_date(fmt) {\n    let i = 0, /*cc = 0,*/ c = \"\", o = \"\";\n    while (i < fmt.length) {\n        switch ((c = fmt.charAt(i))) {\n            case 'G':\n                if (isgeneral(fmt, i)) i += 6;\n                i++;\n                break;\n            case '\"':\n                for (; (/*cc=*/fmt.charCodeAt(++i)) !== 34 && i < fmt.length;) ++i;\n                ++i;\n                break;\n            case '\\\\':\n                i += 2;\n                break;\n            case '_':\n                i += 2;\n                break;\n            case '@':\n                ++i;\n                break;\n            case 'B':\n            case 'b':\n                if (fmt.charAt(i + 1) === \"1\" || fmt.charAt(i + 1) === \"2\") return true;\n            /* falls through */\n            case 'M':\n            case 'D':\n            case 'Y':\n            case 'H':\n            case 'S':\n            case 'E':\n            /* falls through */\n            case 'm':\n            case 'd':\n            case 'y':\n            case 'h':\n            case 's':\n            case 'e':\n            case 'g':\n                return true;\n            case 'A':\n            case 'a':\n                if (fmt.substr(i, 3).toUpperCase() === \"A/P\") return true;\n                if (fmt.substr(i, 5).toUpperCase() === \"AM/PM\") return true;\n                ++i;\n                break;\n            case '[':\n                o = c;\n                while (fmt.charAt(i++) !== ']' && i < fmt.length) o += fmt.charAt(i);\n                if (o.match(abstime)) return true;\n                break;\n            case '.':\n            /* falls through */\n            case '0':\n            case '#':\n                while (i < fmt.length && (\"0#?.,E+-%\".indexOf(c = fmt.charAt(++i)) > -1 || (c == '\\\\' && fmt.charAt(i + 1) == \"-\" && \"0#\".indexOf(fmt.charAt(i + 2)) > -1))) {/* empty */\n                }\n                break;\n            case '?':\n                while (fmt.charAt(++i) === c) {/* empty */\n                }\n                break;\n            case '*':\n                ++i;\n                if (fmt.charAt(i) === ' ' || fmt.charAt(i) === '*') ++i;\n                break;\n            case '(':\n            case ')':\n                ++i;\n                break;\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                while (i < fmt.length && \"0123456789\".indexOf(fmt.charAt(++i)) > -1) {/* empty */\n                }\n                break;\n            case ' ':\n                ++i;\n                break;\n            default:\n                ++i;\n                break;\n        }\n    }\n    return false;\n}\n\nSSF.is_date = fmt_is_date;\n\nfunction eval_fmt(fmt, v, opts, flen) {\n    let out = [], o = \"\", i = 0, c = \"\", lst = 't', dt, j, cc;\n    let hr = 'H';\n    /* Tokenize */\n    while (i < fmt.length) {\n        switch ((c = fmt.charAt(i))) {\n            case 'G': /* General */\n                if (!isgeneral(fmt, i)) throw new Error('unrecognized character ' + c + ' in ' + fmt);\n                out[out.length] = {t: 'G', v: 'General'};\n                i += 7;\n                break;\n            case '\"': /* Literal text */\n                for (o = \"\"; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length;) o += String.fromCharCode(cc);\n                out[out.length] = {t: 't', v: o};\n                ++i;\n                break;\n            case '\\\\':\n                const w = fmt.charAt(++i), t = (w === \"(\" || w === \")\") ? w : 't';\n                out[out.length] = {t: t, v: w};\n                ++i;\n                break;\n            case '_':\n                out[out.length] = {t: 't', v: \" \"};\n                i += 2;\n                break;\n            case '@': /* Text Placeholder */\n                out[out.length] = {t: 'T', v: v};\n                ++i;\n                break;\n            case 'B':\n            case 'b':\n                if (fmt.charAt(i + 1) === \"1\" || fmt.charAt(i + 1) === \"2\") {\n                    if (dt == null) {\n                        dt = parse_date_code(v, opts, fmt.charAt(i + 1) === \"2\");\n                        if (dt == null) return \"\";\n                    }\n                    out[out.length] = {t: 'X', v: fmt.substr(i, 2)};\n                    lst = c;\n                    i += 2;\n                    break;\n                }\n            /* falls through */\n            case 'M':\n            case 'D':\n            case 'Y':\n            case 'H':\n            case 'S':\n            case 'E':\n                c = c.toLowerCase();\n            /* falls through */\n            case 'm':\n            case 'd':\n            case 'y':\n            case 'h':\n            case 's':\n            case 'e':\n            case 'g':\n                if (v < 0) return \"\";\n                if (dt == null) {\n                    dt = parse_date_code(v, opts);\n                    if (dt == null) return \"\";\n                }\n                o = c;\n                while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c) o += c;\n                if (c === 'm' && lst.toLowerCase() === 'h') c = 'M';\n                if (c === 'h') c = hr;\n                out[out.length] = {t: c, v: o};\n                lst = c;\n                break;\n            case 'A':\n            case 'a':\n                const q = {t: c, v: c};\n                if (dt == null) dt = parse_date_code(v, opts);\n                if (fmt.substr(i, 3).toUpperCase() === \"A/P\") {\n                    if (dt != null) q.v = dt.H >= 12 ? \"P\" : \"A\";\n                    q.t = 'T';\n                    hr = 'h';\n                    i += 3;\n                } else if (fmt.substr(i, 5).toUpperCase() === \"AM/PM\") {\n                    if (dt != null) q.v = dt.H >= 12 ? \"PM\" : \"AM\";\n                    q.t = 'T';\n                    i += 5;\n                    hr = 'h';\n                } else {\n                    q.t = \"t\";\n                    ++i;\n                }\n                if (dt == null && q.t === 'T') return \"\";\n                out[out.length] = q;\n                lst = c;\n                break;\n            case '[':\n                o = c;\n                while (fmt.charAt(i++) !== ']' && i < fmt.length) o += fmt.charAt(i);\n                if (o.slice(-1) !== ']') throw 'unterminated \"[\" block: |' + o + '|';\n                if (o.match(abstime)) {\n                    if (dt == null) {\n                        dt = parse_date_code(v, opts);\n                        if (dt == null) return \"\";\n                    }\n                    out[out.length] = {t: 'Z', v: o.toLowerCase()};\n                    lst = o.charAt(1);\n                } else if (o.indexOf(\"$\") > -1) {\n                    o = (o.match(/\\$([^-\\[\\]]*)/) || [])[1] || \"$\";\n                    if (!fmt_is_date(fmt)) out[out.length] = {t: 't', v: o};\n                }\n                break;\n            /* Numbers */\n            case '.':\n                if (dt != null) {\n                    o = c;\n                    while (++i < fmt.length && (c = fmt.charAt(i)) === \"0\") o += c;\n                    out[out.length] = {t: 's', v: o};\n                    break;\n                }\n            /* falls through */\n            case '0':\n            case '#':\n                o = c;\n                while ((++i < fmt.length && \"0#?.,E+-%\".indexOf(c = fmt.charAt(i)) > -1) || (c == '\\\\' && fmt.charAt(i + 1) == \"-\" && i < fmt.length - 2 && \"0#\".indexOf(fmt.charAt(i + 2)) > -1)) o += c;\n                out[out.length] = {t: 'n', v: o};\n                break;\n            case '?':\n                o = c;\n                while (fmt.charAt(++i) === c) o += c;\n                out[out.length] = {t: c, v: o};\n                lst = c;\n                break;\n            case '*':\n                ++i;\n                if (fmt.charAt(i) === ' ' || fmt.charAt(i) === '*') ++i;\n                break; // **\n            case '(':\n            case ')':\n                out[out.length] = {t: (flen === 1 || (typeof v === 'number' && v < 0) ? 't' : c), v: c};\n                ++i;\n                break;\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                o = c;\n                while (i < fmt.length && \"0123456789\".indexOf(fmt.charAt(++i)) > -1) o += fmt.charAt(i);\n                out[out.length] = {t: 'D', v: o};\n                break;\n            case ' ':\n                out[out.length] = {t: c, v: c};\n                ++i;\n                break;\n            default:\n                if (\",$-+/():!^&'~{}<>=\u20ACacfijklopqrtuvwxzP\".indexOf(c) === -1) throw new Error('unrecognized character ' + c + ' in ' + fmt);\n                out[out.length] = {t: 't', v: c};\n                ++i;\n                break;\n        }\n    }\n    let bt = 0, ss0 = 0, ssm;\n    for (i = out.length - 1, lst = 't'; i >= 0; --i) {\n        switch (out[i].t) {\n            case 'h':\n            case 'H':\n                out[i].t = hr;\n                lst = 'h';\n                if (bt < 1) bt = 1;\n                break;\n            case 's':\n                if ((ssm = out[i].v.match(/\\.0+$/))) ss0 = Math.max(ss0, ssm[0].length - 1);\n                if (bt < 3) bt = 3;\n            /* falls through */\n            case 'd':\n            case 'y':\n            case 'M':\n            case 'e':\n                lst = out[i].t;\n                break;\n            case 'm':\n                if (lst === 's') {\n                    out[i].t = 'M';\n                    if (bt < 2) bt = 2;\n                }\n                break;\n            case 'X': /*if(out[i].v === \"B2\");*/\n                break;\n            case 'Z':\n                if (bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;\n                if (bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;\n                if (bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;\n        }\n    }\n    switch (bt) {\n        case 0:\n            break;\n        case 1:\n            if (dt.u >= 0.5) {\n                dt.u = 0;\n                ++dt.S;\n            }\n            if (dt.S >= 60) {\n                dt.S = 0;\n                ++dt.M;\n            }\n            if (dt.M >= 60) {\n                dt.M = 0;\n                ++dt.H;\n            }\n            break;\n        case 2:\n            if (dt.u >= 0.5) {\n                dt.u = 0;\n                ++dt.S;\n            }\n            if (dt.S >= 60) {\n                dt.S = 0;\n                ++dt.M;\n            }\n            break;\n    }\n    /* replace fields */\n    let nstr = \"\", jj;\n    for (i = 0; i < out.length; ++i) {\n        switch (out[i].t) {\n            case 't':\n            case 'T':\n            case ' ':\n            case 'D':\n                break;\n            case 'X':\n                out[i].v = \"\";\n                out[i].t = \";\";\n                break;\n            case 'd':\n            case 'm':\n            case 'y':\n            case 'h':\n            case 'H':\n            case 'M':\n            case 's':\n            case 'e':\n            case 'b':\n            case 'Z':\n                out[i].v = write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);\n                out[i].t = 't';\n                break;\n            case 'n':\n            case '(':\n            case '?':\n                jj = i + 1;\n                while (out[jj] != null && (\n                    (c = out[jj].t) === \"?\" || c === \"D\" ||\n                    ((c === \" \" || c === \"t\") && out[jj + 1] != null && (out[jj + 1].t === '?' || out[jj + 1].t === \"t\" && out[jj + 1].v === '/')) ||\n                    (out[i].t === '(' && (c === ' ' || c === 'n' || c === ')')) ||\n                    (c === 't' && (out[jj].v === '/' || out[jj].v === ' ' && out[jj + 1] != null && out[jj + 1].t === '?'))\n                )) {\n                    out[i].v += out[jj].v;\n                    out[jj] = {v: \"\", t: \";\"};\n                    ++jj;\n                }\n                nstr += out[i].v;\n                i = jj - 1;\n                break;\n            case 'G':\n                out[i].t = 't';\n                out[i].v = general_fmt(v, opts);\n                break;\n        }\n    }\n    let vv = \"\", myv, ostr;\n    if (nstr.length > 0) {\n        if (nstr.charCodeAt(0) === 40) /* '(' */ {\n            myv = (v < 0 && nstr.charCodeAt(0) === 45 ? -v : v);\n            ostr = write_num('(', nstr, myv);\n        } else {\n            myv = (v < 0 && flen > 1 ? -v : v);\n            ostr = write_num('n', nstr, myv);\n            if (myv < 0 && out[0] && out[0].t === 't') {\n                ostr = ostr.substr(1);\n                out[0].v = \"-\" + out[0].v;\n            }\n        }\n        jj = ostr.length - 1;\n        let decpt = out.length;\n        for (i = 0; i < out.length; ++i) if (out[i] != null && out[i].t !== 't' && out[i].v.indexOf(\".\") > -1) {\n            decpt = i;\n            break;\n        }\n        let lasti = out.length;\n        if (decpt === out.length && ostr.indexOf(\"E\") === -1) {\n            for (i = out.length - 1; i >= 0; --i) {\n                if (out[i] == null || 'n?('.indexOf(out[i].t) === -1) continue;\n                if (jj >= out[i].v.length - 1) {\n                    jj -= out[i].v.length;\n                    out[i].v = ostr.substr(jj + 1, out[i].v.length);\n                } else if (jj < 0) out[i].v = \"\";\n                else {\n                    out[i].v = ostr.substr(0, jj + 1);\n                    jj = -1;\n                }\n                out[i].t = 't';\n                lasti = i;\n            }\n            if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;\n        } else if (decpt !== out.length && ostr.indexOf(\"E\") === -1) {\n            jj = ostr.indexOf(\".\") - 1;\n            for (i = decpt; i >= 0; --i) {\n                if (out[i] == null || 'n?('.indexOf(out[i].t) === -1) continue;\n                j = out[i].v.indexOf(\".\") > -1 && i === decpt ? out[i].v.indexOf(\".\") - 1 : out[i].v.length - 1;\n                vv = out[i].v.substr(j + 1);\n                for (; j >= 0; --j) {\n                    if (jj >= 0 && (out[i].v.charAt(j) === \"0\" || out[i].v.charAt(j) === \"#\")) vv = ostr.charAt(jj--) + vv;\n                }\n                out[i].v = vv;\n                out[i].t = 't';\n                lasti = i;\n            }\n            if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;\n            jj = ostr.indexOf(\".\") + 1;\n            for (i = decpt; i < out.length; ++i) {\n                if (out[i] == null || ('n?('.indexOf(out[i].t) === -1 && i !== decpt)) continue;\n                j = out[i].v.indexOf(\".\") > -1 && i === decpt ? out[i].v.indexOf(\".\") + 1 : 0;\n                vv = out[i].v.substr(0, j);\n                for (; j < out[i].v.length; ++j) {\n                    if (jj < ostr.length) vv += ostr.charAt(jj++);\n                }\n                out[i].v = vv;\n                out[i].t = 't';\n                lasti = i;\n            }\n        }\n    }\n    for (i = 0; i < out.length; ++i) if (out[i] != null && 'n(?'.indexOf(out[i].t) > -1) {\n        myv = (flen > 1 && v < 0 && i > 0 && out[i - 1].v === \"-\" ? -v : v);\n        out[i].v = write_num(out[i].t, out[i].v, myv);\n        out[i].t = 't';\n    }\n    let retval = \"\";\n    for (i = 0; i !== out.length; ++i) if (out[i] != null) retval += out[i].v;\n    return retval;\n}\n\nSSF._eval = eval_fmt;\nconst cfregex = /\\[[=<>]/;\nconst cfregex2 = /\\[([=<>]*)(-?\\d+\\.?\\d*)\\]/;\n\nfunction chkcond(v, rr) {\n    if (rr == null) return false;\n    const thresh = parseFloat(rr[2]);\n    switch (rr[1]) {\n        case \"=\":\n            if (v === thresh) return true;\n            break;\n        case \">\":\n            if (v > thresh) return true;\n            break;\n        case \"<\":\n            if (v < thresh) return true;\n            break;\n        case \"<>\":\n            if (v !== thresh) return true;\n            break;\n        case \">=\":\n            if (v >= thresh) return true;\n            break;\n        case \"<=\":\n            if (v <= thresh) return true;\n            break;\n    }\n    return false;\n}\n\nfunction choose_fmt(f, v) {\n    let fmt = split_fmt(f);\n    let l = fmt.length, lat = fmt[l - 1].indexOf(\"@\");\n    if (l < 4 && lat > -1) --l;\n    if (fmt.length > 4) throw new Error(\"cannot find right format for |\" + fmt.join(\"|\") + \"|\");\n    if (typeof v !== \"number\") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : \"@\"];\n    switch (fmt.length) {\n        case 1:\n            fmt = lat > -1 ? [\"General\", \"General\", \"General\", fmt[0]] : [fmt[0], fmt[0], fmt[0], \"@\"];\n            break;\n        case 2:\n            fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], \"@\"];\n            break;\n        case 3:\n            fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], \"@\"];\n            break;\n        case 4:\n            break;\n    }\n    const ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];\n    if (fmt[0].indexOf(\"[\") === -1 && fmt[1].indexOf(\"[\") === -1) return [l, ff];\n    if (fmt[0].match(cfregex) != null || fmt[1].match(cfregex) != null) {\n        const m1 = fmt[0].match(cfregex2);\n        const m2 = fmt[1].match(cfregex2);\n        return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];\n    }\n    return [l, ff];\n}\n\nfunction format(fmt, v, o) {\n    if (o == null) o = {};\n    let sfmt = \"\";\n    switch (typeof fmt) {\n        case \"string\":\n            if (fmt === \"m/d/yy\" && o.dateNF) sfmt = o.dateNF;\n            else sfmt = fmt;\n            break;\n        case \"number\":\n            if (fmt === 14 && o.dateNF) sfmt = o.dateNF;\n            else sfmt = (o.table != null ? (o.table) : table_fmt)[fmt];\n            break;\n    }\n    if (isgeneral(sfmt, 0)) return general_fmt(v, o);\n    if (v instanceof Date) v = datenum_local(v, o.date1904);\n    const f = choose_fmt(sfmt, v);\n    if (isgeneral(f[1])) return general_fmt(v, o);\n    if (v === true) v = \"TRUE\"; else if (v === false) v = \"FALSE\";\n    else if (v === \"\" || v == null) return \"\";\n    return eval_fmt(f[1], v, o, f[0]);\n}\n\nfunction load_entry(fmt, idx) {\n    if (typeof idx !== 'number') {\n        idx = +idx || -1;\n        for (let i = 0; i < 0x0188; ++i) {\n            if (table_fmt[i] === undefined) {\n                if (idx < 0) idx = i;\n                continue;\n            }\n            if (table_fmt[i] === fmt) {\n                idx = i;\n                break;\n            }\n        }\n        if (idx < 0) idx = 0x187;\n    }\n    table_fmt[idx] = fmt;\n    return idx;\n}\n\n/**\n * Load format string\n * @param fmt - format\n * @param [idx] - index\n * @returns {number}\n */\nSSF.load = load_entry;\n\n/**\n * The underlying object, mapping numeric keys to format strings.\n * return {{}}\n */\nSSF._table = table_fmt;\n\n/**\n * Gets the internal format table (number to format mapping).\n * @return {{}}\n */\nSSF.get_table = function get_table() {\n    return table_fmt;\n};\nSSF.load_table = function load_table(tbl) {\n    for (let i = 0; i !== 0x0188; ++i)\n        if (tbl[i] !== undefined) load_entry(tbl[i], i);\n};\nSSF.init_table = init_table;\n\n/**\n * Render value using format string or code.\n * If fmt is a string, it will be parsed and evaluated. If fmt is a number, the actual format will be the\n * corresponding entry in the internal format table. For a raw numeric format like 000, the value should be\n * passed as a string.\n *\n * Date arguments are interpreted in the local time of the JS client.\n *\n * @param {string|number} fmt - format\n * @param {any} v - values\n * @param {{date1904: boolean}|undefined} [o] - options\n * @returns {string|*|string|undefined}\n */\nSSF.format = format;\n\nmodule.exports = SSF;\n", "/*\nstep:\n1. validate\n2. sanitize\n3. split\n4. proceed\n5. grammar\n6. combine\n*/\n\nconst defaultResult = '\u0E28\u0E39\u0E19\u0E22\u0E4C\u0E1A\u0E32\u0E17\u0E16\u0E49\u0E27\u0E19'\nconst singleUnitStrs = [\n  '',\n  '\u0E2B\u0E19\u0E36\u0E48\u0E07',\n  '\u0E2A\u0E2D\u0E07',\n  '\u0E2A\u0E32\u0E21',\n  '\u0E2A\u0E35\u0E48',\n  '\u0E2B\u0E49\u0E32',\n  '\u0E2B\u0E01',\n  '\u0E40\u0E08\u0E47\u0E14',\n  '\u0E41\u0E1B\u0E14',\n  '\u0E40\u0E01\u0E49\u0E32'\n]\nconst placeNameStrs = [\n  '',\n  '\u0E2A\u0E34\u0E1A',\n  '\u0E23\u0E49\u0E2D\u0E22',\n  '\u0E1E\u0E31\u0E19',\n  '\u0E2B\u0E21\u0E37\u0E48\u0E19',\n  '\u0E41\u0E2A\u0E19',\n  '\u0E25\u0E49\u0E32\u0E19'\n]\n\n/**\n * @param {number[]} nums\n * @returns {string}\n */\nfunction num2Word (nums) {\n  let result = ''\n  const len = nums.length\n  const maxLen = 7\n\n  if (len > maxLen) {\n    // more than million\n    const overflowIndex = len - maxLen + 1\n    const overflowNums = nums.slice(0, overflowIndex)\n    const remainingNumbs = nums.slice(overflowIndex)\n    return num2Word(overflowNums) + '\u0E25\u0E49\u0E32\u0E19' + num2Word(remainingNumbs)\n  } else {\n    for (let i = 0; i < len; i++) {\n      const digit = nums[i]\n      if (digit > 0) {\n        result += singleUnitStrs[digit] + placeNameStrs[len - i - 1]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction grammarFix (str) {\n  let result = str\n\n  // \"\u0E2A\u0E34\u0E1A\"\n  result = result.replace('\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E2A\u0E34\u0E1A', '\u0E2A\u0E34\u0E1A')\n  // \"\u0E22\u0E35\u0E48\u0E2A\u0E34\u0E1A\"\n  result = result.replace('\u0E2A\u0E2D\u0E07\u0E2A\u0E34\u0E1A', '\u0E22\u0E35\u0E48\u0E2A\u0E34\u0E1A')\n  // \"\u0E40\u0E2D\u0E47\u0E14\"\n  const neungLen = 5\n  if (result.length > neungLen &&\n    result.length - result.lastIndexOf('\u0E2B\u0E19\u0E36\u0E48\u0E07') === neungLen) {\n    result = result.substr(0, result.length - neungLen) + '\u0E40\u0E2D\u0E47\u0E14'\n  }\n\n  return result\n}\n\n/**\n * Combine baht and satang\n * and also adding unit\n *\n * @param {string} baht\n * @param {string} satang\n * @returns {string}\n */\nfunction combine (baht, satang) {\n  let result = ''\n\n  if (baht === '' && satang === '') {\n    result = defaultResult\n  } else if (baht !== '' && satang === '') {\n    result = baht + '\u0E1A\u0E32\u0E17' + '\u0E16\u0E49\u0E27\u0E19'\n  } else if (baht === '' && satang !== '') {\n    result = satang + '\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C'\n  } else {\n    result = baht + '\u0E1A\u0E32\u0E17' + satang + '\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C'\n  }\n\n  return result\n}\n\n/**\n * Change number to Thai pronunciation string\n *\n * @param {number} num\n * @returns {string}\n */\nfunction bahttext (num) {\n  let result = defaultResult\n\n  // 1. validate: invalid number\n  if (isNaN(num)) return result\n  // 1. validate: more than\n  if (num >= Number.MAX_SAFE_INTEGER) return result\n\n  // 2. sanitize: ????\n\n  // 3. split: baht and satang\n  // e.g. 432.21 >> 432, 21\n  // @todo optimize\n  /** @type {string} */\n  const bahtStr = Math.floor(num).toString()\n  /** @type {string} */\n  const satangStr = Math.round(num % 1 * 100).toString()\n\n  // 3. split: convert number array\n  // @todo optimize it\n  /** @type {number[]} */\n  const bahtArr = Array.from(bahtStr).map(Number)\n  /** @type {number[]} */\n  const satangArr = Array.from(satangStr).map(Number)\n\n  // 4. proceed\n  let baht = num2Word(bahtArr)\n  let satang = num2Word(satangArr)\n\n  // 5. grammar\n  baht = grammarFix(baht)\n  satang = grammarFix(satang)\n\n  // 6. combine\n  result = combine(baht, satang)\n\n  return result\n}\n\nif (typeof module !== 'undefined' &&\n  module.exports != null) {\n  module.exports = bahttext\n}\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types, WildCard} = require('../helpers');\r\nconst H = FormulaHelpers;\r\n\r\n// Spreadsheet number format\r\nconst ssf = require('../../ssf/ssf');\r\n\r\n// Change number to Thai pronunciation string\r\nconst bahttext = require('bahttext');\r\n\r\n// full-width and half-width converter\r\nconst charsets = {\r\n    latin: {halfRE: /[!-~]/g, fullRE: /[\uFF01-\uFF5E]/g, delta: 0xFEE0},\r\n    hangul1: {halfRE: /[\uFFA1-\uFFBE]/g, fullRE: /[\u11A8-\u11C2]/g, delta: -0xEDF9},\r\n    hangul2: {halfRE: /[\uFFC2-\uFFDC]/g, fullRE: /[\u1161-\u1175]/g, delta: -0xEE61},\r\n    kana: {\r\n        delta: 0,\r\n        half: \"\uFF61\uFF62\uFF63\uFF64\uFF65\uFF66\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\uFF71\uFF72\uFF73\uFF74\uFF75\uFF76\uFF77\uFF78\uFF79\uFF7A\uFF7B\uFF7C\uFF7D\uFF7E\uFF7F\uFF80\uFF81\uFF82\uFF83\uFF84\uFF85\uFF86\uFF87\uFF88\uFF89\uFF8A\uFF8B\uFF8C\uFF8D\uFF8E\uFF8F\uFF90\uFF91\uFF92\uFF93\uFF94\uFF95\uFF96\uFF97\uFF98\uFF99\uFF9A\uFF9B\uFF9C\uFF9D\uFF9E\uFF9F\",\r\n        full: \"\u3002\u300C\u300D\u3001\u30FB\u30F2\u30A1\u30A3\u30A5\u30A7\u30A9\u30E3\u30E5\u30E7\u30C3\u30FC\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\" +\r\n            \"\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F3\u309B\u309C\"\r\n    },\r\n    extras: {\r\n        delta: 0,\r\n        half: \"\u00A2\u00A3\u00AC\u00AF\u00A6\u00A5\u20A9\\u0020|\u2190\u2191\u2192\u2193\u25A0\u00B0\",\r\n        full: \"\uFFE0\uFFE1\uFFE2\uFFE3\uFFE4\uFFE5\uFFE6\\u3000\uFFE8\uFFE9\uFFEA\uFFEB\uFFEC\uFFED\uFFEE\"\r\n    }\r\n};\r\nconst toFull = set => c => set.delta ?\r\n    String.fromCharCode(c.charCodeAt(0) + set.delta) :\r\n    [...set.full][[...set.half].indexOf(c)];\r\nconst toHalf = set => c => set.delta ?\r\n    String.fromCharCode(c.charCodeAt(0) - set.delta) :\r\n    [...set.half][[...set.full].indexOf(c)];\r\nconst re = (set, way) => set[way + \"RE\"] || new RegExp(\"[\" + set[way] + \"]\", \"g\");\r\nconst sets = Object.keys(charsets).map(i => charsets[i]);\r\nconst toFullWidth = str0 =>\r\n    sets.reduce((str, set) => str.replace(re(set, \"half\"), toFull(set)), str0);\r\nconst toHalfWidth = str0 =>\r\n    sets.reduce((str, set) => str.replace(re(set, \"full\"), toHalf(set)), str0);\r\n\r\nconst TextFunctions = {\r\n    ASC: (text) => {\r\n        text = H.accept(text, Types.STRING);\r\n        return toHalfWidth(text);\r\n    },\r\n\r\n    BAHTTEXT: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        try {\r\n            return bahttext(number);\r\n        } catch (e) {\r\n            throw Error(`Error in https://github.com/jojoee/bahttext \\n${e.toString()}`)\r\n        }\r\n    },\r\n\r\n    CHAR: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number > 255 || number < 1)\r\n            throw FormulaError.VALUE;\r\n        return String.fromCharCode(number);\r\n    },\r\n\r\n    CLEAN: (text) => {\r\n        text = H.accept(text, Types.STRING);\r\n        return text.replace(/[\\x00-\\x1F]/g, '');\r\n    },\r\n\r\n    CODE: (text) => {\r\n        text = H.accept(text, Types.STRING);\r\n        if (text.length === 0)\r\n            throw FormulaError.VALUE;\r\n        return text.charCodeAt(0);\r\n    },\r\n\r\n    CONCAT: (...params) => {\r\n        let text = '';\r\n        // does not allow union\r\n        H.flattenParams(params, Types.STRING, false, item => {\r\n            item = H.accept(item, Types.STRING);\r\n            text += item;\r\n        });\r\n        return text\r\n    },\r\n\r\n    CONCATENATE: (...params) => {\r\n        let text = '';\r\n        if (params.length === 0)\r\n            throw Error('CONCATENATE need at least one argument.');\r\n        params.forEach(param => {\r\n            // does not allow range reference, array, union\r\n            param = H.accept(param, Types.STRING);\r\n            text += param;\r\n        });\r\n\r\n        return text;\r\n    },\r\n\r\n    DBCS: (text) => {\r\n        text = H.accept(text, Types.STRING);\r\n        return toFullWidth(text);\r\n    },\r\n\r\n    DOLLAR: (number, decimals) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        decimals = H.accept(decimals, Types.NUMBER, 2);\r\n        const decimalString = Array(decimals).fill('0').join('');\r\n        // Note: does not support locales\r\n        // TODO: change currency based on user locale or settings from this library\r\n        return ssf.format(`$#,##0.${decimalString}_);($#,##0.${decimalString})`, number).trim();\r\n    },\r\n\r\n    EXACT: (text1, text2) => {\r\n        text1 = H.accept(text1, [Types.STRING]);\r\n        text2 = H.accept(text2, [Types.STRING]);\r\n\r\n        return text1 === text2;\r\n    },\r\n\r\n    FIND: (findText, withinText, startNum) => {\r\n        findText = H.accept(findText, Types.STRING);\r\n        withinText = H.accept(withinText, Types.STRING);\r\n        startNum = H.accept(startNum, Types.NUMBER, 1);\r\n        if (startNum < 1 || startNum > withinText.length)\r\n            throw FormulaError.VALUE;\r\n        const res = withinText.indexOf(findText, startNum - 1);\r\n        if (res === -1)\r\n            throw FormulaError.VALUE;\r\n        return res + 1;\r\n    },\r\n\r\n    FINDB: (...params) => {\r\n        return TextFunctions.FIND(...params);\r\n    },\r\n\r\n    FIXED: (number, decimals, noCommas) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        decimals = H.accept(decimals, Types.NUMBER, 2);\r\n        noCommas = H.accept(noCommas, Types.BOOLEAN, false);\r\n\r\n        const decimalString = Array(decimals).fill('0').join('');\r\n        const comma = noCommas ? '' : '#,';\r\n        return ssf.format(`${comma}##0.${decimalString}_);(${comma}##0.${decimalString})`, number).trim();\r\n    },\r\n\r\n    LEFT: (text, numChars) => {\r\n        text = H.accept(text, Types.STRING);\r\n        numChars = H.accept(numChars, Types.NUMBER, 1);\r\n\r\n        if (numChars < 0)\r\n            throw FormulaError.VALUE;\r\n        if (numChars > text.length)\r\n            return text;\r\n        return text.slice(0, numChars);\r\n    },\r\n\r\n    LEFTB: (...params) => {\r\n        return TextFunctions.LEFT(...params);\r\n    },\r\n\r\n    LEN: (text) => {\r\n        text = H.accept(text, Types.STRING);\r\n        return text.length;\r\n    },\r\n\r\n    LENB: (...params) => {\r\n        return TextFunctions.LEN(...params);\r\n    },\r\n\r\n    LOWER: (text) => {\r\n        text = H.accept(text, Types.STRING);\r\n        return text.toLowerCase();\r\n    },\r\n\r\n    MID: (text, startNum, numChars) => {\r\n        text = H.accept(text, Types.STRING);\r\n        startNum = H.accept(startNum, Types.NUMBER);\r\n        numChars = H.accept(numChars, Types.NUMBER);\r\n        if (startNum > text.length)\r\n            return '';\r\n        if (startNum < 1 || numChars < 1)\r\n            throw FormulaError.VALUE;\r\n        return text.slice(startNum - 1, startNum + numChars - 1);\r\n    },\r\n\r\n    MIDB: (...params) => {\r\n        return TextFunctions.MID(...params);\r\n    },\r\n\r\n    NUMBERVALUE: (text, decimalSeparator, groupSeparator) => {\r\n        text = H.accept(text, Types.STRING);\r\n        // TODO: support reading system locale and set separators\r\n        decimalSeparator = H.accept(decimalSeparator, Types.STRING, '.');\r\n        groupSeparator = H.accept(groupSeparator, Types.STRING, ',');\r\n\r\n        if (text.length === 0)\r\n            return 0;\r\n        if (decimalSeparator.length === 0 || groupSeparator.length === 0)\r\n            throw FormulaError.VALUE;\r\n        decimalSeparator = decimalSeparator[0];\r\n        groupSeparator = groupSeparator[0];\r\n        if (decimalSeparator === groupSeparator\r\n            || text.indexOf(decimalSeparator) < text.lastIndexOf(groupSeparator))\r\n            throw FormulaError.VALUE;\r\n\r\n        const res = text.replace(groupSeparator, '')\r\n            .replace(decimalSeparator, '.')\r\n            // remove chars that not related to number\r\n            .replace(/[^\\-0-9.%()]/g, '')\r\n            .match(/([(-]*)([0-9]*[.]*[0-9]+)([)]?)([%]*)/);\r\n        if (!res)\r\n            throw FormulaError.VALUE;\r\n        // [\"-123456.78%%\", \"(-\", \"123456.78\", \")\", \"%%\"]\r\n        const leftParenOrMinus = res[1].length, rightParen = res[3].length, percent = res[4].length;\r\n        let number = Number(res[2]);\r\n        if (leftParenOrMinus > 1 || leftParenOrMinus && !rightParen\r\n            || !leftParenOrMinus && rightParen || isNaN(number))\r\n            throw FormulaError.VALUE;\r\n        number = number / 100 ** percent;\r\n        return leftParenOrMinus ? -number : number;\r\n    },\r\n\r\n    PHONETIC: () => {\r\n    },\r\n\r\n    PROPER: (text) => {\r\n        text = H.accept(text, [Types.STRING]);\r\n        text = text.toLowerCase();\r\n        text = text.charAt(0).toUpperCase() + text.slice(1);\r\n        return text.replace(/(?:[^a-zA-Z])([a-zA-Z])/g,\r\n            letter => letter.toUpperCase());\r\n    },\r\n\r\n    REPLACE: (old_text, start_num, num_chars, new_text) => {\r\n        old_text = H.accept(old_text, [Types.STRING]);\r\n        start_num = H.accept(start_num, [Types.NUMBER]);\r\n        num_chars = H.accept(num_chars, [Types.NUMBER]);\r\n        new_text = H.accept(new_text, [Types.STRING]);\r\n\r\n        let arr = old_text.split(\"\");\r\n        arr.splice(start_num - 1, num_chars, new_text);\r\n\r\n        return arr.join(\"\");\r\n    },\r\n\r\n    REPLACEB: (...params) => {\r\n        return TextFunctions.REPLACE(...params)\r\n    },\r\n\r\n    REPT: (text, number_times) => {\r\n        text = H.accept(text, Types.STRING);\r\n        number_times = H.accept(number_times, Types.NUMBER);\r\n        let str = \"\";\r\n\r\n        for (let i = 0; i < number_times; i++) {\r\n            str += text;\r\n        }\r\n        return str;\r\n    },\r\n\r\n    RIGHT: (text, numChars) => {\r\n        text = H.accept(text, Types.STRING);\r\n        numChars = H.accept(numChars, Types.NUMBER, 1);\r\n\r\n        if (numChars < 0)\r\n            throw FormulaError.VALUE;\r\n        const len = text.length;\r\n        if (numChars > len)\r\n            return text;\r\n        return text.slice(len - numChars);\r\n    },\r\n\r\n    RIGHTB: (...params) => {\r\n        return TextFunctions.RIGHT(...params);\r\n    },\r\n\r\n    SEARCH: (findText, withinText, startNum) => {\r\n        findText = H.accept(findText, Types.STRING);\r\n        withinText = H.accept(withinText, Types.STRING);\r\n        startNum = H.accept(startNum, Types.NUMBER, 1);\r\n        if (startNum < 1 || startNum > withinText.length)\r\n            throw FormulaError.VALUE;\r\n\r\n        // transform to js regex expression\r\n        let findTextRegex = WildCard.isWildCard(findText) ? WildCard.toRegex(findText, 'i') : findText;\r\n        const res = withinText.slice(startNum - 1).search(findTextRegex);\r\n        if (res === -1)\r\n            throw FormulaError.VALUE;\r\n        return res + startNum;\r\n    },\r\n\r\n    SEARCHB: (...params) => {\r\n        return TextFunctions.SEARCH(...params)\r\n    },\r\n\r\n    SUBSTITUTE: (...params) => {\r\n\r\n    },\r\n\r\n    T: (value) => {\r\n        // extract the real parameter\r\n        value = H.accept(value);\r\n        if (typeof value === \"string\")\r\n            return value;\r\n        return '';\r\n    },\r\n\r\n    TEXT: (value, formatText) => {\r\n        value = H.accept(value, Types.NUMBER);\r\n        formatText = H.accept(formatText, Types.STRING);\r\n        // I know ssf contains bugs...\r\n        try {\r\n            return ssf.format(formatText, value);\r\n        } catch (e) {\r\n            console.error(e)\r\n            throw FormulaError.VALUE;\r\n        }\r\n    },\r\n\r\n    TEXTJOIN: (...params) => {\r\n\r\n    },\r\n\r\n    TRIM: (text) => {\r\n        text = H.accept(text, [Types.STRING]);\r\n        return text.replace(/^\\s+|\\s+$/g, '')\r\n    },\r\n\r\n    UNICHAR: (number) => {\r\n        number = H.accept(number, [Types.NUMBER]);\r\n        if (number <= 0)\r\n            throw FormulaError.VALUE;\r\n        return String.fromCharCode(number);\r\n    },\r\n\r\n    UNICODE: (text) => {\r\n        return TextFunctions.CODE(text);\r\n    },\r\n};\r\n\r\nmodule.exports = TextFunctions;\r\n", "const FormulaError = require('../formulas/error');\r\nconst {FormulaHelpers} = require('../formulas/helpers');\r\n\r\nconst Prefix = {\r\n    unaryOp: (prefixes, value, isArray) => {\r\n        let sign = 1;\r\n        prefixes.forEach(prefix => {\r\n            if (prefix === '+') {\r\n            } else if (prefix === '-') {\r\n                sign = -sign;\r\n            } else {\r\n                throw new Error(`Unrecognized prefix: ${prefix}`);\r\n            }\r\n        });\r\n\r\n        if (value == null) {\r\n            value = 0;\r\n        }\r\n        // positive means no changes\r\n        if (sign === 1) {\r\n            return value;\r\n        }\r\n        // negative\r\n        try {\r\n            value = FormulaHelpers.acceptNumber(value, isArray);\r\n        } catch (e) {\r\n            if (e instanceof FormulaError) {\r\n                // parse number fails\r\n                if (Array.isArray(value))\r\n                    value = value[0][0]\r\n            } else\r\n                throw e;\r\n        }\r\n\r\n        if (typeof value === \"number\" && isNaN(value)) return FormulaError.VALUE;\r\n        return -value;\r\n    }\r\n};\r\n\r\nconst Postfix = {\r\n    percentOp: (value, postfix, isArray) => {\r\n        try {\r\n            value = FormulaHelpers.acceptNumber(value, isArray);\r\n        } catch (e) {\r\n            if (e instanceof FormulaError)\r\n                return e;\r\n            throw e;\r\n        }\r\n        if (postfix === '%') {\r\n            return value / 100;\r\n        }\r\n        throw new Error(`Unrecognized postfix: ${postfix}`);\r\n    }\r\n};\r\n\r\nconst type2Number = {'boolean': 3, 'string': 2, 'number': 1};\r\n\r\nconst Infix = {\r\n    compareOp: (value1, infix, value2, isArray1, isArray2) => {\r\n        if (value1 == null) value1 = 0;\r\n        if (value2 == null) value2 = 0;\r\n        // for array: {1,2,3}, get the first element to compare\r\n        if (isArray1) {\r\n            value1 = value1[0][0];\r\n        }\r\n        if (isArray2) {\r\n            value2 = value2[0][0];\r\n        }\r\n\r\n        const type1 = typeof value1, type2 = typeof value2;\r\n\r\n        if (type1 === type2) {\r\n            // same type comparison\r\n            switch (infix) {\r\n                case '=':\r\n                    return value1 === value2;\r\n                case '>':\r\n                    return value1 > value2;\r\n                case '<':\r\n                    return value1 < value2;\r\n                case '<>':\r\n                    return value1 !== value2;\r\n                case '<=':\r\n                    return value1 <= value2;\r\n                case '>=':\r\n                    return value1 >= value2;\r\n            }\r\n        } else {\r\n            switch (infix) {\r\n                case '=':\r\n                    return false;\r\n                case '>':\r\n                    return type2Number[type1] > type2Number[type2];\r\n                case '<':\r\n                    return type2Number[type1] < type2Number[type2];\r\n                case '<>':\r\n                    return true;\r\n                case '<=':\r\n                    return type2Number[type1] <= type2Number[type2];\r\n                case '>=':\r\n                    return type2Number[type1] >= type2Number[type2];\r\n            }\r\n\r\n        }\r\n        throw Error('Infix.compareOp: Should not reach here.');\r\n    },\r\n\r\n    concatOp: (value1, infix, value2, isArray1, isArray2) => {\r\n        if (value1 == null) value1 = '';\r\n        if (value2 == null) value2 = '';\r\n        // for array: {1,2,3}, get the first element to concat\r\n        if (isArray1) {\r\n            value1 = value1[0][0];\r\n        }\r\n        if (isArray2) {\r\n            value2 = value2[0][0];\r\n        }\r\n\r\n        const type1 = typeof value1, type2 = typeof value2;\r\n        // convert boolean to string\r\n        if (type1 === 'boolean')\r\n            value1 = value1 ? 'TRUE' : 'FALSE';\r\n        if (type2 === 'boolean')\r\n            value2 = value2 ? 'TRUE' : 'FALSE';\r\n        return '' + value1 + value2;\r\n    },\r\n\r\n    mathOp: (value1, infix, value2, isArray1, isArray2) => {\r\n        if (value1 == null) value1 = 0;\r\n        if (value2 == null) value2 = 0;\r\n\r\n        try {\r\n            value1 = FormulaHelpers.acceptNumber(value1, isArray1);\r\n            value2 = FormulaHelpers.acceptNumber(value2, isArray2);\r\n        } catch (e) {\r\n            if (e instanceof FormulaError)\r\n                return e;\r\n            throw e;\r\n        }\r\n\r\n        switch (infix) {\r\n            case '+':\r\n                return value1 + value2;\r\n            case '-':\r\n                return value1 - value2;\r\n            case '*':\r\n                return value1 * value2;\r\n            case '/':\r\n                if (value2 === 0)\r\n                    return FormulaError.DIV0;\r\n                return value1 / value2;\r\n            case '^':\r\n                return value1 ** value2;\r\n        }\r\n\r\n        throw Error('Infix.mathOp: Should not reach here.');\r\n    },\r\n\r\n};\r\n\r\nmodule.exports = {\r\n    Prefix,\r\n    Postfix,\r\n    Infix,\r\n    Operators: {\r\n        compareOp: ['<', '>', '=', '<>', '<=', '>='],\r\n        concatOp: ['&'],\r\n        mathOp: ['+', '-', '*', '/', '^'],\r\n    }\r\n};\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types, Factorials, Criteria} = require('../helpers');\r\nconst {Infix} = require('../operators');\r\nconst H = FormulaHelpers;\r\n\r\n// Max number in excel is 2^1024-1, same as javascript, thus I will not check if number is valid in some functions.\r\n\r\n// factorials\r\nconst f = [], fd = [];\r\n\r\nfunction factorial(n) {\r\n    if (n <= 100)\r\n        return Factorials[n];\r\n    if (f[n] > 0)\r\n        return f[n];\r\n    return f[n] = factorial(n - 1) * n;\r\n}\r\n\r\nfunction factorialDouble(n) {\r\n    if (n === 1 || n === 0)\r\n        return 1;\r\n    if (n === 2)\r\n        return 2;\r\n    if (fd[n] > 0)\r\n        return fd[n];\r\n    return fd[n] = factorialDouble(n - 2) * n;\r\n}\r\n\r\n// https://support.office.com/en-us/article/excel-functions-by-category-5f91f4e9-7b42-46d2-9bd1-63f26a86c0eb\r\nconst MathFunctions = {\r\n    ABS: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.abs(number);\r\n    },\r\n\r\n    AGGREGATE: (functionNum, options, ref1, ...refs) => {\r\n        // functionNum = H.accept(functionNum, Types.NUMBER);\r\n        // throw FormulaError.NOT_IMPLEMENTED('AGGREGATE');\r\n    },\r\n\r\n    ARABIC: text => {\r\n        text = H.accept(text, Types.STRING).toUpperCase();\r\n        // Credits: Rafa? Kukawski\r\n        if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {\r\n            throw new FormulaError('#VALUE!', 'Invalid roman numeral in ARABIC evaluation.');\r\n        }\r\n        let r = 0;\r\n        text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function (i) {\r\n            r += {\r\n                M: 1000,\r\n                CM: 900,\r\n                D: 500,\r\n                CD: 400,\r\n                C: 100,\r\n                XC: 90,\r\n                L: 50,\r\n                XL: 40,\r\n                X: 10,\r\n                IX: 9,\r\n                V: 5,\r\n                IV: 4,\r\n                I: 1\r\n            }[i];\r\n        });\r\n        return r;\r\n    },\r\n\r\n    BASE: (number, radix, minLength) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number < 0 || number >= 2 ** 53)\r\n            throw FormulaError.NUM;\r\n        radix = H.accept(radix, Types.NUMBER);\r\n        if (radix < 2 || radix > 36)\r\n            throw FormulaError.NUM;\r\n        minLength = H.accept(minLength, Types.NUMBER, 0);\r\n        if (minLength < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        const result = number.toString(radix).toUpperCase();\r\n        return new Array(Math.max(minLength + 1 - result.length, 0)).join('0') + result;\r\n    },\r\n\r\n    CEILING: (number, significance) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        significance = H.accept(significance, Types.NUMBER);\r\n        if (significance === 0)\r\n            return 0;\r\n        if (number / significance % 1 === 0)\r\n            return number;\r\n        const absSignificance = Math.abs(significance);\r\n        const times = Math.floor(Math.abs(number) / absSignificance);\r\n        if (number < 0) {\r\n            // round down, away from zero\r\n            const roundDown = significance < 0;\r\n            return roundDown ? -absSignificance * (times + 1) : -absSignificance * (times);\r\n        } else {\r\n            return (times + 1) * absSignificance;\r\n        }\r\n    },\r\n\r\n    'CEILING.MATH': (number, significance, mode) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        significance = H.accept(significance, Types.NUMBER, number > 0 ? 1 : -1);\r\n        // mode can be any number\r\n        mode = H.accept(mode, Types.NUMBER, 0);\r\n        // The Mode argument does not affect positive numbers.\r\n        if (number >= 0) {\r\n            return MathFunctions.CEILING(number, significance);\r\n        }\r\n        // if round down, away from zero, then significance\r\n        const offset = mode ? significance : 0;\r\n        return MathFunctions.CEILING(number, significance) - offset;\r\n    },\r\n\r\n    'CEILING.PRECISE': (number, significance) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        significance = H.accept(significance, Types.NUMBER, 1);\r\n        // always round up\r\n        return MathFunctions.CEILING(number, Math.abs(significance));\r\n    },\r\n\r\n    COMBIN: (number, numberChosen) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        numberChosen = H.accept(numberChosen, Types.NUMBER);\r\n        if (number < 0 || numberChosen < 0 || number < numberChosen)\r\n            throw FormulaError.NUM;\r\n        const nFactorial = MathFunctions.FACT(number), kFactorial = MathFunctions.FACT(numberChosen);\r\n        return nFactorial / kFactorial / MathFunctions.FACT(number - numberChosen);\r\n    },\r\n\r\n    COMBINA: (number, numberChosen) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        numberChosen = H.accept(numberChosen, Types.NUMBER);\r\n        // special case\r\n        if ((number === 0 || number === 1) && numberChosen === 0)\r\n            return 1;\r\n        if (number < 0 || numberChosen < 0)\r\n            throw FormulaError.NUM;\r\n        return MathFunctions.COMBIN(number + numberChosen - 1, number - 1);\r\n    },\r\n\r\n    DECIMAL: (text, radix) => {\r\n        text = H.accept(text, Types.STRING);\r\n        radix = H.accept(radix, Types.NUMBER);\r\n        radix = Math.trunc(radix);\r\n        if (radix < 2 || radix > 36)\r\n            throw FormulaError.NUM;\r\n        const res = parseInt(text, radix);\r\n        if (isNaN(res))\r\n            throw FormulaError.NUM;\r\n        return res;\r\n    },\r\n\r\n    DEGREES: (radians) => {\r\n        radians = H.accept(radians, Types.NUMBER);\r\n        return radians * (180 / Math.PI);\r\n    },\r\n\r\n    EVEN: (number) => {\r\n        return MathFunctions.CEILING(number, -2);\r\n    },\r\n\r\n    EXP: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.exp(number)\r\n    },\r\n\r\n    FACT: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        number = Math.trunc(number);\r\n        // max number = 170\r\n        if (number > 170 || number < 0)\r\n            throw FormulaError.NUM;\r\n        if (number <= 100)\r\n            return Factorials[number];\r\n        return factorial(number);\r\n    },\r\n\r\n    FACTDOUBLE: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        number = Math.trunc(number);\r\n        // max number = 170\r\n        if (number < -1)\r\n            throw FormulaError.NUM;\r\n        if (number === -1)\r\n            return 1;\r\n        return factorialDouble(number);\r\n    },\r\n\r\n    FLOOR: (number, significance) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        significance = H.accept(significance, Types.NUMBER);\r\n        if (significance === 0)\r\n            return 0;\r\n        if (number > 0 && significance < 0)\r\n            throw FormulaError.NUM;\r\n        if (number / significance % 1 === 0)\r\n            return number;\r\n        const absSignificance = Math.abs(significance);\r\n        const times = Math.floor(Math.abs(number) / absSignificance);\r\n        if (number < 0) {\r\n            // round down, away from zero\r\n            const roundDown = significance < 0;\r\n            return roundDown ? -absSignificance * times : -absSignificance * (times + 1);\r\n        } else {\r\n            // toward zero\r\n            return times * absSignificance;\r\n        }\r\n    },\r\n\r\n    'FLOOR.MATH': (number, significance, mode) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        significance = H.accept(significance, Types.NUMBER, number > 0 ? 1 : -1);\r\n\r\n        // mode can be 0 or any other number, 0 means away from zero\r\n        // the official documentation seems wrong\r\n        mode = H.accept(mode, Types.NUMBER, 0);\r\n        // The Mode argument does not affect positive numbers.\r\n        if (mode === 0 || number >= 0) {\r\n            // away from zero\r\n            return MathFunctions.FLOOR(number, Math.abs(significance));\r\n        }\r\n        // towards zero, add a significance\r\n        return MathFunctions.FLOOR(number, significance) + significance;\r\n    },\r\n\r\n    'FLOOR.PRECISE': (number, significance) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        significance = H.accept(significance, Types.NUMBER, 1);\r\n        // always round up\r\n        return MathFunctions.FLOOR(number, Math.abs(significance));\r\n    },\r\n\r\n    GCD: (...params) => {\r\n        const arr = [];\r\n        H.flattenParams(params, null, false,\r\n            (param) => {\r\n                // allow array, range ref\r\n                param = typeof param === 'boolean' ? NaN : Number(param);\r\n                if (!isNaN(param)) {\r\n                    if (param < 0 || param > 9007199254740990) // 2^53\r\n                        throw FormulaError.NUM;\r\n                    arr.push(Math.trunc(param))\r\n                } else\r\n                    throw FormulaError.VALUE;\r\n            }, 0);\r\n        // http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript\r\n        let i, y,\r\n            n = params.length,\r\n            x = Math.abs(arr[0]);\r\n\r\n        for (i = 1; i < n; i++) {\r\n            y = Math.abs(arr[i]);\r\n\r\n            while (x && y) {\r\n                (x > y) ? x %= y : y %= x;\r\n            }\r\n            x += y;\r\n        }\r\n        return x;\r\n    },\r\n\r\n    INT: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.floor(number);\r\n    },\r\n\r\n    'ISO.CEILING': (...params) => {\r\n        return MathFunctions['CEILING.PRECISE'](...params);\r\n    },\r\n\r\n    LCM: (...params) => {\r\n        const arr = [];\r\n        // always parse string to number if possible\r\n        H.flattenParams(params, null, false,\r\n            param => {\r\n                param = typeof param === 'boolean' ? NaN : Number(param);\r\n                if (!isNaN(param)) {\r\n                    if (param < 0 || param > 9007199254740990) // 2^53\r\n                        throw FormulaError.NUM;\r\n                    arr.push(Math.trunc(param))\r\n                }\r\n                // throw value error if can't parse to string\r\n                else\r\n                    throw FormulaError.VALUE;\r\n            }, 1);\r\n        // http://rosettacode.org/wiki/Least_common_multiple#JavaScript\r\n        let n = arr.length, a = Math.abs(arr[0]);\r\n        for (let i = 1; i < n; i++) {\r\n            let b = Math.abs(arr[i]), c = a;\r\n            while (a && b) {\r\n                a > b ? a %= b : b %= a;\r\n            }\r\n            a = Math.abs(c * arr[i]) / (a + b);\r\n        }\r\n        return a;\r\n    },\r\n\r\n    LN: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.log(number);\r\n    },\r\n\r\n    LOG: (number, base) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        base = H.accept(base, Types.NUMBER, 10);\r\n\r\n        return Math.log(number) / Math.log(base);\r\n    },\r\n\r\n    LOG10: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.log10(number);\r\n    },\r\n\r\n    MDETERM: (array) => {\r\n        array = H.accept(array, Types.ARRAY, undefined, false, true);\r\n        if (array[0].length !== array.length)\r\n            throw FormulaError.VALUE;\r\n        // adopted from https://github.com/numbers/numbers.js/blob/master/lib/numbers/matrix.js#L261\r\n        const numRow = array.length, numCol = array[0].length;\r\n        let det = 0, diagLeft, diagRight;\r\n\r\n        if (numRow === 1) {\r\n            return array[0][0];\r\n        } else if (numRow === 2) {\r\n            return array[0][0] * array[1][1] - array[0][1] * array[1][0];\r\n        }\r\n\r\n        for (let col = 0; col < numCol; col++) {\r\n            diagLeft = array[0][col];\r\n            diagRight = array[0][col];\r\n\r\n            for (let row = 1; row < numRow; row++) {\r\n                diagRight *= array[row][(((col + row) % numCol) + numCol) % numCol];\r\n                diagLeft *= array[row][(((col - row) % numCol) + numCol) % numCol];\r\n            }\r\n\r\n            det += diagRight - diagLeft;\r\n        }\r\n\r\n        return det;\r\n    },\r\n\r\n    MINVERSE: (array) => {\r\n        // TODO\r\n        // array = H.accept(array, Types.ARRAY, null, false);\r\n        // if (array[0].length !== array.length)\r\n        //     throw FormulaError.VALUE;\r\n        // throw FormulaError.NOT_IMPLEMENTED('MINVERSE');\r\n    },\r\n\r\n    MMULT: (array1, array2) => {\r\n        array1 = H.accept(array1, Types.ARRAY, undefined, false, true);\r\n        array2 = H.accept(array2, Types.ARRAY, undefined, false, true);\r\n\r\n        const aNumRows = array1.length, aNumCols = array1[0].length,\r\n            bNumRows = array2.length, bNumCols = array2[0].length,\r\n            m = new Array(aNumRows);  // initialize array of rows\r\n\r\n        if (aNumCols !== bNumRows)\r\n            throw FormulaError.VALUE;\r\n\r\n        for (let r = 0; r < aNumRows; r++) {\r\n            m[r] = new Array(bNumCols); // initialize the current row\r\n            for (let c = 0; c < bNumCols; c++) {\r\n                m[r][c] = 0;             // initialize the current cell\r\n                for (let i = 0; i < aNumCols; i++) {\r\n                    const v1 = array1[r][i], v2 = array2[i][c];\r\n                    if (typeof v1 !== \"number\" || typeof v2 !== \"number\") throw FormulaError.VALUE;\r\n                    m[r][c] += array1[r][i] * array2[i][c];\r\n                }\r\n            }\r\n        }\r\n        return m;\r\n    },\r\n\r\n    MOD: (number, divisor) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        divisor = H.accept(divisor, Types.NUMBER);\r\n        if (divisor === 0)\r\n            throw FormulaError.DIV0;\r\n        return number - divisor * MathFunctions.INT(number / divisor);\r\n\r\n    },\r\n\r\n    MROUND: (number, multiple) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        multiple = H.accept(multiple, Types.NUMBER);\r\n        if (multiple === 0)\r\n            return 0;\r\n        if (number > 0 && multiple < 0 || number < 0 && multiple > 0)\r\n            throw FormulaError.NUM;\r\n        if (number / multiple % 1 === 0)\r\n            return number;\r\n        return Math.round(number / multiple) * multiple;\r\n    },\r\n\r\n    MULTINOMIAL: (...numbers) => {\r\n        let numerator = 0, denominator = 1;\r\n        H.flattenParams(numbers, Types.NUMBER, false, number => {\r\n            if (number < 0)\r\n                throw FormulaError.NUM;\r\n            numerator += number;\r\n            denominator *= factorial(number);\r\n        });\r\n        return factorial(numerator) / denominator;\r\n    },\r\n\r\n    MUNIT: (dimension) => {\r\n        dimension = H.accept(dimension, Types.NUMBER);\r\n        const matrix = [];\r\n        for (let row = 0; row < dimension; row++) {\r\n            const rowArr = [];\r\n            for (let col = 0; col < dimension; col++) {\r\n                if (row === col)\r\n                    rowArr.push(1);\r\n                else\r\n                    rowArr.push(0);\r\n            }\r\n            matrix.push(rowArr);\r\n        }\r\n        return matrix;\r\n    },\r\n\r\n    ODD: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number === 0)\r\n            return 1;\r\n        let temp = Math.ceil(Math.abs(number));\r\n        temp = (temp & 1) ? temp : temp + 1;\r\n        return (number > 0) ? temp : -temp;\r\n    },\r\n\r\n    PI: () => {\r\n        return Math.PI;\r\n    },\r\n\r\n    POWER: (number, power) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        power = H.accept(power, Types.NUMBER);\r\n        return number ** power;\r\n    },\r\n\r\n    PRODUCT: (...numbers) => {\r\n        let product = 1;\r\n        H.flattenParams(numbers, null, true, (number, info) => {\r\n            const parsedNumber = Number(number);\r\n            if (info.isLiteral && !isNaN(parsedNumber)) {\r\n                product *= parsedNumber;\r\n            } else {\r\n                if (typeof number === \"number\")\r\n                    product *= number;\r\n            }\r\n        }, 1);\r\n        return product;\r\n    },\r\n\r\n    QUOTIENT: (numerator, denominator) => {\r\n        numerator = H.accept(numerator, Types.NUMBER);\r\n        denominator = H.accept(denominator, Types.NUMBER);\r\n        return Math.trunc(numerator / denominator);\r\n    },\r\n\r\n    RADIANS: (degrees) => {\r\n        degrees = H.accept(degrees, Types.NUMBER);\r\n        return degrees / 180 * Math.PI;\r\n    },\r\n\r\n    RAND: () => {\r\n        return Math.random();\r\n    },\r\n\r\n    RANDBETWEEN: (bottom, top) => {\r\n        bottom = H.accept(bottom, Types.NUMBER);\r\n        top = H.accept(top, Types.NUMBER);\r\n        return Math.floor(Math.random() * (top - bottom + 1) + bottom);\r\n    },\r\n\r\n    ROMAN: (number, form) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        form = H.accept(form, Types.NUMBER, 0);\r\n        if (form !== 0)\r\n            throw Error('ROMAN: only allows form=0 (classic form).');\r\n        // The MIT License\r\n        // Copyright (c) 2008 Steven Levithan\r\n        const digits = String(number).split('');\r\n        const key = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];\r\n        let roman = '', i = 3;\r\n        while (i--) {\r\n            roman = (key[+digits.pop() + (i * 10)] || '') + roman;\r\n        }\r\n        return new Array(+digits.join('') + 1).join('M') + roman;\r\n    },\r\n\r\n    ROUND: (number, digits) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        digits = H.accept(digits, Types.NUMBER);\r\n\r\n        const multiplier = Math.pow(10, Math.abs(digits));\r\n        const sign = number > 0 ? 1 : -1;\r\n        if (digits > 0) {\r\n            return sign * Math.round(Math.abs(number) * multiplier) / multiplier;\r\n        } else if (digits === 0) {\r\n            return sign * Math.round(Math.abs(number));\r\n        } else {\r\n            return sign * Math.round(Math.abs(number) / multiplier) * multiplier;\r\n        }\r\n    },\r\n\r\n    ROUNDDOWN: (number, digits) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        digits = H.accept(digits, Types.NUMBER);\r\n\r\n        const multiplier = Math.pow(10, Math.abs(digits));\r\n        const sign = number > 0 ? 1 : -1;\r\n        if (digits > 0) {\r\n            const offset = 1 / multiplier * 0.5;\r\n            return sign * Math.round((Math.abs(number) - offset) * multiplier) / multiplier;\r\n        } else if (digits === 0) {\r\n            const offset = 0.5;\r\n            return sign * Math.round((Math.abs(number) - offset));\r\n        } else {\r\n            const offset = multiplier * 0.5;\r\n            return sign * Math.round((Math.abs(number) - offset) / multiplier) * multiplier;\r\n        }\r\n    },\r\n\r\n    ROUNDUP: (number, digits) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        digits = H.accept(digits, Types.NUMBER);\r\n\r\n        const multiplier = Math.pow(10, Math.abs(digits));\r\n        const sign = number > 0 ? 1 : -1;\r\n        if (digits > 0) {\r\n            const offset = 1 / multiplier * 0.5;\r\n            return sign * Math.round((Math.abs(number) + offset) * multiplier) / multiplier;\r\n        } else if (digits === 0) {\r\n            const offset = 0.5;\r\n            return sign * Math.round((Math.abs(number) + offset));\r\n        } else {\r\n            const offset = multiplier * 0.5;\r\n            return sign * Math.round((Math.abs(number) + offset) / multiplier) * multiplier;\r\n        }\r\n    },\r\n\r\n    SERIESSUM: (x, n, m, coefficients) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        n = H.accept(n, Types.NUMBER);\r\n        m = H.accept(m, Types.NUMBER);\r\n        let i = 0, result;\r\n        H.flattenParams([coefficients], Types.NUMBER, false, (coefficient) => {\r\n            if (typeof coefficient !== \"number\") {\r\n                throw FormulaError.VALUE;\r\n            }\r\n            if (i === 0) {\r\n                result = coefficient * Math.pow(x, n);\r\n            } else {\r\n                result += coefficient * Math.pow(x, n + i * m);\r\n            }\r\n            i++;\r\n        });\r\n        return result;\r\n    },\r\n\r\n    SIGN: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return number > 0 ? 1 : number === 0 ? 0 : -1;\r\n    },\r\n\r\n    SQRT: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number < 0)\r\n            throw FormulaError.NUM;\r\n        return Math.sqrt(number);\r\n    },\r\n\r\n    SQRTPI: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number < 0)\r\n            throw FormulaError.NUM;\r\n        return Math.sqrt(number * Math.PI);\r\n    },\r\n\r\n    SUBTOTAL: () => {\r\n        // TODO: Finish this after statistical functions are implemented.\r\n    },\r\n\r\n    SUM: (...params) => {\r\n        // parse string to number only when it is a literal. (not a reference)\r\n        let result = 0;\r\n        H.flattenParams(params, Types.NUMBER, true,\r\n            (item, info) => {\r\n                // literal will be parsed to given type (Type.NUMBER)\r\n                if (info.isLiteral) {\r\n                    result += item;\r\n                } else {\r\n                    if (typeof item === \"number\")\r\n                        result += item;\r\n                }\r\n            });\r\n        return result\r\n    },\r\n\r\n    /**\r\n     * This functions requires instance of {@link FormulaParser}.\r\n     */\r\n    SUMIF: (context, range, criteria, sumRange) => {\r\n        const ranges = H.retrieveRanges(context, range, sumRange);\r\n        range = ranges[0];\r\n        sumRange = ranges[1];\r\n\r\n        criteria = H.retrieveArg(context, criteria);\r\n        const isCriteriaArray = criteria.isArray;\r\n        // parse criteria\r\n        criteria = Criteria.parse(H.accept(criteria));\r\n        let sum = 0;\r\n\r\n        range.forEach((row, rowNum) => {\r\n            row.forEach((value, colNum) => {\r\n                const valueToAdd = sumRange[rowNum][colNum];\r\n                if (typeof valueToAdd !== \"number\")\r\n                    return;\r\n                // wildcard\r\n                if (criteria.op === 'wc') {\r\n                    if (criteria.match === criteria.value.test(value)) {\r\n                        sum += valueToAdd;\r\n                    }\r\n\r\n                } else if (Infix.compareOp(value, criteria.op, criteria.value, Array.isArray(value), isCriteriaArray)) {\r\n                    sum += valueToAdd;\r\n                }\r\n            })\r\n        });\r\n        return sum;\r\n    },\r\n\r\n    SUMIFS: () => {\r\n\r\n    },\r\n\r\n    SUMPRODUCT: (array1, ...arrays) => {\r\n        array1 = H.accept(array1, Types.ARRAY, undefined, false, true);\r\n        arrays.forEach(array => {\r\n            array = H.accept(array, Types.ARRAY, undefined, false, true);\r\n            if (array1[0].length !== array[0].length || array1.length !== array.length)\r\n                throw FormulaError.VALUE;\r\n            for (let i = 0; i < array1.length; i++) {\r\n                for (let j = 0; j < array1[0].length; j++) {\r\n                    if (typeof array1[i][j] !== \"number\")\r\n                        array1[i][j] = 0;\r\n                    if (typeof array[i][j] !== \"number\")\r\n                        array[i][j] = 0;\r\n                    array1[i][j] *= array[i][j];\r\n                }\r\n            }\r\n        });\r\n        let result = 0;\r\n\r\n        array1.forEach(row => {\r\n            row.forEach(value => {\r\n                result += value;\r\n            })\r\n        });\r\n\r\n        return result;\r\n    },\r\n\r\n    SUMSQ: (...params) => {\r\n        // parse string to number only when it is a literal. (not a reference)\r\n        let result = 0;\r\n        H.flattenParams(params, Types.NUMBER, true,\r\n            (item, info) => {\r\n                // literal will be parsed to given type (Type.NUMBER)\r\n                if (info.isLiteral) {\r\n                    result += item ** 2;\r\n                } else {\r\n                    if (typeof item === \"number\")\r\n                        result += item ** 2;\r\n                }\r\n            });\r\n        return result\r\n    },\r\n\r\n    SUMX2MY2: (arrayX, arrayY) => {\r\n        const x = [], y = [];\r\n        let sum = 0;\r\n        H.flattenParams([arrayX], null, false, (item, info) => {\r\n            x.push(item);\r\n        });\r\n        H.flattenParams([arrayY], null, false, (item, info) => {\r\n            y.push(item);\r\n        });\r\n        if (x.length !== y.length)\r\n            throw FormulaError.NA;\r\n        for (let i = 0; i < x.length; i++) {\r\n            if (typeof x[i] === \"number\" && typeof y[i] === \"number\")\r\n                sum += x[i] ** 2 - y[i] ** 2\r\n        }\r\n        return sum;\r\n    },\r\n\r\n    SUMX2PY2: (arrayX, arrayY) => {\r\n        const x = [], y = [];\r\n        let sum = 0;\r\n        H.flattenParams([arrayX], null, false, (item, info) => {\r\n            x.push(item);\r\n        });\r\n        H.flattenParams([arrayY], null, false, (item, info) => {\r\n            y.push(item);\r\n        });\r\n        if (x.length !== y.length)\r\n            throw FormulaError.NA;\r\n        for (let i = 0; i < x.length; i++) {\r\n            if (typeof x[i] === \"number\" && typeof y[i] === \"number\")\r\n                sum += x[i] ** 2 + y[i] ** 2\r\n        }\r\n        return sum;\r\n    },\r\n\r\n    SUMXMY2: (arrayX, arrayY) => {\r\n        const x = [], y = [];\r\n        let sum = 0;\r\n        H.flattenParams([arrayX], null, false, (item, info) => {\r\n            x.push(item);\r\n        });\r\n        H.flattenParams([arrayY], null, false, (item, info) => {\r\n            y.push(item);\r\n        });\r\n        if (x.length !== y.length)\r\n            throw FormulaError.NA;\r\n        for (let i = 0; i < x.length; i++) {\r\n            if (typeof x[i] === \"number\" && typeof y[i] === \"number\")\r\n                sum += (x[i] - y[i]) ** 2;\r\n        }\r\n        return sum;\r\n    },\r\n\r\n    TRUNC: (number) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.trunc(number);\r\n    },\r\n};\r\n\r\n\r\nmodule.exports = MathFunctions;\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types} = require('../helpers');\r\nconst H = FormulaHelpers;\r\nconst MAX_NUMBER = 2 ** 27 - 1;\r\n\r\n// https://support.office.com/en-us/article/excel-functions-by-category-5f91f4e9-7b42-46d2-9bd1-63f26a86c0eb\r\nconst TrigFunctions = {\r\n    ACOS: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number > 1 || number < -1)\r\n            throw FormulaError.NUM;\r\n        return Math.acos(number);\r\n    },\r\n\r\n    ACOSH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number < 1)\r\n            throw FormulaError.NUM;\r\n        return Math.acosh(number);\r\n    },\r\n\r\n    ACOT: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.PI / 2 - Math.atan(number);\r\n    },\r\n\r\n    ACOTH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) <= 1)\r\n            throw FormulaError.NUM;\r\n        return Math.atanh(1 / number);\r\n    },\r\n\r\n    ASIN: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number > 1 || number < -1)\r\n            throw FormulaError.NUM;\r\n        return Math.asin(number);\r\n    },\r\n\r\n    ASINH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.asinh(number);\r\n    },\r\n\r\n    ATAN: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.atan(number);\r\n    },\r\n\r\n    ATAN2: (x, y) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        y = H.accept(y, Types.NUMBER);\r\n        if (y === 0 && x === 0)\r\n            throw FormulaError.DIV0;\r\n        return Math.atan2(y, x);\r\n    },\r\n\r\n    ATANH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) > 1)\r\n            throw FormulaError.NUM;\r\n        return Math.atanh(number);\r\n    },\r\n\r\n    COS: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) > MAX_NUMBER)\r\n            throw FormulaError.NUM;\r\n        return Math.cos(number);\r\n    },\r\n\r\n    COSH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.cosh(number);\r\n    },\r\n\r\n    COT: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) > MAX_NUMBER)\r\n            throw FormulaError.NUM;\r\n        if (number === 0)\r\n            throw FormulaError.DIV0;\r\n        return 1 / Math.tan(number);\r\n    },\r\n\r\n    COTH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number === 0)\r\n            throw FormulaError.DIV0;\r\n        return 1 / Math.tanh(number);\r\n    },\r\n\r\n    CSC: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) > MAX_NUMBER)\r\n            throw FormulaError.NUM;\r\n        return 1 / Math.sin(number);\r\n    },\r\n\r\n    CSCH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (number === 0)\r\n            throw FormulaError.DIV0;\r\n        return 1 / Math.sinh(number);\r\n    },\r\n\r\n    SEC: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) > MAX_NUMBER)\r\n            throw FormulaError.NUM;\r\n        return 1 / Math.cos(number);\r\n    },\r\n\r\n    SECH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return 1 / Math.cosh(number);\r\n    },\r\n\r\n    SIN: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) > MAX_NUMBER)\r\n            throw FormulaError.NUM;\r\n        return Math.sin(number);\r\n    },\r\n\r\n    SINH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.sinh(number);\r\n    },\r\n\r\n    TAN: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        if (Math.abs(number) > MAX_NUMBER)\r\n            throw FormulaError.NUM;\r\n        return Math.tan(number);\r\n    },\r\n\r\n    TANH: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        return Math.tanh(number);\r\n    },\r\n};\r\n\r\nmodule.exports = TrigFunctions;\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types,} = require('../helpers');\r\nconst H = FormulaHelpers;\r\n\r\n/**\r\n * Get the number of values that evaluate to true and false.\r\n * Cast Number and \"TRUE\", \"FALSE\" to boolean.\r\n * Ignore unrelated values.\r\n * @ignore\r\n * @param {any[]} params\r\n * @return {number[]}\r\n */\r\nfunction getNumLogicalValue(params) {\r\n    let numTrue = 0, numFalse = 0;\r\n    H.flattenParams(params, null, true, val => {\r\n        const type = typeof val;\r\n        if (type === \"string\") {\r\n            if (val === 'TRUE')\r\n                val = true;\r\n            else if (val === 'FALSE')\r\n                val = false;\r\n        } else if (type === \"number\")\r\n            val = Boolean(val);\r\n\r\n        if (typeof val === \"boolean\") {\r\n            if (val === true)\r\n                numTrue++;\r\n            else\r\n                numFalse++;\r\n        }\r\n    });\r\n    return [numTrue, numFalse];\r\n}\r\n\r\nconst LogicalFunctions = {\r\n    AND: (...params) => {\r\n        const [numTrue, numFalse] = getNumLogicalValue(params);\r\n\r\n        // OR returns #VALUE! if no logical values are found.\r\n        if (numTrue === 0 && numFalse === 0)\r\n            return FormulaError.VALUE;\r\n\r\n        return numTrue > 0 && numFalse === 0;\r\n    },\r\n\r\n    FALSE: () => {\r\n        return false;\r\n    },\r\n\r\n    // Special\r\n    IF: (context, logicalTest, valueIfTrue, valueIfFalse) => {\r\n        logicalTest = H.accept(logicalTest, Types.BOOLEAN);\r\n        valueIfTrue = H.accept(valueIfTrue); // do not parse type\r\n        valueIfFalse = H.accept(valueIfFalse, null, false); // do not parse type\r\n\r\n        return logicalTest ? valueIfTrue : valueIfFalse;\r\n    },\r\n\r\n    IFERROR: (value, valueIfError) => {\r\n        return value.value instanceof FormulaError ? H.accept(valueIfError) : H.accept(value);\r\n    },\r\n\r\n    IFNA: function (value, valueIfNa) {\r\n        if (arguments.length > 2)\r\n            throw FormulaError.TOO_MANY_ARGS('IFNA');\r\n        return FormulaError.NA.equals(value.value) ? H.accept(valueIfNa) : H.accept(value);\r\n    },\r\n\r\n    IFS: (...params) => {\r\n        if (params.length % 2 !== 0)\r\n            return new FormulaError('#N/A', 'IFS expects all arguments after position 0 to be in pairs.');\r\n\r\n        for (let i = 0; i < params.length / 2; i++) {\r\n            const logicalTest = H.accept(params[i * 2], Types.BOOLEAN);\r\n            const valueIfTrue = H.accept(params[i * 2 + 1]);\r\n            if (logicalTest)\r\n                return valueIfTrue;\r\n        }\r\n\r\n        return FormulaError.NA;\r\n    },\r\n\r\n    NOT: (logical) => {\r\n        logical = H.accept(logical, Types.BOOLEAN);\r\n        return !logical;\r\n    },\r\n\r\n    OR: (...params) => {\r\n        const [numTrue, numFalse] = getNumLogicalValue(params);\r\n\r\n        // OR returns #VALUE! if no logical values are found.\r\n        if (numTrue === 0 && numFalse === 0)\r\n            return FormulaError.VALUE;\r\n\r\n        return numTrue > 0;\r\n    },\r\n\r\n    SWITCH: (...params) => {\r\n\r\n    },\r\n\r\n    TRUE: () => {\r\n        return true;\r\n    },\r\n\r\n    XOR: (...params) => {\r\n        const [numTrue, numFalse] = getNumLogicalValue(params);\r\n\r\n        // XOR returns #VALUE! if no logical values are found.\r\n        if (numTrue === 0 && numFalse === 0)\r\n            return FormulaError.VALUE;\r\n\r\n        return numTrue % 2 === 1;\r\n    },\r\n};\r\n\r\nmodule.exports = LogicalFunctions;\r\n", "/* bessel.js (C) 2013-present SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\n/*exported BESSEL */\nvar BESSEL;\n(function (factory) {\n  /*jshint ignore:start */\n  if(typeof DO_NOT_EXPORT_BESSEL === 'undefined') {\n    if('object' === typeof exports) {\n      factory(exports);\n    } else if ('function' === typeof define && define.amd) {\n      define(function () {\n        var module = {};\n        factory(module);\n        return module;\n      });\n    } else {\n      factory(BESSEL = {});\n    }\n  } else {\n    factory(BESSEL = {});\n  }\n  /*jshint ignore:end */\n}(function(BESSEL) {\nBESSEL.version = '1.0.2';\nvar M = Math;\n\nfunction _horner(arr, v) { for(var i = 0, z = 0; i < arr.length; ++i) z = v * z + arr[i]; return z; }\nfunction _bessel_iter(x, n, f0, f1, sign) {\n  if(n === 0) return f0;\n  if(n === 1) return f1;\n  var tdx = 2 / x, f2 = f1;\n  for(var o = 1; o < n; ++o) {\n    f2 = f1 * o * tdx + sign * f0;\n    f0 = f1; f1 = f2;\n  }\n  return f2;\n}\nfunction _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {\n  return function bessel(x,n) {\n    if(nonzero) {\n      if(x === 0) return (nonzero == 1 ? -Infinity : Infinity);\n      else if(x < 0) return NaN;\n    }\n    if(n === 0) return bessel0(x);\n    if(n === 1) return bessel1(x);\n    if(n < 0) return NaN;\n    n|=0;\n    var b0 = bessel0(x), b1 = bessel1(x);\n    return _bessel_iter(x, n, b0, b1, sign);\n  };\n}\nvar besselj = (function() {\n  var W = 0.636619772; // 2 / Math.PI\n\n  var b0_a1a = [57568490574.0, -13362590354.0, 651619640.7, -11214424.18, 77392.33017, -184.9052456].reverse();\n  var b0_a2a = [57568490411.0, 1029532985.0, 9494680.718, 59272.64853, 267.8532712, 1.0].reverse();\n  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();\n  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();\n\n  function bessel0(x) {\n    var a=0, a1=0, a2=0, y = x * x;\n    if(x < 8) {\n      a1 = _horner(b0_a1a, y);\n      a2 = _horner(b0_a2a, y);\n      a = a1 / a2;\n    } else {\n      var xx = x - 0.785398164;\n      y = 64 / y;\n      a1 = _horner(b0_a1b, y);\n      a2 = _horner(b0_a2b, y);\n      a = M.sqrt(W/x)*(M.cos(xx)*a1-M.sin(xx)*a2*8/x);\n    }\n    return a;\n  }\n\n  var b1_a1a = [72362614232.0, -7895059235.0, 242396853.1, -2972611.439, 15704.48260, -30.16036606].reverse();\n  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();\n  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();\n  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();\n\n  function bessel1(x) {\n    var a=0, a1=0, a2=0, y = x*x, xx = M.abs(x) - 2.356194491;\n    if(Math.abs(x)< 8) {\n      a1 = x*_horner(b1_a1a, y);\n      a2 = _horner(b1_a2a, y);\n      a = a1 / a2;\n    } else {\n      y = 64 / y;\n      a1=_horner(b1_a1b, y);\n      a2=_horner(b1_a2b, y);\n      a=M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));\n      if(x < 0) a = -a;\n    }\n    return a;\n  }\n\n  return function besselj(x, n) {\n    n = Math.round(n);\n    if(!isFinite(x)) return isNaN(x) ? x : 0;\n    if(n < 0) return ((n%2)?-1:1)*besselj(x, -n);\n    if(x < 0) return ((n%2)?-1:1)*besselj(-x, n);\n    if(n === 0) return bessel0(x);\n    if(n === 1) return bessel1(x);\n    if(x === 0) return 0;\n\n    var ret=0.0;\n    if(x > n) {\n      ret = _bessel_iter(x, n, bessel0(x), bessel1(x),-1);\n    } else {\n      var m=2*M.floor((n+M.floor(M.sqrt(40*n)))/2);\n      var jsum=false;\n      var bjp=0.0, sum=0.0;\n      var bj=1.0, bjm = 0.0;\n      var tox = 2 / x;\n      for (var j=m;j>0;j--) {\n        bjm=j*tox*bj-bjp;\n        bjp=bj;\n        bj=bjm;\n        if (M.abs(bj) > 1E10) {\n          bj *= 1E-10;\n          bjp *= 1E-10;\n          ret *= 1E-10;\n          sum *= 1E-10;\n        }\n        if (jsum) sum += bj;\n        jsum=!jsum;\n        if (j == n) ret=bjp;\n      }\n      sum=2.0*sum-bj;\n      ret /= sum;\n    }\n    return ret;\n  };\n})();\nvar bessely = (function() {\n  var W = 0.636619772;\n\n  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();\n  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();\n  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();\n  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();\n\n  function bessel0(x) {\n    var a=0, a1=0, a2=0, y = x * x, xx = x - 0.785398164;\n    if(x < 8) {\n      a1 = _horner(b0_a1a, y);\n      a2 = _horner(b0_a2a, y);\n      a = a1/a2 + W * besselj(x,0) * M.log(x);\n    } else {\n      y = 64 / y;\n      a1 = _horner(b0_a1b, y);\n      a2 = _horner(b0_a2b, y);\n      a = M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);\n    }\n    return a;\n  }\n\n  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();\n  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();\n  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();\n  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();\n\n  function bessel1(x) {\n    var a=0, a1=0, a2=0, y = x*x, xx = x - 2.356194491;\n    if(x < 8) {\n      a1 = x*_horner(b1_a1a, y);\n      a2 = _horner(b1_a2a, y);\n      a = a1/a2 + W * (besselj(x,1) * M.log(x) - 1 / x);\n    } else {\n      y = 64 / y;\n      a1=_horner(b1_a1b, y);\n      a2=_horner(b1_a2b, y);\n      a=M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);\n    }\n    return a;\n  }\n\n  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);\n})();\nvar besseli = (function() {\n  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();\n  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();\n\n  function bessel0(x) {\n    if(x <= 3.75) return _horner(b0_a, x*x/(3.75*3.75));\n    return M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b0_b, 3.75/M.abs(x));\n  }\n\n  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();\n  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();\n\n  function bessel1(x) {\n    if(x < 3.75) return x * _horner(b1_a, x*x/(3.75*3.75));\n    return (x < 0 ? -1 : 1) * M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b1_b, 3.75/M.abs(x));\n  }\n\n  return function besseli(x, n) {\n    n = Math.round(n);\n    if(n === 0) return bessel0(x);\n    if(n === 1) return bessel1(x);\n    if(n < 0) return NaN;\n    if(M.abs(x) === 0) return 0;\n    if(x == Infinity) return Infinity;\n\n    var ret = 0.0, j, tox = 2 / M.abs(x), bip = 0.0, bi=1.0, bim=0.0;\n    var m=2*M.round((n+M.round(M.sqrt(40*n)))/2);\n    for (j=m;j>0;j--) {\n      bim=j*tox*bi + bip;\n      bip=bi; bi=bim;\n      if (M.abs(bi) > 1E10) {\n        bi *= 1E-10;\n        bip *= 1E-10;\n        ret *= 1E-10;\n      }\n      if(j == n) ret = bip;\n    }\n    ret *= besseli(x, 0) / bi;\n    return x < 0 && (n%2) ? -ret : ret;\n  };\n\n})();\n\nvar besselk = (function() {\n  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();\n  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();\n\n  function bessel0(x) {\n    if(x <= 2) return -M.log(x/2) * besseli(x,0) + _horner(b0_a, x*x/4);\n    return M.exp(-x) / M.sqrt(x) * _horner(b0_b, 2/x);\n  }\n\n  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();\n  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();\n\n  function bessel1(x) {\n    if(x <= 2) return M.log(x/2) * besseli(x,1) + (1/x) * _horner(b1_a, x*x/4);\n    return M.exp(-x)/M.sqrt(x)*_horner(b1_b, 2/x);\n  }\n\n  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);\n})();\nBESSEL.besselj = besselj;\nBESSEL.bessely = bessely;\nBESSEL.besseli = besseli;\nBESSEL.besselk = besselk;\n}));\n", "(function (window, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        window.jStat = factory();\n    }\n})(this, function () {\nvar jStat = (function(Math, undefined) {\n\n// For quick reference.\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n// Calculate correction for IEEE error\n// TODO: This calculation can be improved.\nfunction calcRdx(n, m) {\n  var val = n > m ? n : m;\n  return Math.pow(10,\n                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));\n}\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return toString.call(arg) === '[object Array]';\n};\n\n\nfunction isFunction(arg) {\n  return toString.call(arg) === '[object Function]';\n}\n\n\nfunction isNumber(num) {\n  return (typeof num === 'number') ? num - num === 0 : false;\n}\n\n\n// Converts the jStat matrix to vector.\nfunction toVector(arr) {\n  return concat.apply([], arr);\n}\n\n\n// The one and only jStat constructor.\nfunction jStat() {\n  return new jStat._init(arguments);\n}\n\n\n// TODO: Remove after all references in src files have been removed.\njStat.fn = jStat.prototype;\n\n\n// By separating the initializer from the constructor it's easier to handle\n// always returning a new instance whether \"new\" was used or not.\njStat._init = function _init(args) {\n  // If first argument is an array, must be vector or matrix.\n  if (isArray(args[0])) {\n    // Check if matrix.\n    if (isArray(args[0][0])) {\n      // See if a mapping function was also passed.\n      if (isFunction(args[1]))\n        args[0] = jStat.map(args[0], args[1]);\n      // Iterate over each is faster than this.push.apply(this, args[0].\n      for (var i = 0; i < args[0].length; i++)\n        this[i] = args[0][i];\n      this.length = args[0].length;\n\n    // Otherwise must be a vector.\n    } else {\n      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];\n      this.length = 1;\n    }\n\n  // If first argument is number, assume creation of sequence.\n  } else if (isNumber(args[0])) {\n    this[0] = jStat.seq.apply(null, args);\n    this.length = 1;\n\n  // Handle case when jStat object is passed to jStat.\n  } else if (args[0] instanceof jStat) {\n    // Duplicate the object and pass it back.\n    return jStat(args[0].toArray());\n\n  // Unexpected argument value, return empty jStat object.\n  // TODO: This is strange behavior. Shouldn't this throw or some such to let\n  // the user know they had bad arguments?\n  } else {\n    this[0] = [];\n    this.length = 1;\n  }\n\n  return this;\n};\njStat._init.prototype = jStat.prototype;\njStat._init.constructor = jStat;\n\n\n// Utility functions.\n// TODO: for internal use only?\njStat.utils = {\n  calcRdx: calcRdx,\n  isArray: isArray,\n  isFunction: isFunction,\n  isNumber: isNumber,\n  toVector: toVector\n};\n\n\njStat._random_fn = Math.random;\njStat.setRandom = function setRandom(fn) {\n  if (typeof fn !== 'function')\n    throw new TypeError('fn is not a function');\n  jStat._random_fn = fn;\n};\n\n\n// Easily extend the jStat object.\n// TODO: is this seriously necessary?\njStat.extend = function extend(obj) {\n  var i, j;\n\n  if (arguments.length === 1) {\n    for (j in obj)\n      jStat[j] = obj[j];\n    return this;\n  }\n\n  for (i = 1; i < arguments.length; i++) {\n    for (j in arguments[i])\n      obj[j] = arguments[i][j];\n  }\n\n  return obj;\n};\n\n\n// Returns the number of rows in the matrix.\njStat.rows = function rows(arr) {\n  return arr.length || 1;\n};\n\n\n// Returns the number of columns in the matrix.\njStat.cols = function cols(arr) {\n  return arr[0].length || 1;\n};\n\n\n// Returns the dimensions of the object { rows: i, cols: j }\njStat.dimensions = function dimensions(arr) {\n  return {\n    rows: jStat.rows(arr),\n    cols: jStat.cols(arr)\n  };\n};\n\n\n// Returns a specified row as a vector or return a sub matrix by pick some rows\njStat.row = function row(arr, index) {\n  if (isArray(index)) {\n    return index.map(function(i) {\n      return jStat.row(arr, i);\n    })\n  }\n  return arr[index];\n};\n\n\n// return row as array\n// rowa([[1,2],[3,4]],0) -> [1,2]\njStat.rowa = function rowa(arr, i) {\n  return jStat.row(arr, i);\n};\n\n\n// Returns the specified column as a vector or return a sub matrix by pick some\n// columns\njStat.col = function col(arr, index) {\n  if (isArray(index)) {\n    var submat = jStat.arange(arr.length).map(function() {\n      return new Array(index.length);\n    });\n    index.forEach(function(ind, i){\n      jStat.arange(arr.length).forEach(function(j) {\n        submat[j][i] = arr[j][ind];\n      });\n    });\n    return submat;\n  }\n  var column = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++)\n    column[i] = [arr[i][index]];\n  return column;\n};\n\n\n// return column as array\n// cola([[1,2],[3,4]],0) -> [1,3]\njStat.cola = function cola(arr, i) {\n  return jStat.col(arr, i).map(function(a){ return a[0] });\n};\n\n\n// Returns the diagonal of the matrix\njStat.diag = function diag(arr) {\n  var nrow = jStat.rows(arr);\n  var res = new Array(nrow);\n  for (var row = 0; row < nrow; row++)\n    res[row] = [arr[row][row]];\n  return res;\n};\n\n\n// Returns the anti-diagonal of the matrix\njStat.antidiag = function antidiag(arr) {\n  var nrow = jStat.rows(arr) - 1;\n  var res = new Array(nrow);\n  for (var i = 0; nrow >= 0; nrow--, i++)\n    res[i] = [arr[i][nrow]];\n  return res;\n};\n\n// Transpose a matrix or array.\njStat.transpose = function transpose(arr) {\n  var obj = [];\n  var objArr, rows, cols, j, i;\n\n  // Make sure arr is in matrix format.\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  rows = arr.length;\n  cols = arr[0].length;\n\n  for (i = 0; i < cols; i++) {\n    objArr = new Array(rows);\n    for (j = 0; j < rows; j++)\n      objArr[j] = arr[j][i];\n    obj.push(objArr);\n  }\n\n  // If obj is vector, return only single array.\n  return obj.length === 1 ? obj[0] : obj;\n};\n\n\n// Map a function to an array or array of arrays.\n// \"toAlter\" is an internal variable.\njStat.map = function map(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    for (col = 0; col < ncol; col++)\n      res[row][col] = func(arr[row][col], row, col);\n  }\n\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Cumulatively combine the elements of an array or array of arrays using a function.\njStat.cumreduce = function cumreduce(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    if (ncol > 0)\n      res[row][0] = arr[row][0];\n    for (col = 1; col < ncol; col++)\n      res[row][col] = func(res[row][col-1], arr[row][col]);\n  }\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Destructively alter an array.\njStat.alter = function alter(arr, func) {\n  return jStat.map(arr, func, true);\n};\n\n\n// Generate a rows x cols matrix according to the supplied function.\njStat.create = function  create(rows, cols, func) {\n  var res = new Array(rows);\n  var i, j;\n\n  if (isFunction(cols)) {\n    func = cols;\n    cols = rows;\n  }\n\n  for (i = 0; i < rows; i++) {\n    res[i] = new Array(cols);\n    for (j = 0; j < cols; j++)\n      res[i][j] = func(i, j);\n  }\n\n  return res;\n};\n\n\nfunction retZero() { return 0; }\n\n\n// Generate a rows x cols matrix of zeros.\njStat.zeros = function zeros(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retZero);\n};\n\n\nfunction retOne() { return 1; }\n\n\n// Generate a rows x cols matrix of ones.\njStat.ones = function ones(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retOne);\n};\n\n\n// Generate a rows x cols matrix of uniformly random numbers.\njStat.rand = function rand(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, jStat._random_fn);\n};\n\n\nfunction retIdent(i, j) { return i === j ? 1 : 0; }\n\n\n// Generate an identity matrix of size row x cols.\njStat.identity = function identity(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retIdent);\n};\n\n\n// Tests whether a matrix is symmetric\njStat.symmetric = function symmetric(arr) {\n  var size = arr.length;\n  var row, col;\n\n  if (arr.length !== arr[0].length)\n    return false;\n\n  for (row = 0; row < size; row++) {\n    for (col = 0; col < size; col++)\n      if (arr[col][row] !== arr[row][col])\n        return false;\n  }\n\n  return true;\n};\n\n\n// Set all values to zero.\njStat.clear = function clear(arr) {\n  return jStat.alter(arr, retZero);\n};\n\n\n// Generate sequence.\njStat.seq = function seq(min, max, length, func) {\n  if (!isFunction(func))\n    func = false;\n\n  var arr = [];\n  var hival = calcRdx(min, max);\n  var step = (max * hival - min * hival) / ((length - 1) * hival);\n  var current = min;\n  var cnt;\n\n  // Current is assigned using a technique to compensate for IEEE error.\n  // TODO: Needs better implementation.\n  for (cnt = 0;\n       current <= max && cnt < length;\n       cnt++, current = (min * hival + step * hival * cnt) / hival) {\n    arr.push((func ? func(current, cnt) : current));\n  }\n\n  return arr;\n};\n\n\n// arange(5) -> [0,1,2,3,4]\n// arange(1,5) -> [1,2,3,4]\n// arange(5,1,-1) -> [5,4,3,2]\njStat.arange = function arange(start, end, step) {\n  var rl = [];\n  var i;\n  step = step || 1;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  if (start === end || step === 0) {\n    return [];\n  }\n  if (start < end && step < 0) {\n    return [];\n  }\n  if (start > end && step > 0) {\n    return [];\n  }\n  if (step > 0) {\n    for (i = start; i < end; i += step) {\n      rl.push(i);\n    }\n  } else {\n    for (i = start; i > end; i += step) {\n      rl.push(i);\n    }\n  }\n  return rl;\n};\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]\n// slice(A,1,{start:1}) -> [5,6]\n// as numpy code A[:2,1:]\njStat.slice = (function(){\n  function _slice(list, start, end, step) {\n    // note it's not equal to range.map mode it's a bug\n    var i;\n    var rl = [];\n    var length = list.length;\n    if (start === undefined && end === undefined && step === undefined) {\n      return jStat.copy(list);\n    }\n\n    start = start || 0;\n    end = end || list.length;\n    start = start >= 0 ? start : length + start;\n    end = end >= 0 ? end : length + end;\n    step = step || 1;\n    if (start === end || step === 0) {\n      return [];\n    }\n    if (start < end && step < 0) {\n      return [];\n    }\n    if (start > end && step > 0) {\n      return [];\n    }\n    if (step > 0) {\n      for (i = start; i < end; i += step) {\n        rl.push(list[i]);\n      }\n    } else {\n      for (i = start; i > end;i += step) {\n        rl.push(list[i]);\n      }\n    }\n    return rl;\n  }\n\n  function slice(list, rcSlice) {\n    var colSlice, rowSlice;\n    rcSlice = rcSlice || {};\n    if (isNumber(rcSlice.row)) {\n      if (isNumber(rcSlice.col))\n        return list[rcSlice.row][rcSlice.col];\n      var row = jStat.rowa(list, rcSlice.row);\n      colSlice = rcSlice.col || {};\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    }\n\n    if (isNumber(rcSlice.col)) {\n      var col = jStat.cola(list, rcSlice.col);\n      rowSlice = rcSlice.row || {};\n      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);\n    }\n\n    rowSlice = rcSlice.row || {};\n    colSlice = rcSlice.col || {};\n    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);\n    return rows.map(function(row) {\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    });\n  }\n\n  return slice;\n}());\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])\n// A=[[1,2,3],[4,0,0],[7,0,0]]\njStat.sliceAssign = function sliceAssign(A, rcSlice, B) {\n  var nl, ml;\n  if (isNumber(rcSlice.row)) {\n    if (isNumber(rcSlice.col))\n      return A[rcSlice.row][rcSlice.col] = B;\n    rcSlice.col = rcSlice.col || {};\n    rcSlice.col.start = rcSlice.col.start || 0;\n    rcSlice.col.end = rcSlice.col.end || A[0].length;\n    rcSlice.col.step = rcSlice.col.step || 1;\n    nl = jStat.arange(rcSlice.col.start,\n                          Math.min(A.length, rcSlice.col.end),\n                          rcSlice.col.step);\n    var m = rcSlice.row;\n    nl.forEach(function(n, i) {\n      A[m][n] = B[i];\n    });\n    return A;\n  }\n\n  if (isNumber(rcSlice.col)) {\n    rcSlice.row = rcSlice.row || {};\n    rcSlice.row.start = rcSlice.row.start || 0;\n    rcSlice.row.end = rcSlice.row.end || A.length;\n    rcSlice.row.step = rcSlice.row.step || 1;\n    ml = jStat.arange(rcSlice.row.start,\n                          Math.min(A[0].length, rcSlice.row.end),\n                          rcSlice.row.step);\n    var n = rcSlice.col;\n    ml.forEach(function(m, j) {\n      A[m][n] = B[j];\n    });\n    return A;\n  }\n\n  if (B[0].length === undefined) {\n    B = [B];\n  }\n  rcSlice.row.start = rcSlice.row.start || 0;\n  rcSlice.row.end = rcSlice.row.end || A.length;\n  rcSlice.row.step = rcSlice.row.step || 1;\n  rcSlice.col.start = rcSlice.col.start || 0;\n  rcSlice.col.end = rcSlice.col.end || A[0].length;\n  rcSlice.col.step = rcSlice.col.step || 1;\n  ml = jStat.arange(rcSlice.row.start,\n                        Math.min(A.length, rcSlice.row.end),\n                        rcSlice.row.step);\n  nl = jStat.arange(rcSlice.col.start,\n                        Math.min(A[0].length, rcSlice.col.end),\n                        rcSlice.col.step);\n  ml.forEach(function(m, i) {\n    nl.forEach(function(n, j) {\n      A[m][n] = B[i][j];\n    });\n  });\n  return A;\n};\n\n\n// [1,2,3] ->\n// [[1,0,0],[0,2,0],[0,0,3]]\njStat.diagonal = function diagonal(diagArray) {\n  var mat = jStat.zeros(diagArray.length, diagArray.length);\n  diagArray.forEach(function(t, i) {\n    mat[i][i] = t;\n  });\n  return mat;\n};\n\n\n// return copy of A\njStat.copy = function copy(A) {\n  return A.map(function(row) {\n    if (isNumber(row))\n      return row;\n    return row.map(function(t) {\n      return t;\n    });\n  });\n};\n\n\n// TODO: Go over this entire implementation. Seems a tragic waste of resources\n// doing all this work. Instead, and while ugly, use new Function() to generate\n// a custom function for each static method.\n\n// Quick reference.\nvar jProto = jStat.prototype;\n\n// Default length.\njProto.length = 0;\n\n// For internal use only.\n// TODO: Check if they're actually used, and if they are then rename them\n// to _*\njProto.push = Array.prototype.push;\njProto.sort = Array.prototype.sort;\njProto.splice = Array.prototype.splice;\njProto.slice = Array.prototype.slice;\n\n\n// Return a clean array.\njProto.toArray = function toArray() {\n  return this.length > 1 ? slice.call(this) : slice.call(this)[0];\n};\n\n\n// Map a function to a matrix or vector.\njProto.map = function map(func, toAlter) {\n  return jStat(jStat.map(this, func, toAlter));\n};\n\n\n// Cumulatively combine the elements of a matrix or vector using a function.\njProto.cumreduce = function cumreduce(func, toAlter) {\n  return jStat(jStat.cumreduce(this, func, toAlter));\n};\n\n\n// Destructively alter an array.\njProto.alter = function alter(func) {\n  jStat.alter(this, func);\n  return this;\n};\n\n\n// Extend prototype with methods that have no argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(func) {\n      var self = this,\n      results;\n      // Check for callback.\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self));\n        });\n        return this;\n      }\n      results = jStat[passfunc](this);\n      return isArray(results) ? jStat(results) : results;\n    };\n  })(funcs[i]);\n})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));\n\n\n// Extend prototype with methods that have one argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(index, func) {\n      var self = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self, index));\n        });\n        return this;\n      }\n      return jStat(jStat[passfunc](this, index));\n    };\n  })(funcs[i]);\n})('row col'.split(' '));\n\n\n// Extend prototype with simple shortcut methods.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('create zeros ones rand identity'.split(' '));\n\n\n// Exposing jStat.\nreturn jStat;\n\n}(Math));\n(function(jStat, Math) {\n\nvar isFunction = jStat.utils.isFunction;\n\n// Ascending functions for sort\nfunction ascNum(a, b) { return a - b; }\n\nfunction clip(arg, min, max) {\n  return Math.max(min, Math.min(arg, max));\n}\n\n\n// sum of an array\njStat.sum = function sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n\n// sum squared\njStat.sumsqrd = function sumsqrd(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i] * arr[i];\n  return sum;\n};\n\n\n// sum of squared errors of prediction (SSE)\njStat.sumsqerr = function sumsqerr(arr) {\n  var mean = jStat.mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - mean;\n    sum += tmp * tmp;\n  }\n  return sum;\n};\n\n// sum of an array in each row\njStat.sumrow = function sumrow(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n// product of an array\njStat.product = function product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0)\n    prod *= arr[i];\n  return prod;\n};\n\n\n// minimum value of an array\njStat.min = function min(arr) {\n  var low = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] < low)\n      low = arr[i];\n  return low;\n};\n\n\n// maximum value of an array\njStat.max = function max(arr) {\n  var high = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] > high)\n      high = arr[i];\n  return high;\n};\n\n\n// unique values of an array\njStat.unique = function unique(arr) {\n  var hash = {}, _arr = [];\n  for(var i = 0; i < arr.length; i++) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      _arr.push(arr[i]);\n    }\n  }\n  return _arr;\n};\n\n\n// mean value of an array\njStat.mean = function mean(arr) {\n  return jStat.sum(arr) / arr.length;\n};\n\n\n// mean squared error (MSE)\njStat.meansqerr = function meansqerr(arr) {\n  return jStat.sumsqerr(arr) / arr.length;\n};\n\n\n// geometric mean of an array\njStat.geomean = function geomean(arr) {\n  var logs = arr.map(Math.log)\n  var meanOfLogs = jStat.mean(logs)\n  return Math.exp(meanOfLogs)\n};\n\n\n// median of an array\njStat.median = function median(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  // check if array is even or odd, then return the appropriate\n  return !(arrlen & 1)\n    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2\n    : _arr[(arrlen / 2) | 0 ];\n};\n\n\n// cumulative sum of an array\njStat.cumsum = function cumsum(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a + b; });\n};\n\n\n// cumulative product of an array\njStat.cumprod = function cumprod(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a * b; });\n};\n\n\n// successive differences of a sequence\njStat.diff = function diff(arr) {\n  var diffs = [];\n  var arrLen = arr.length;\n  var i;\n  for (i = 1; i < arrLen; i++)\n    diffs.push(arr[i] - arr[i - 1]);\n  return diffs;\n};\n\n\n// ranks of an array\njStat.rank = function (arr) {\n  var i;\n  var distinctNumbers = [];\n  var numberCounts = {};\n  for (i = 0; i < arr.length; i++) {\n    var number = arr[i];\n    if (numberCounts[number]) {\n      numberCounts[number]++;\n    } else {\n      numberCounts[number] = 1;\n      distinctNumbers.push(number);\n    }\n  }\n\n  var sortedDistinctNumbers = distinctNumbers.sort(ascNum);\n  var numberRanks = {};\n  var currentRank = 1;\n  for (i = 0; i < sortedDistinctNumbers.length; i++) {\n    var number = sortedDistinctNumbers[i];\n    var count = numberCounts[number];\n    var first = currentRank;\n    var last = currentRank + count - 1;\n    var rank = (first + last) / 2;\n    numberRanks[number] = rank;\n    currentRank += count;\n  }\n\n  return arr.map(function (number) {\n    return numberRanks[number];\n  });\n};\n\n\n// mode of an array\n// if there are multiple modes of an array, return all of them\n// is this the appropriate way of handling it?\njStat.mode = function mode(arr) {\n  var arrLen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  var count = 1;\n  var maxCount = 0;\n  var numMaxCount = 0;\n  var mode_arr = [];\n  var i;\n\n  for (i = 0; i < arrLen; i++) {\n    if (_arr[i] === _arr[i + 1]) {\n      count++;\n    } else {\n      if (count > maxCount) {\n        mode_arr = [_arr[i]];\n        maxCount = count;\n        numMaxCount = 0;\n      }\n      // are there multiple max counts\n      else if (count === maxCount) {\n        mode_arr.push(_arr[i]);\n        numMaxCount++;\n      }\n      // resetting count for new value in array\n      count = 1;\n    }\n  }\n\n  return numMaxCount === 0 ? mode_arr[0] : mode_arr;\n};\n\n\n// range of an array\njStat.range = function range(arr) {\n  return jStat.max(arr) - jStat.min(arr);\n};\n\n// variance of an array\n// flag = true indicates sample instead of population\njStat.variance = function variance(arr, flag) {\n  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n};\n\n// pooled variance of an array of arrays\njStat.pooledvariance = function pooledvariance(arr) {\n  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);\n  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);\n  return sumsqerr / (count - arr.length);\n};\n\n// deviation of an array\njStat.deviation = function (arr) {\n  var mean = jStat.mean(arr);\n  var arrlen = arr.length;\n  var dev = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    dev[i] = arr[i] - mean;\n  }\n  return dev;\n};\n\n// standard deviation of an array\n// flag = true indicates sample instead of population\njStat.stdev = function stdev(arr, flag) {\n  return Math.sqrt(jStat.variance(arr, flag));\n};\n\n// pooled standard deviation of an array of arrays\njStat.pooledstdev = function pooledstdev(arr) {\n  return Math.sqrt(jStat.pooledvariance(arr));\n};\n\n// mean deviation (mean absolute deviation) of an array\njStat.meandev = function meandev(arr) {\n  var mean = jStat.mean(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - mean));\n  }\n  return jStat.mean(a);\n};\n\n\n// median deviation (median absolute deviation) of an array\njStat.meddev = function meddev(arr) {\n  var median = jStat.median(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - median));\n  }\n  return jStat.median(a);\n};\n\n\n// coefficient of variation\njStat.coeffvar = function coeffvar(arr) {\n  return jStat.stdev(arr) / jStat.mean(arr);\n};\n\n\n// quartiles of an array\njStat.quartiles = function quartiles(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  return [\n    _arr[ Math.round((arrlen) / 4) - 1 ],\n    _arr[ Math.round((arrlen) / 2) - 1 ],\n    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]\n  ];\n};\n\n\n// Arbitary quantiles of an array. Direct port of the scipy.stats\n// implementation by Pierre GF Gerard-Marchant.\njStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {\n  var sortedArray = arr.slice().sort(ascNum);\n  var quantileVals = [quantilesArray.length];\n  var n = arr.length;\n  var i, p, m, aleph, k, gamma;\n\n  if (typeof alphap === 'undefined')\n    alphap = 3 / 8;\n  if (typeof betap === 'undefined')\n    betap = 3 / 8;\n\n  for (i = 0; i < quantilesArray.length; i++) {\n    p = quantilesArray[i];\n    m = alphap + p * (1 - alphap - betap);\n    aleph = n * p + m;\n    k = Math.floor(clip(aleph, 1, n - 1));\n    gamma = clip(aleph - k, 0, 1);\n    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];\n  }\n\n  return quantileVals;\n};\n\n// Return the k-th percentile of values in a range, where k is in the range 0..1, inclusive.\n// Passing true for the exclusive parameter excludes both endpoints of the range.\njStat.percentile = function percentile(arr, k, exclusive) {\n  var _arr = arr.slice().sort(ascNum);\n  var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);\n  var index = parseInt(realIndex);\n  var frac = realIndex - index;\n  if (index + 1 < _arr.length) {\n    return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);\n  } else {\n    return _arr[index - 1];\n  }\n}\n\n// The percentile rank of score in a given array. Returns the percentage\n// of all values in the input array that are less than (kind='strict') or\n// less or equal than (kind='weak') score. Default is weak.\njStat.percentileOfScore = function percentileOfScore(arr, score, kind) {\n  var counter = 0;\n  var len = arr.length;\n  var strict = false;\n  var value, i;\n\n  if (kind === 'strict')\n    strict = true;\n\n  for (i = 0; i < len; i++) {\n    value = arr[i];\n    if ((strict && value < score) ||\n        (!strict && value <= score)) {\n      counter++;\n    }\n  }\n\n  return counter / len;\n};\n\n\n// Histogram (bin count) data\njStat.histogram = function histogram(arr, binCnt) {\n  binCnt = binCnt || 4;\n  var first = jStat.min(arr);\n  var binWidth = (jStat.max(arr) - first) / binCnt;\n  var len = arr.length;\n  var bins = [];\n  var i;\n\n  for (i = 0; i < binCnt; i++)\n    bins[i] = 0;\n  for (i = 0; i < len; i++)\n    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;\n\n  return bins;\n};\n\n\n// covariance of two arrays\njStat.covariance = function covariance(arr1, arr2) {\n  var u = jStat.mean(arr1);\n  var v = jStat.mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n\n  for (i = 0; i < arr1Len; i++)\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n\n  return jStat.sum(sq_dev) / (arr1Len - 1);\n};\n\n\n// (pearson's) population correlation coefficient, rho\njStat.corrcoeff = function corrcoeff(arr1, arr2) {\n  return jStat.covariance(arr1, arr2) /\n      jStat.stdev(arr1, 1) /\n      jStat.stdev(arr2, 1);\n};\n\n  // (spearman's) rank correlation coefficient, sp\njStat.spearmancoeff =  function (arr1, arr2) {\n  arr1 = jStat.rank(arr1);\n  arr2 = jStat.rank(arr2);\n  //return pearson's correlation of the ranks:\n  return jStat.corrcoeff(arr1, arr2);\n}\n\n\n// statistical standardized moments (general form of skew/kurt)\njStat.stanMoment = function stanMoment(arr, n) {\n  var mu = jStat.mean(arr);\n  var sigma = jStat.stdev(arr);\n  var len = arr.length;\n  var skewSum = 0;\n\n  for (var i = 0; i < len; i++)\n    skewSum += Math.pow((arr[i] - mu) / sigma, n);\n\n  return skewSum / arr.length;\n};\n\n// (pearson's) moment coefficient of skewness\njStat.skewness = function skewness(arr) {\n  return jStat.stanMoment(arr, 3);\n};\n\n// (pearson's) (excess) kurtosis\njStat.kurtosis = function kurtosis(arr) {\n  return jStat.stanMoment(arr, 4) - 3;\n};\n\n\nvar jProto = jStat.prototype;\n\n\n// Extend jProto with method for calculating cumulative sums and products.\n// This differs from the similar extension below as cumsum and cumprod should\n// not be run again in the case fullbool === true.\n// If a matrix is passed, automatically assume operation should be done on the\n// columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('cumsum cumprod').split(' '));\n\n\n// Extend jProto with methods which don't require arguments and work on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        if (passfunc !== 'sumrow')\n          tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return fullbool === true\n            ? jStat[passfunc](jStat.utils.toVector(arr))\n            : arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +\n    'geomean median diff rank mode range variance deviation stdev meandev ' +\n    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));\n\n\n// Extend jProto with functions that take arguments. Operations on matrices are\n// done on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      var args = Array.prototype.slice.call(arguments);\n      var callbackFunction;\n\n      // If the last argument is a function, we assume it's a callback; we\n      // strip the callback out and call the function again.\n      if (isFunction(args[args.length - 1])) {\n        callbackFunction = args[args.length - 1];\n        var argsToPass = args.slice(0, args.length - 1);\n\n        setTimeout(function() {\n          callbackFunction.call(tmpthis,\n                                jProto[passfunc].apply(tmpthis, argsToPass));\n        });\n        return this;\n\n      // Otherwise we curry the function args and call normally.\n      } else {\n        callbackFunction = undefined;\n        var curriedFunction = function curriedFunction(vector) {\n          return jStat[passfunc].apply(tmpthis, [vector].concat(args));\n        }\n      }\n\n      // If this is a matrix, run column-by-column.\n      if (this.length > 1) {\n        tmpthis = tmpthis.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = curriedFunction(tmpthis[i]);\n        return arr;\n      }\n\n      // Otherwise run on the vector.\n      return curriedFunction(this[0]);\n    };\n  })(funcs[i]);\n})('quantiles percentileOfScore'.split(' '));\n\n}(jStat, Math));\n// Special functions //\n(function(jStat, Math) {\n\n// Log-gamma function\njStat.gammaln = function gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.50532032941677, 24.01409824083091,\n    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y;\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n};\n\n/*\n * log-gamma function to support poisson distribution sampling. The\n * algorithm comes from SPECFUN by Shanjie Zhang and Jianming Jin and their\n * book \"Computation of Special Functions\", 1996, John Wiley & Sons, Inc.\n */\njStat.loggam = function loggam(x) {\n  var x0, x2, xp, gl, gl0;\n  var k, n;\n\n  var a = [8.333333333333333e-02, -2.777777777777778e-03,\n          7.936507936507937e-04, -5.952380952380952e-04,\n          8.417508417508418e-04, -1.917526917526918e-03,\n          6.410256410256410e-03, -2.955065359477124e-02,\n          1.796443723688307e-01, -1.39243221690590e+00];\n  x0 = x;\n  n = 0;\n  if ((x == 1.0) || (x == 2.0)) {\n      return 0.0;\n  }\n  if (x <= 7.0) {\n      n = Math.floor(7 - x);\n      x0 = x + n;\n  }\n  x2 = 1.0 / (x0 * x0);\n  xp = 2 * Math.PI;\n  gl0 = a[9];\n  for (k = 8; k >= 0; k--) {\n      gl0 *= x2;\n      gl0 += a[k];\n  }\n  gl = gl0 / x0 + 0.5 * Math.log(xp) + (x0 - 0.5) * Math.log(x0) - x0;\n  if (x <= 7.0) {\n      for (k = 1; k <= n; k++) {\n          gl -= Math.log(x0 - 1.0);\n          x0 -= 1.0;\n      }\n  }\n  return gl;\n}\n\n// gamma of x\njStat.gammafn = function gammafn(x) {\n  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,\n           629.3311553128184, 866.9662027904133, -31451.272968848367,\n           -36144.413418691176, 66456.14382024054\n  ];\n  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,\n           -3107.771671572311, 22538.118420980151, 4755.8462775278811,\n           -134659.9598649693, -115132.2596755535];\n  var fact = false;\n  var n = 0;\n  var xden = 0;\n  var xnum = 0;\n  var y = x;\n  var i, z, yi, res;\n  if (x > 171.6243769536076) {\n    return Infinity;\n  }\n  if (y <= 0) {\n    res = y % 1 + 3.6e-16;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n};\n\n\n// lower incomplete gamma function, which is usually typeset with a\n// lower-case greek gamma as the function symbol\njStat.gammap = function gammap(a, x) {\n  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);\n};\n\n\n// The lower regularized incomplete gamma function, usually written P(a,x)\njStat.lowRegGamma = function lowRegGamma(a, x) {\n  var aln = jStat.gammaln(a);\n  var ap = a;\n  var sum = 1 / a;\n  var del = sum;\n  var b = x + 1 - a;\n  var c = 1 / 1.0e-30;\n  var d = 1 / b;\n  var h = d;\n  var i = 1;\n  // calculate maximum number of itterations required for a\n  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  var an;\n\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));\n  }\n\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n\n  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));\n};\n\n// natural log factorial of n\njStat.factorialln = function factorialln(n) {\n  return n < 0 ? NaN : jStat.gammaln(n + 1);\n};\n\n// factorial of n\njStat.factorial = function factorial(n) {\n  return n < 0 ? NaN : jStat.gammafn(n + 1);\n};\n\n// combinations of n, m\njStat.combination = function combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return (n > 170 || m > 170)\n      ? Math.exp(jStat.combinationln(n, m))\n      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);\n};\n\n\njStat.combinationln = function combinationln(n, m){\n  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);\n};\n\n\n// permutations of n, m\njStat.permutation = function permutation(n, m) {\n  return jStat.factorial(n) / jStat.factorial(n - m);\n};\n\n\n// beta function\njStat.betafn = function betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0)\n    return undefined;\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return (x + y > 170)\n      ? Math.exp(jStat.betaln(x, y))\n      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);\n};\n\n\n// natural logarithm of beta function\njStat.betaln = function betaln(x, y) {\n  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);\n};\n\n\n// Evaluates the continued fraction for incomplete beta function by modified\n// Lentz's method.\njStat.betacf = function betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7)\n      break;\n  }\n\n  return h;\n};\n\n\n// Returns the inverse of the lower regularized inomplete gamma function\njStat.gammapinv = function gammapinv(p, a) {\n  var j = 0;\n  var a1 = a - 1;\n  var EPS = 1e-8;\n  var gln = jStat.gammaln(a);\n  var x, err, t, u, pp, lna1, afac;\n\n  if (p >= 1)\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  if (p <= 0)\n    return 0;\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    x = Math.max(1e-3,\n                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t)\n      x = Math.pow(p / t, 1 / a);\n    else\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n  }\n\n  for(; j < 12; j++) {\n    if (x <= 0)\n      return 0;\n    err = jStat.lowRegGamma(a, x) - p;\n    if (a > 1)\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    else\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (Math.abs(t) < EPS * x)\n      break;\n  }\n\n  return x;\n};\n\n\n// Returns the error function erf(x)\njStat.erf = function erf(x) {\n  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,\n             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,\n             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,\n             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,\n             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,\n             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,\n             -6.886027e-12, 8.94487e-13, 3.13092e-13,\n             -1.12708e-13, 3.81e-16, 7.106e-15,\n             -1.523e-15, -9.4e-17, 1.21e-16,\n             -2.8e-17];\n  var j = cof.length - 1;\n  var isneg = false;\n  var d = 0;\n  var dd = 0;\n  var t, ty, tmp, res;\n\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n\n  for(; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n};\n\n\n// Returns the complmentary error function erfc(x)\njStat.erfc = function erfc(x) {\n  return 1 - jStat.erf(x);\n};\n\n\n// Returns the inverse of the complementary error function\njStat.erfcinv = function erfcinv(p) {\n  var j = 0;\n  var x, err, t, pp;\n  if (p >= 2)\n    return -100;\n  if (p <= 0)\n    return 100;\n  pp = (p < 1) ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) /\n                  (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = jStat.erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return (p < 1) ? x : -x;\n};\n\n\n// Returns the inverse of the incomplete beta function\njStat.ibetainv = function ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a >= 1 && b >= 1) {\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *\n        (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w)\n      x = Math.pow(a * w * p, 1 / a);\n    else\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);\n  for(; j < 10; j++) {\n    if (x === 0 || x === 1)\n      return x;\n    err = jStat.ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (x >= 1)\n      x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0)\n      break;\n  }\n  return x;\n};\n\n\n// Returns the incomplete beta function I_x(a,b)\njStat.ibeta = function ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = (x === 0 || x === 1) ?  0 :\n    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -\n             jStat.gammaln(b) + a * Math.log(x) + b *\n             Math.log(1 - x));\n  if (x < 0 || x > 1)\n    return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return bt * jStat.betacf(x, a, b) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * jStat.betacf(1 - x, b, a) / b;\n};\n\n\n// Returns a normal deviate (mu=0, sigma=1).\n// If n and m are specified it returns a object of normal deviates.\njStat.randn = function randn(n, m) {\n  var u, v, x, y, q;\n  if (!m)\n    m = n;\n  if (n)\n    return jStat.create(n, m, function() { return jStat.randn(); });\n  do {\n    u = jStat._random_fn();\n    v = 1.7156 * (jStat._random_fn() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n};\n\n\n// Returns a gamma deviate by the method of Marsaglia and Tsang.\njStat.randg = function randg(shape, n, m) {\n  var oalph = shape;\n  var a1, a2, u, v, x, mat;\n  if (!m)\n    m = n;\n  if (!shape)\n    shape = 1;\n  if (n) {\n    mat = jStat.zeros(n,m);\n    mat.alter(function() { return jStat.randg(shape); });\n    return mat;\n  }\n  if (shape < 1)\n    shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = jStat.randn();\n      v = 1 + a2 * x;\n    } while(v <= 0);\n    v = v * v * v;\n    u = jStat._random_fn();\n  } while(u > 1 - 0.331 * Math.pow(x, 4) &&\n          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));\n  // alpha > 1\n  if (shape == oalph)\n    return a1 * v;\n  // alpha < 1\n  do {\n    u = jStat._random_fn();\n  } while(u === 0);\n  return Math.pow(u, 1 / oalph) * a1 * v;\n};\n\n\n// making use of static methods on the instance\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(\n          jStat.map(this, function(value) { return jStat[passfunc](value); }));\n    }\n  })(funcs[i]);\n})('gammaln gammafn factorial factorialln'.split(' '));\n\n\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('randn'.split(' '));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\n// generate all distribution instance methods\n(function(list) {\n  for (var i = 0; i < list.length; i++) (function(func) {\n    // distribution instance method\n    jStat[func] = function f(a, b, c) {\n      if (!(this instanceof f))\n        return new f(a, b, c);\n      this._a = a;\n      this._b = b;\n      this._c = c;\n      return this;\n    };\n    // distribution method to be used on a jStat instance\n    jStat.fn[func] = function(a, b, c) {\n      var newthis = jStat[func](a, b, c);\n      newthis.data = this;\n      return newthis;\n    };\n    // sample instance method\n    jStat[func].prototype.sample = function(arr) {\n      var a = this._a;\n      var b = this._b;\n      var c = this._c;\n      if (arr)\n        return jStat.alter(arr, function() {\n          return jStat[func].sample(a, b, c);\n        });\n      else\n        return jStat[func].sample(a, b, c);\n    };\n    // generate the pdf, cdf and inv instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function(x) {\n          var a = this._a;\n          var b = this._b;\n          var c = this._c;\n          if (!x && x !== 0)\n            x = this.data;\n          if (typeof x !== 'number') {\n            return jStat.fn.map.call(x, function(x) {\n              return jStat[func][fnfunc](x, a, b, c);\n            });\n          }\n          return jStat[func][fnfunc](x, a, b, c);\n        };\n      })(vals[i]);\n    })('pdf cdf inv'.split(' '));\n    // generate the mean, median, mode and variance instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function() {\n          return jStat[func][fnfunc](this._a, this._b, this._c);\n        };\n      })(vals[i]);\n    })('mean median mode variance'.split(' '));\n  })(list[i]);\n})((\n  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +\n  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +\n  'binomial negbin hypgeom poisson triangular tukey arcsine'\n).split(' '));\n\n\n\n// extend beta function with static methods\njStat.extend(jStat.beta, {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0)\n      return 0;\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1)\n      return 1;\n\n    if (alpha < 512 && beta < 512) {\n      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /\n          jStat.betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) +\n                      (beta - 1) * Math.log(1 - x) -\n                      jStat.betaln(alpha, beta));\n    }\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);\n  },\n\n  inv: function inv(x, alpha, beta) {\n    return jStat.ibetainv(x, alpha, beta);\n  },\n\n  mean: function mean(alpha, beta) {\n    return alpha / (alpha + beta);\n  },\n\n  median: function median(alpha, beta) {\n    return jStat.ibetainv(0.5, alpha, beta);\n  },\n\n  mode: function mode(alpha, beta) {\n    return (alpha - 1 ) / ( alpha + beta - 2);\n  },\n\n  // return a random sample\n  sample: function sample(alpha, beta) {\n    var u = jStat.randg(alpha);\n    return u / (u + jStat.randg(beta));\n  },\n\n  variance: function variance(alpha, beta) {\n    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));\n  }\n});\n\n// extend F function with static methods\njStat.extend(jStat.centralF, {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n\n    if (x < 0)\n      return 0;\n\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *\n              Math.pow(df1 / df2, df1 / 2) *\n              Math.pow(x, (df1/2) - 1) *\n              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);\n    }\n\n    p = (df1 * x) / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0)\n      return 0;\n    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));\n  },\n\n  mean: function mean(df1, df2) {\n    return (df2 > 2) ? df2 / (df2 - 2) : undefined;\n  },\n\n  mode: function mode(df1, df2) {\n    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;\n  },\n\n  // return a random sample\n  sample: function sample(df1, df2) {\n    var x1 = jStat.randg(df1 / 2) * 2;\n    var x2 = jStat.randg(df2 / 2) * 2;\n    return (x1 / df1) / (x2 / df2);\n  },\n\n  variance: function variance(df1, df2) {\n    if (df2 <= 4)\n      return undefined;\n    return 2 * df2 * df2 * (df1 + df2 - 2) /\n        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));\n  }\n});\n\n\n// extend cauchy function with static methods\njStat.extend(jStat.cauchy, {\n  pdf: function pdf(x, local, scale) {\n    if (scale < 0) { return 0; }\n\n    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;\n  },\n\n  cdf: function cdf(x, local, scale) {\n    return Math.atan((x - local) / scale) / Math.PI + 0.5;\n  },\n\n  inv: function(p, local, scale) {\n    return local + scale * Math.tan(Math.PI * (p - 0.5));\n  },\n\n  median: function median(local/*, scale*/) {\n    return local;\n  },\n\n  mode: function mode(local/*, scale*/) {\n    return local;\n  },\n\n  sample: function sample(local, scale) {\n    return jStat.randn() *\n        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;\n  }\n});\n\n\n\n// extend chisquare function with static methods\njStat.extend(jStat.chisquare, {\n  pdf: function pdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && dof === 2) ? 0.5 :\n        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *\n                 Math.log(2) - jStat.gammaln(dof / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(dof / 2, x / 2);\n  },\n\n  inv: function(p, dof) {\n    return 2 * jStat.gammapinv(p, 0.5 * dof);\n  },\n\n  mean : function(dof) {\n    return dof;\n  },\n\n  // TODO: this is an approximation (is there a better way?)\n  median: function median(dof) {\n    return dof * Math.pow(1 - (2 / (9 * dof)), 3);\n  },\n\n  mode: function mode(dof) {\n    return (dof - 2 > 0) ? dof - 2 : 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randg(dof / 2) * 2;\n  },\n\n  variance: function variance(dof) {\n    return 2 * dof;\n  }\n});\n\n\n\n// extend exponential function with static methods\njStat.extend(jStat.exponential, {\n  pdf: function pdf(x, rate) {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n\n  cdf: function cdf(x, rate) {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  },\n\n  inv: function(p, rate) {\n    return -Math.log(1 - p) / rate;\n  },\n\n  mean : function(rate) {\n    return 1 / rate;\n  },\n\n  median: function (rate) {\n    return (1 / rate) * Math.log(2);\n  },\n\n  mode: function mode(/*rate*/) {\n    return 0;\n  },\n\n  sample: function sample(rate) {\n    return -1 / rate * Math.log(jStat._random_fn());\n  },\n\n  variance : function(rate) {\n    return Math.pow(rate, -2);\n  }\n});\n\n\n\n// extend gamma function with static methods\njStat.extend(jStat.gamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && shape === 1) ? 1 / scale :\n            Math.exp((shape - 1) * Math.log(x) - x / scale -\n                    jStat.gammaln(shape) - shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(shape, x / scale);\n  },\n\n  inv: function(p, shape, scale) {\n    return jStat.gammapinv(p, shape) * scale;\n  },\n\n  mean : function(shape, scale) {\n    return shape * scale;\n  },\n\n  mode: function mode(shape, scale) {\n    if(shape > 1) return (shape - 1) * scale;\n    return undefined;\n  },\n\n  sample: function sample(shape, scale) {\n    return jStat.randg(shape) * scale;\n  },\n\n  variance: function variance(shape, scale) {\n    return shape * scale * scale;\n  }\n});\n\n// extend inverse gamma function with static methods\njStat.extend(jStat.invgamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -\n                    jStat.gammaln(shape) + shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return 1 - jStat.lowRegGamma(shape, scale / x);\n  },\n\n  inv: function(p, shape, scale) {\n    return scale / jStat.gammapinv(1 - p, shape);\n  },\n\n  mean : function(shape, scale) {\n    return (shape > 1) ? scale / (shape - 1) : undefined;\n  },\n\n  mode: function mode(shape, scale) {\n    return scale / (shape + 1);\n  },\n\n  sample: function sample(shape, scale) {\n    return scale / jStat.randg(shape);\n  },\n\n  variance: function variance(shape, scale) {\n    if (shape <= 2)\n      return undefined;\n    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));\n  }\n});\n\n\n// extend kumaraswamy function with static methods\njStat.extend(jStat.kumaraswamy, {\n  pdf: function pdf(x, alpha, beta) {\n    if (x === 0 && alpha === 1)\n      return beta;\n    else if (x === 1 && beta === 1)\n      return alpha;\n    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *\n                    Math.log(x) + (beta - 1) *\n                    Math.log(1 - Math.pow(x, alpha)));\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    if (x < 0)\n      return 0;\n    else if (x > 1)\n      return 1;\n    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));\n  },\n\n  inv: function inv(p, alpha, beta) {\n    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);\n  },\n\n  mean : function(alpha, beta) {\n    return (beta * jStat.gammafn(1 + 1 / alpha) *\n            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));\n  },\n\n  median: function median(alpha, beta) {\n    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);\n  },\n\n  mode: function mode(alpha, beta) {\n    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))\n      return undefined;\n    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);\n  },\n\n  variance: function variance(/*alpha, beta*/) {\n    throw new Error('variance not yet implemented');\n    // TODO: complete this\n  }\n});\n\n\n\n// extend lognormal function with static methods\njStat.extend(jStat.lognormal, {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -\n                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /\n                    (2 * sigma * sigma));\n  },\n\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0)\n      return 0;\n    return 0.5 +\n        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));\n  },\n\n  inv: function(p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);\n  },\n\n  mean: function mean(mu, sigma) {\n    return Math.exp(mu + sigma * sigma / 2);\n  },\n\n  median: function median(mu/*, sigma*/) {\n    return Math.exp(mu);\n  },\n\n  mode: function mode(mu, sigma) {\n    return Math.exp(mu - sigma * sigma);\n  },\n\n  sample: function sample(mu, sigma) {\n    return Math.exp(jStat.randn() * sigma + mu);\n  },\n\n  variance: function variance(mu, sigma) {\n    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);\n  }\n});\n\n\n\n// extend noncentralt function with static methods\njStat.extend(jStat.noncentralt, {\n  pdf: function pdf(x, dof, ncp) {\n    var tol = 1e-14;\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.pdf(x, dof)\n\n    if (Math.abs(x) < tol) {  // different formula for x == 0\n      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -\n                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));\n    }\n\n    // formula for x != 0\n    return dof / x *\n        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -\n         jStat.noncentralt.cdf(x, dof, ncp));\n  },\n\n  cdf: function cdf(x, dof, ncp) {\n    var tol = 1e-14;\n    var min_iterations = 200;\n\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.cdf(x, dof);\n\n    // turn negative x into positive and flip result afterwards\n    var flip = false;\n    if (x < 0) {\n      flip = true;\n      ncp = -ncp;\n    }\n\n    var prob = jStat.normal.cdf(-ncp, 0, 1);\n    var value = tol + 1;\n    // use value at last two steps to determine convergence\n    var lastvalue = value;\n    var y = x * x / (x * x + dof);\n    var j = 0;\n    var p = Math.exp(-ncp * ncp / 2);\n    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -\n                     jStat.gammaln(3 / 2)) * ncp;\n    while (j < min_iterations || lastvalue > tol || value > tol) {\n      lastvalue = value;\n      if (j > 0) {\n        p *= (ncp * ncp) / (2 * j);\n        q *= (ncp * ncp) / (2 * (j + 1 / 2));\n      }\n      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +\n          q * jStat.beta.cdf(y, j+1, dof/2);\n      prob += 0.5 * value;\n      j++;\n    }\n\n    return flip ? (1 - prob) : prob;\n  }\n});\n\n\n// extend normal function with static methods\njStat.extend(jStat.normal, {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) -\n                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n\n  inv: function(p, mean, std) {\n    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;\n  },\n\n  mean : function(mean/*, std*/) {\n    return mean;\n  },\n\n  median: function median(mean/*, std*/) {\n    return mean;\n  },\n\n  mode: function (mean/*, std*/) {\n    return mean;\n  },\n\n  sample: function sample(mean, std) {\n    return jStat.randn() * std + mean;\n  },\n\n  variance : function(mean, std) {\n    return std * std;\n  }\n});\n\n\n\n// extend pareto function with static methods\njStat.extend(jStat.pareto, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return 1 - Math.pow(scale / x, shape);\n  },\n\n  inv: function inv(p, scale, shape) {\n    return scale / Math.pow(1 - p, 1 / shape);\n  },\n\n  mean: function mean(scale, shape) {\n    if (shape <= 1)\n      return undefined;\n    return (shape * Math.pow(scale, shape)) / (shape - 1);\n  },\n\n  median: function median(scale, shape) {\n    return scale * (shape * Math.SQRT2);\n  },\n\n  mode: function mode(scale/*, shape*/) {\n    return scale;\n  },\n\n  variance : function(scale, shape) {\n    if (shape <= 2)\n      return undefined;\n    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));\n  }\n});\n\n\n\n// extend studentt function with static methods\njStat.extend(jStat.studentt, {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *\n        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /\n                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n\n  inv: function(p, dof) {\n    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return (p > 0.5) ? x : -x;\n  },\n\n  mean: function mean(dof) {\n    return (dof > 1) ? 0 : undefined;\n  },\n\n  median: function median(/*dof*/) {\n    return 0;\n  },\n\n  mode: function mode(/*dof*/) {\n    return 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));\n  },\n\n  variance: function variance(dof) {\n    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;\n  }\n});\n\n\n\n// extend weibull function with static methods\njStat.extend(jStat.weibull, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0)\n      return 0;\n    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *\n        Math.exp(-(Math.pow((x / scale), shape)));\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));\n  },\n\n  inv: function(p, scale, shape) {\n    return scale * Math.pow(-Math.log(1 - p), 1 / shape);\n  },\n\n  mean : function(scale, shape) {\n    return scale * jStat.gammafn(1 + 1 / shape);\n  },\n\n  median: function median(scale, shape) {\n    return scale * Math.pow(Math.log(2), 1 / shape);\n  },\n\n  mode: function mode(scale, shape) {\n    if (shape <= 1)\n      return 0;\n    return scale * Math.pow((shape - 1) / shape, 1 / shape);\n  },\n\n  sample: function sample(scale, shape) {\n    return scale * Math.pow(-Math.log(jStat._random_fn()), 1 / shape);\n  },\n\n  variance: function variance(scale, shape) {\n    return scale * scale * jStat.gammafn(1 + 2 / shape) -\n        Math.pow(jStat.weibull.mean(scale, shape), 2);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.uniform, {\n  pdf: function pdf(x, a, b) {\n    return (x < a || x > b) ? 0 : 1 / (b - a);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (x - a) / (b - a);\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (p * (b - a));\n  },\n\n  mean: function mean(a, b) {\n    return 0.5 * (a + b);\n  },\n\n  median: function median(a, b) {\n    return jStat.mean(a, b);\n  },\n\n  mode: function mode(/*a, b*/) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * jStat._random_fn() - 1);\n  },\n\n  variance: function variance(a, b) {\n    return Math.pow(b - a, 2) / 12;\n  }\n});\n\n\n// Got this from http://www.math.ucla.edu/~tom/distributions/binomial.html\nfunction betinc(x, a, b, eps) {\n  var a0 = 0;\n  var b0 = 1;\n  var a1 = 1;\n  var b1 = 1;\n  var m9 = 0;\n  var a2 = 0;\n  var c9;\n\n  while (Math.abs((a1 - a2) / a1) > eps) {\n    a2 = a1;\n    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);\n    a0 = a1 + c9 * a0;\n    b0 = b1 + c9 * b0;\n    m9 = m9 + 1;\n    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);\n    a1 = a0 + c9 * a1;\n    b1 = b0 + c9 * b1;\n    a0 = a0 / b1;\n    b0 = b0 / b1;\n    a1 = a1 / b1;\n    b1 = 1;\n  }\n\n  return a1 / a;\n}\n\n\n// extend uniform function with static methods\njStat.extend(jStat.binomial, {\n  pdf: function pdf(k, n, p) {\n    return (p === 0 || p === 1) ?\n      ((n * p) === k ? 1 : 0) :\n      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n\n  cdf: function cdf(x, n, p) {\n    var betacdf;\n    var eps = 1e-10;\n\n    if (x < 0)\n      return 0;\n    if (x >= n)\n      return 1;\n    if (p < 0 || p > 1 || n <= 0)\n      return NaN;\n\n    x = Math.floor(x);\n    var z = p;\n    var a = x + 1;\n    var b = n - x;\n    var s = a + b;\n    var bt = Math.exp(jStat.gammaln(s) - jStat.gammaln(b) -\n                      jStat.gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));\n\n    if (z < (a + 1) / (s + 2))\n      betacdf = bt * betinc(z, a, b, eps);\n    else\n      betacdf = 1 - bt * betinc(1 - z, b, a, eps);\n\n    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.negbin, {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0)\n      return false;\n    if (k < 0)\n      return 0;\n    return jStat.combination(k + r - 1, r - 1) *\n        Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sum += jStat.negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.hypgeom, {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n\n    // A simplification of the CDF algorithm below.\n\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(k !== k | 0) {\n      return false;\n    } else if(k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if(k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return jStat.hypgeom.pdf(n - k, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return jStat.hypgeom.pdf(m - k, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          scaledPDF *= 1 - (m / (N - samplesDone));\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if(x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          var factor = 1 - (m / (N - samplesDone));\n\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.poisson, {\n  pdf: function pdf(k, l) {\n    if (l < 0 || (k % 1) !== 0 || k < 0) {\n      return 0;\n    }\n\n    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);\n  },\n\n  cdf: function cdf(x, l) {\n    var sumarr = [],\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sumarr.push(jStat.poisson.pdf(k, l));\n    }\n    return jStat.sum(sumarr);\n  },\n\n  mean : function(l) {\n    return l;\n  },\n\n  variance : function(l) {\n    return l;\n  },\n\n  sampleSmall: function sampleSmall(l) {\n    var p = 1, k = 0, L = Math.exp(-l);\n    do {\n      k++;\n      p *= jStat._random_fn();\n    } while (p > L);\n    return k - 1;\n  },\n\n  sampleLarge: function sampleLarge(l) {\n    var lam = l;\n    var k;\n    var U, V, slam, loglam, a, b, invalpha, vr, us;\n\n    slam = Math.sqrt(lam);\n    loglam = Math.log(lam);\n    b = 0.931 + 2.53 * slam;\n    a = -0.059 + 0.02483 * b;\n    invalpha = 1.1239 + 1.1328 / (b - 3.4);\n    vr = 0.9277 - 3.6224 / (b - 2);\n\n    while (1) {\n      U = Math.random() - 0.5;\n      V = Math.random();\n      us = 0.5 - Math.abs(U);\n      k = Math.floor((2 * a / us + b) * U + lam + 0.43);\n      if ((us >= 0.07) && (V <= vr)) {\n          return k;\n      }\n      if ((k < 0) || ((us < 0.013) && (V > us))) {\n          continue;\n      }\n      /* log(V) == log(0.0) ok here */\n      /* if U==0.0 so that us==0.0, log is ok since always returns */\n      if ((Math.log(V) + Math.log(invalpha) - Math.log(a / (us * us) + b)) <= (-lam + k * loglam - jStat.loggam(k + 1))) {\n          return k;\n      }\n    }\n  },\n\n  sample: function sample(l) {\n    if (l < 10)\n      return this.sampleSmall(l);\n    else\n      return this.sampleLarge(l);\n  }\n});\n\n// extend triangular function with static methods\njStat.extend(jStat.triangular, {\n  pdf: function pdf(x, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (x < a || x > b) {\n        return 0;\n      } else if (x < c) {\n          return (2 * (x - a)) / ((b - a) * (c - a));\n      } else if (x === c) {\n          return (2 / (b - a));\n      } else { // x > c\n          return (2 * (b - x)) / ((b - a) * (b - c));\n      }\n    }\n  },\n\n  cdf: function cdf(x, a, b, c) {\n    if (b <= a || c < a || c > b)\n      return NaN;\n    if (x <= a)\n      return 0;\n    else if (x >= b)\n      return 1;\n    if (x <= c)\n      return Math.pow(x - a, 2) / ((b - a) * (c - a));\n    else // x > c\n      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));\n  },\n\n  inv: function inv(p, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (p <= ((c - a) / (b - a))) {\n        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));\n      } else { // p > ((c - a) / (b - a))\n        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));\n      }\n    }\n  },\n\n  mean: function mean(a, b, c) {\n    return (a + b + c) / 3;\n  },\n\n  median: function median(a, b, c) {\n    if (c <= (a + b) / 2) {\n      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);\n    } else if (c > (a + b) / 2) {\n      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);\n    }\n  },\n\n  mode: function mode(a, b, c) {\n    return c;\n  },\n\n  sample: function sample(a, b, c) {\n    var u = jStat._random_fn();\n    if (u < ((c - a) / (b - a)))\n      return a + Math.sqrt(u * (b - a) * (c - a))\n    return b - Math.sqrt((1 - u) * (b - a) * (b - c));\n  },\n\n  variance: function variance(a, b, c) {\n    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n  }\n});\n\n\n// extend arcsine function with static methods\njStat.extend(jStat.arcsine, {\n  pdf: function pdf(x, a, b) {\n    if (b <= a) return NaN;\n\n    return (x <= a || x >= b) ? 0 :\n      (2 / Math.PI) *\n        Math.pow(Math.pow(b - a, 2) -\n                  Math.pow(2 * x - a - b, 2), -0.5);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);\n  },\n\n  mean: function mean(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  median: function median(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  mode: function mode(/*a, b*/) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return ((a + b) / 2) + ((b - a) / 2) *\n      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));\n  },\n\n  variance: function variance(a, b) {\n    if (b <= a) return NaN;\n    return Math.pow(b - a, 2) / 8;\n  }\n});\n\n\nfunction laplaceSign(x) { return x / Math.abs(x); }\n\njStat.extend(jStat.laplace, {\n  pdf: function pdf(x, mu, b) {\n    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);\n  },\n\n  cdf: function cdf(x, mu, b) {\n    if (b <= 0) { return 0; }\n\n    if(x < mu) {\n      return 0.5 * Math.exp((x - mu) / b);\n    } else {\n      return 1 - 0.5 * Math.exp(- (x - mu) / b);\n    }\n  },\n\n  mean: function(mu/*, b*/) {\n    return mu;\n  },\n\n  median: function(mu/*, b*/) {\n    return mu;\n  },\n\n  mode: function(mu/*, b*/) {\n    return mu;\n  },\n\n  variance: function(mu, b) {\n    return 2 * b * b;\n  },\n\n  sample: function sample(mu, b) {\n    var u = jStat._random_fn() - 0.5;\n\n    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));\n  }\n});\n\nfunction tukeyWprob(w, rr, cc) {\n  var nleg = 12;\n  var ihalf = 6;\n\n  var C1 = -30;\n  var C2 = -50;\n  var C3 = 60;\n  var bb   = 8;\n  var wlar = 3;\n  var wincr1 = 2;\n  var wincr2 = 3;\n  var xleg = [\n    0.981560634246719250690549090149,\n    0.904117256370474856678465866119,\n    0.769902674194304687036893833213,\n    0.587317954286617447296702418941,\n    0.367831498998180193752691536644,\n    0.125233408511468915472441369464\n  ];\n  var aleg = [\n    0.047175336386511827194615961485,\n    0.106939325995318430960254718194,\n    0.160078328543346226334652529543,\n    0.203167426723065921749064455810,\n    0.233492536538354808760849898925,\n    0.249147045813402785000562436043\n  ];\n\n  var qsqz = w * 0.5;\n\n  // if w >= 16 then the integral lower bound (occurs for c=20)\n  // is 0.99999999999995 so return a value of 1.\n\n  if (qsqz >= bb)\n    return 1.0;\n\n  // find (f(w/2) - 1) ^ cc\n  // (first term in integral of hartley's form).\n\n  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)\n  // if pr_w ^ cc < 2e-22 then set pr_w = 0\n  if (pr_w >= Math.exp(C2 / cc))\n    pr_w = Math.pow(pr_w, cc);\n  else\n    pr_w = 0.0;\n\n  // if w is large then the second component of the\n  // integral is small, so fewer intervals are needed.\n\n  var wincr;\n  if (w > wlar)\n    wincr = wincr1;\n  else\n    wincr = wincr2;\n\n  // find the integral of second term of hartley's form\n  // for the integral of the range for equal-length\n  // intervals using legendre quadrature.  limits of\n  // integration are from (w/2, 8).  two or three\n  // equal-length intervals are used.\n\n  // blb and bub are lower and upper limits of integration.\n\n  var blb = qsqz;\n  var binc = (bb - qsqz) / wincr;\n  var bub = blb + binc;\n  var einsum = 0.0;\n\n  // integrate over each interval\n\n  var cc1 = cc - 1.0;\n  for (var wi = 1; wi <= wincr; wi++) {\n    var elsum = 0.0;\n    var a = 0.5 * (bub + blb);\n\n    // legendre quadrature with order = nleg\n\n    var b = 0.5 * (bub - blb);\n\n    for (var jj = 1; jj <= nleg; jj++) {\n      var j, xx;\n      if (ihalf < jj) {\n        j = (nleg - jj) + 1;\n        xx = xleg[j-1];\n      } else {\n        j = jj;\n        xx = -xleg[j-1];\n      }\n      var c = b * xx;\n      var ac = a + c;\n\n      // if exp(-qexpo/2) < 9e-14,\n      // then doesn't contribute to integral\n\n      var qexpo = ac * ac;\n      if (qexpo > C3)\n        break;\n\n      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);\n      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);\n\n      // if rinsum ^ (cc-1) < 9e-14,\n      // then doesn't contribute to integral\n\n      var rinsum = (pplus * 0.5) - (pminus * 0.5);\n      if (rinsum >= Math.exp(C1 / cc1)) {\n        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);\n        elsum += rinsum;\n      }\n    }\n    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));\n    einsum += elsum;\n    blb = bub;\n    bub += binc;\n  }\n\n  // if pr_w ^ rr < 9e-14, then return 0\n  pr_w += einsum;\n  if (pr_w <= Math.exp(C1 / rr))\n    return 0;\n\n  pr_w = Math.pow(pr_w, rr);\n  if (pr_w >= 1) // 1 was iMax was eps\n    return 1;\n  return pr_w;\n}\n\nfunction tukeyQinv(p, c, v) {\n  var p0 = 0.322232421088;\n  var q0 = 0.993484626060e-01;\n  var p1 = -1.0;\n  var q1 = 0.588581570495;\n  var p2 = -0.342242088547;\n  var q2 = 0.531103462366;\n  var p3 = -0.204231210125;\n  var q3 = 0.103537752850;\n  var p4 = -0.453642210148e-04;\n  var q4 = 0.38560700634e-02;\n  var c1 = 0.8832;\n  var c2 = 0.2368;\n  var c3 = 1.214;\n  var c4 = 1.208;\n  var c5 = 1.4142;\n  var vmax = 120.0;\n\n  var ps = 0.5 - 0.5 * p;\n  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));\n  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)\n     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);\n  if (v < vmax) t += (t * t * t + t) / v / 4.0;\n  var q = c1 - c2 * t;\n  if (v < vmax) q += -c3 / v + c4 * t / v;\n  return t * (q * Math.log(c - 1.0) + c5);\n}\n\njStat.extend(jStat.tukey, {\n  cdf: function cdf(q, nmeans, df) {\n    // Identical implementation as the R ptukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var nlegq = 16;\n    var ihalfq = 8;\n\n    var eps1 = -30.0;\n    var eps2 = 1.0e-14;\n    var dhaf  = 100.0;\n    var dquar = 800.0;\n    var deigh = 5000.0;\n    var dlarg = 25000.0;\n    var ulen1 = 1.0;\n    var ulen2 = 0.5;\n    var ulen3 = 0.25;\n    var ulen4 = 0.125;\n    var xlegq = [\n      0.989400934991649932596154173450,\n      0.944575023073232576077988415535,\n      0.865631202387831743880467897712,\n      0.755404408355003033895101194847,\n      0.617876244402643748446671764049,\n      0.458016777657227386342419442984,\n      0.281603550779258913230460501460,\n      0.950125098376374401853193354250e-1\n    ];\n    var alegq = [\n      0.271524594117540948517805724560e-1,\n      0.622535239386478928628438369944e-1,\n      0.951585116824927848099251076022e-1,\n      0.124628971255533872052476282192,\n      0.149595988816576732081501730547,\n      0.169156519395002538189312079030,\n      0.182603415044923588866763667969,\n      0.189450610455068496285396723208\n    ];\n\n    if (q <= 0)\n      return 0;\n\n    // df must be > 1\n    // there must be at least two values\n\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (!Number.isFinite(q))\n      return 1;\n\n    if (df > dlarg)\n      return tukeyWprob(q, rr, cc);\n\n    // calculate leading constant\n\n    var f2 = df * 0.5;\n    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);\n    var f21 = f2 - 1.0;\n\n    // integral is divided into unit, half-unit, quarter-unit, or\n    // eighth-unit length intervals depending on the value of the\n    // degrees of freedom.\n\n    var ff4 = df * 0.25;\n    var ulen;\n    if      (df <= dhaf)  ulen = ulen1;\n    else if (df <= dquar) ulen = ulen2;\n    else if (df <= deigh) ulen = ulen3;\n    else                  ulen = ulen4;\n\n    f2lf += Math.log(ulen);\n\n    // integrate over each subinterval\n\n    var ans = 0.0;\n\n    for (var i = 1; i <= 50; i++) {\n      var otsum = 0.0;\n\n      // legendre quadrature with order = nlegq\n      // nodes (stored in xlegq) are symmetric around zero.\n\n      var twa1 = (2 * i - 1) * ulen;\n\n      for (var jj = 1; jj <= nlegq; jj++) {\n        var j, t1;\n        if (ihalfq < jj) {\n          j = jj - ihalfq - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))\n              - (((xlegq[j] * ulen) + twa1) * ff4);\n        } else {\n          j = jj - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))\n              + (((xlegq[j] * ulen) - twa1) * ff4);\n        }\n\n        // if exp(t1) < 9e-14, then doesn't contribute to integral\n        var qsqz;\n        if (t1 >= eps1) {\n          if (ihalfq < jj) {\n            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);\n          } else {\n            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);\n          }\n\n          // call wprob to find integral of range portion\n\n          var wprb = tukeyWprob(qsqz, rr, cc);\n          var rotsum = (wprb * alegq[j]) * Math.exp(t1);\n          otsum += rotsum;\n        }\n        // end legendre integral for interval i\n        // L200:\n      }\n\n      // if integral for interval i < 1e-14, then stop.\n      // However, in order to avoid small area under left tail,\n      // at least  1 / ulen  intervals are calculated.\n      if (i * ulen >= 1.0 && otsum <= eps2)\n        break;\n\n      // end of interval i\n      // L330:\n\n      ans += otsum;\n    }\n\n    if (otsum > eps2) { // not converged\n      throw new Error('tukey.cdf failed to converge');\n    }\n    if (ans > 1)\n      ans = 1;\n    return ans;\n  },\n\n  inv: function(p, nmeans, df) {\n    // Identical implementation as the R qtukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var eps = 0.0001;\n    var maxiter = 50;\n\n    // df must be > 1 ; there must be at least two values\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (p < 0 || p > 1) return NaN;\n    if (p === 0) return 0;\n    if (p === 1) return Infinity;\n\n    // Initial value\n\n    var x0 = tukeyQinv(p, cc, df);\n\n    // Find prob(value < x0)\n\n    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;\n\n    // Find the second iterate and prob(value < x1).\n    // If the first iterate has probability value\n    // exceeding p then second iterate is 1 less than\n    // first iterate; otherwise it is 1 greater.\n\n    var x1;\n    if (valx0 > 0.0)\n      x1 = Math.max(0.0, x0 - 1.0);\n    else\n      x1 = x0 + 1.0;\n    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;\n\n    // Find new iterate\n\n    var ans;\n    for(var iter = 1; iter < maxiter; iter++) {\n      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));\n      valx0 = valx1;\n\n      // New iterate must be >= 0\n\n      x0 = x1;\n      if (ans < 0.0) {\n        ans = 0.0;\n        valx1 = -p;\n      }\n      // Find prob(value < new iterate)\n\n      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;\n      x1 = ans;\n\n      // If the difference between two successive\n      // iterates is less than eps, stop\n\n      var xabs = Math.abs(x1 - x0);\n      if (xabs < eps)\n        return ans;\n    }\n\n    throw new Error('tukey.inv failed to converge');\n  }\n});\n\n}(jStat, Math));\n/* Provides functions for the solution of linear system of equations, integration, extrapolation,\n * interpolation, eigenvalue problems, differential equations and PCA analysis. */\n\n(function(jStat, Math) {\n\nvar push = Array.prototype.push;\nvar isArray = jStat.utils.isArray;\n\nfunction isUsable(arg) {\n  return isArray(arg) || arg instanceof jStat;\n}\n\njStat.extend({\n\n  // add a vector/matrix to a vector/matrix or scalar\n  add: function add(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value + arg[row][col];\n      });\n    }\n    return jStat.map(arr, function(value) { return value + arg; });\n  },\n\n  // subtract a vector or scalar from the vector\n  subtract: function subtract(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value - arg[row][col] || 0;\n      });\n    }\n    return jStat.map(arr, function(value) { return value - arg; });\n  },\n\n  // matrix division\n  divide: function divide(arr, arg) {\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.multiply(arr, jStat.inv(arg));\n    }\n    return jStat.map(arr, function(value) { return value / arg; });\n  },\n\n  // matrix multiplication\n  multiply: function multiply(arr, arg) {\n    var row, col, nrescols, sum, nrow, ncol, res, rescols;\n    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure\n    if (arr.length === undefined && arg.length === undefined) {\n      return arr * arg;\n    }\n    nrow = arr.length,\n    ncol = arr[0].length,\n    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),\n    rescols = 0;\n    if (isUsable(arg)) {\n      for (; rescols < nrescols; rescols++) {\n        for (row = 0; row < nrow; row++) {\n          sum = 0;\n          for (col = 0; col < ncol; col++)\n          sum += arr[row][col] * arg[col][rescols];\n          res[row][rescols] = sum;\n        }\n      }\n      return (nrow === 1 && rescols === 1) ? res[0][0] : res;\n    }\n    return jStat.map(arr, function(value) { return value * arg; });\n  },\n\n  // outer([1,2,3],[4,5,6])\n  // ===\n  // [[1],[2],[3]] times [[4,5,6]]\n  // ->\n  // [[4,5,6],[8,10,12],[12,15,18]]\n  outer:function outer(A, B) {\n    return jStat.multiply(A.map(function(t){ return [t] }), [B]);\n  },\n\n\n  // Returns the dot product of two matricies\n  dot: function dot(arr, arg) {\n    if (!isUsable(arr[0])) arr = [ arr ];\n    if (!isUsable(arg[0])) arg = [ arg ];\n    // convert column to row vector\n    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,\n    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,\n    res = [],\n    row = 0,\n    nrow = left.length,\n    ncol = left[0].length,\n    sum, col;\n    for (; row < nrow; row++) {\n      res[row] = [];\n      sum = 0;\n      for (col = 0; col < ncol; col++)\n      sum += left[row][col] * right[row][col];\n      res[row] = sum;\n    }\n    return (res.length === 1) ? res[0] : res;\n  },\n\n  // raise every element by a scalar\n  pow: function pow(arr, arg) {\n    return jStat.map(arr, function(value) { return Math.pow(value, arg); });\n  },\n\n  // exponentiate every element\n  exp: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.exp(value); });\n  },\n\n  // generate the natural log of every element\n  log: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.log(value); });\n  },\n\n  // generate the absolute values of the vector\n  abs: function abs(arr) {\n    return jStat.map(arr, function(value) { return Math.abs(value); });\n  },\n\n  // computes the p-norm of the vector\n  // In the case that a matrix is passed, uses the first row as the vector\n  norm: function norm(arr, p) {\n    var nnorm = 0,\n    i = 0;\n    // check the p-value of the norm, and set for most common case\n    if (isNaN(p)) p = 2;\n    // check if multi-dimensional array, and make vector correction\n    if (isUsable(arr[0])) arr = arr[0];\n    // vector norm\n    for (; i < arr.length; i++) {\n      nnorm += Math.pow(Math.abs(arr[i]), p);\n    }\n    return Math.pow(nnorm, 1 / p);\n  },\n\n  // computes the angle between two vectors in rads\n  // In case a matrix is passed, this uses the first row as the vector\n  angle: function angle(arr, arg) {\n    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));\n  },\n\n  // augment one matrix by another\n  // Note: this function returns a matrix, not a jStat object\n  aug: function aug(a, b) {\n    var newarr = [];\n    var i;\n    for (i = 0; i < a.length; i++) {\n      newarr.push(a[i].slice());\n    }\n    for (i = 0; i < newarr.length; i++) {\n      push.apply(newarr[i], b[i]);\n    }\n    return newarr;\n  },\n\n  // The inv() function calculates the inverse of a matrix\n  // Create the inverse by augmenting the matrix by the identity matrix of the\n  // appropriate size, and then use G-J elimination on the augmented matrix.\n  inv: function inv(a) {\n    var rows = a.length;\n    var cols = a[0].length;\n    var b = jStat.identity(rows, cols);\n    var c = jStat.gauss_jordan(a, b);\n    var result = [];\n    var i = 0;\n    var j;\n\n    //We need to copy the inverse portion to a new matrix to rid G-J artifacts\n    for (; i < rows; i++) {\n      result[i] = [];\n      for (j = cols; j < c[0].length; j++)\n        result[i][j - cols] = c[i][j];\n    }\n    return result;\n  },\n\n  // calculate the determinant of a matrix\n  det: function det(a) {\n    if (a.length === 2) {\n      return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    }\n\n    var determinant = 0;\n    for (var i = 0; i < a.length; i++) {\n      // build a sub matrix without column `i`\n      var submatrix = [];\n      for (var row = 1; row < a.length; row++) {\n        submatrix[row - 1] = [];\n        for (var col = 0; col < a.length; col++) {\n          if (col < i) {\n            submatrix[row - 1][col] = a[row][col];\n          } else if (col > i) {\n            submatrix[row - 1][col - 1] = a[row][col];\n          }\n        }\n      }\n\n      // alternate between + and - between determinants\n      var sign = i % 2 ? -1 : 1;\n      determinant += det(submatrix) * a[0][i] * sign;\n    }\n\n    return determinant\n  },\n\n  gauss_elimination: function gauss_elimination(a, b) {\n    var i = 0,\n    j = 0,\n    n = a.length,\n    m = a[0].length,\n    factor = 1,\n    sum = 0,\n    x = [],\n    maug, pivot, temp, k;\n    a = jStat.aug(a, b);\n    maug = a[0].length;\n    for(i = 0; i < n; i++) {\n      pivot = a[i][i];\n      j = i;\n      for (k = i + 1; k < m; k++) {\n        if (pivot < Math.abs(a[k][i])) {\n          pivot = a[k][i];\n          j = k;\n        }\n      }\n      if (j != i) {\n        for(k = 0; k < maug; k++) {\n          temp = a[i][k];\n          a[i][k] = a[j][k];\n          a[j][k] = temp;\n        }\n      }\n      for (j = i + 1; j < n; j++) {\n        factor = a[j][i] / a[i][i];\n        for(k = i; k < maug; k++) {\n          a[j][k] = a[j][k] - factor * a[i][k];\n        }\n      }\n    }\n    for (i = n - 1; i >= 0; i--) {\n      sum = 0;\n      for (j = i + 1; j<= n - 1; j++) {\n        sum = sum + x[j] * a[i][j];\n      }\n      x[i] =(a[i][maug - 1] - sum) / a[i][i];\n    }\n    return x;\n  },\n\n  gauss_jordan: function gauss_jordan(a, b) {\n    var m = jStat.aug(a, b);\n    var h = m.length;\n    var w = m[0].length;\n    var c = 0;\n    var x, y, y2;\n    // find max pivot\n    for (y = 0; y < h; y++) {\n      var maxrow = y;\n      for (y2 = y+1; y2 < h; y2++) {\n        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n          maxrow = y2;\n      }\n      var tmp = m[y];\n      m[y] = m[maxrow];\n      m[maxrow] = tmp\n      for (y2 = y+1; y2 < h; y2++) {\n        c = m[y2][y] / m[y][y];\n        for (x = y; x < w; x++) {\n          m[y2][x] -= m[y][x] * c;\n        }\n      }\n    }\n    // backsubstitute\n    for (y = h-1; y >= 0; y--) {\n      c = m[y][y];\n      for (y2 = 0; y2 < y; y2++) {\n        for (x = w-1; x > y-1; x--) {\n          m[y2][x] -= m[y][x] * m[y2][y] / c;\n        }\n      }\n      m[y][y] /= c;\n      for (x = h; x < w; x++) {\n        m[y][x] /= c;\n      }\n    }\n    return m;\n  },\n\n  // solve equation\n  // Ax=b\n  // A is upper triangular matrix\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[1,2,3]\n  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]\n  // if you use matrix style\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[[1],[2],[3]]\n  // will return [[2.666],[0.1666],[1.666]]\n  triaUpSolve: function triaUpSolve(A, b) {\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n    var matrix_mode = false;\n\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size - 1, -1, -1).forEach(function(i) {\n      parts = jStat.arange(i + 1, size).map(function(j) {\n        return x[j] * A[i][j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    });\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n  triaLowSolve: function triaLowSolve(A, b) {\n    // like to triaUpSolve but A is lower triangular matrix\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n\n    var matrix_mode=false;\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(j) {\n        return A[i][j] * x[j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    })\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n\n  // A -> [L,U]\n  // A=LU\n  // L is lower triangular matrix\n  // U is upper triangular matrix\n  lu: function lu(A) {\n    var size = A.length;\n    //var L=jStat.diagonal(jStat.ones(1,size)[0]);\n    var L = jStat.identity(size);\n    var R = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(t) {\n      R[0][t] = A[0][t];\n    });\n    jStat.arange(1, size).forEach(function(l) {\n      jStat.arange(l).forEach(function(i) {\n        parts = jStat.arange(i).map(function(jj) {\n          return L[l][jj] * R[jj][i];\n        });\n        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];\n      });\n      jStat.arange(l, size).forEach(function(j) {\n        parts = jStat.arange(l).map(function(jj) {\n          return L[l][jj] * R[jj][j];\n        });\n        R[l][j] = A[parts.length][j] - jStat.sum(parts);\n      });\n    });\n    return [L, R];\n  },\n\n  // A -> T\n  // A=TT'\n  // T is lower triangular matrix\n  cholesky: function cholesky(A) {\n    var size = A.length;\n    var T = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(t) {\n        return Math.pow(T[i][t],2);\n      });\n      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));\n      jStat.arange(i + 1, size).forEach(function(j) {\n        parts = jStat.arange(i).map(function(t) {\n          return T[i][t] * T[j][t];\n        });\n        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];\n      });\n    });\n    return T;\n  },\n\n\n  gauss_jacobi: function gauss_jacobi(a, b, x, r) {\n    var i = 0;\n    var j = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);\n    c = jStat.multiply(jStat.inv(d), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  gauss_seidel: function gauss_seidel(a, b, x, r) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);\n    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i = i + 1;\n    }\n    return xk;\n  },\n\n  SOR: function SOR(a, b, x, r, w) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),\n                       jStat.subtract(jStat.multiply(d, 1 - w),\n                                      jStat.multiply(u, w)));\n    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,\n        jStat.multiply(l, w))), b), w);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  householder: function householder(a) {\n    var m = a.length;\n    var n = a[0].length;\n    var i = 0;\n    var w = [];\n    var p = [];\n    var alpha, r, k, j, factor;\n    for (; i < m - 1; i++) {\n      alpha = 0;\n      for (j = i + 1; j < n; j++)\n      alpha += (a[j][i] * a[j][i]);\n      factor = (a[i + 1][i] > 0) ? -1 : 1;\n      alpha = factor * Math.sqrt(alpha);\n      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));\n      w = jStat.zeros(m, 1);\n      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);\n      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);\n      p = jStat.subtract(jStat.identity(m, n),\n          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));\n      a = jStat.multiply(p, jStat.multiply(a, p));\n    }\n    return a;\n  },\n\n  // A -> [Q,R]\n  // Q is orthogonal matrix\n  // R is upper triangular\n  QR: (function() {\n    // x -> Q\n    // find a orthogonal matrix Q st.\n    // Qx=y\n    // y is [||x||,0,0,...]\n\n    // quick ref\n    var sum   = jStat.sum;\n    var range = jStat.arange;\n\n    function qr2(x) {\n      // quick impletation\n      // https://www.stat.wisc.edu/~larget/math496/qr.html\n\n      var n = x.length;\n      var p = x[0].length;\n\n      var r = jStat.zeros(p, p);\n      x = jStat.copy(x);\n\n      var i,j,k;\n      for(j = 0; j < p; j++){\n        r[j][j] = Math.sqrt(sum(range(n).map(function(i){\n          return x[i][j] * x[i][j];\n        })));\n        for(i = 0; i < n; i++){\n          x[i][j] = x[i][j] / r[j][j];\n        }\n        for(k = j+1; k < p; k++){\n          r[j][k] = sum(range(n).map(function(i){\n            return x[i][j] * x[i][k];\n          }));\n          for(i = 0; i < n; i++){\n            x[i][k] = x[i][k] - x[i][j]*r[j][k];\n          }\n        }\n      }\n      return [x, r];\n    }\n\n    return qr2;\n  }()),\n\n  lstsq: (function() {\n    // solve least squard problem for Ax=b as QR decomposition way if b is\n    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution\n    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution\n    function R_I(A) {\n      A = jStat.copy(A);\n      var size = A.length;\n      var I = jStat.identity(size);\n      jStat.arange(size - 1, -1, -1).forEach(function(i) {\n        jStat.sliceAssign(\n            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));\n        jStat.sliceAssign(\n            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));\n        jStat.arange(i).forEach(function(j) {\n          var c = jStat.multiply(A[j][i], -1);\n          var Aj = jStat.slice(A, { row: j });\n          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);\n          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));\n          var Ij = jStat.slice(I, { row: j });\n          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);\n          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));\n        })\n      });\n      return I;\n    }\n\n    function qr_solve(A, b){\n      var array_mode = false;\n      if (b[0].length === undefined) {\n        // [c1,c2,c3] mode\n        b = b.map(function(x){ return [x] });\n        array_mode = true;\n      }\n      var QR = jStat.QR(A);\n      var Q = QR[0];\n      var R = QR[1];\n      var attrs = A[0].length;\n      var Q1 = jStat.slice(Q,{col:{end:attrs}});\n      var R1 = jStat.slice(R,{row:{end:attrs}});\n      var RI = R_I(R1);\n      var Q2 = jStat.transpose(Q1);\n\n      if(Q2[0].length === undefined){\n        Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.\n      }\n\n      var x = jStat.multiply(jStat.multiply(RI, Q2), b);\n\n      if(x.length === undefined){\n        x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.\n      }\n\n\n      if (array_mode)\n        return x.map(function(i){ return i[0] });\n      return x;\n    }\n\n    return qr_solve;\n  }()),\n\n  jacobi: function jacobi(a) {\n    var condition = 1;\n    var n = a.length;\n    var e = jStat.identity(n, n);\n    var ev = [];\n    var b, i, j, p, q, maxim, theta, s;\n    // condition === 1 only if tolerance is not reached\n    while (condition === 1) {\n      maxim = a[0][1];\n      p = 0;\n      q = 1;\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i != j) {\n            if (maxim < Math.abs(a[i][j])) {\n              maxim = Math.abs(a[i][j]);\n              p = i;\n              q = j;\n            }\n          }\n        }\n      }\n      if (a[p][p] === a[q][q])\n        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;\n      else\n        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;\n      s = jStat.identity(n, n);\n      s[p][p] = Math.cos(theta);\n      s[p][q] = -Math.sin(theta);\n      s[q][p] = Math.sin(theta);\n      s[q][q] = Math.cos(theta);\n      // eigen vector matrix\n      e = jStat.multiply(e, s);\n      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);\n      a = b;\n      condition = 0;\n      for (i = 1; i < n; i++) {\n        for (j = 1; j < n; j++) {\n          if (i != j && Math.abs(a[i][j]) > 0.001) {\n            condition = 1;\n          }\n        }\n      }\n    }\n    for (i = 0; i < n; i++) ev.push(a[i][i]);\n    //returns both the eigenvalue and eigenmatrix\n    return [e, ev];\n  },\n\n  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {\n    var k1, k2, u_j1, k3, k4;\n    if (order === 2) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h, u_j + k1);\n        u_j1 = u_j + (k1 + k2) / 2;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    if (order === 4) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h / 2, u_j + k1 / 2);\n        k3 = h * f(t_j + h / 2, u_j + k2 / 2);\n        k4 = h * f(t_j +h, u_j + k3);\n        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    return u_j;\n  },\n\n  romberg: function romberg(f, a, b, order) {\n    var i = 0;\n    var h = (b - a) / 2;\n    var x = [];\n    var h1 = [];\n    var g = [];\n    var m, a1, j, k, I;\n    while (i < order / 2) {\n      I = f(a);\n      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;\n      m = x.length;\n      for (j = 1; j < m - 1; j++) {\n        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);\n      }\n      I = (h / 3) * (I + f(b));\n      g[i] = I;\n      h /= 2;\n      i++;\n    }\n    a1 = g.length;\n    m = 1;\n    while (a1 !== 1) {\n      for (j = 0; j < a1 - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a1 = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  richardson: function richardson(X, f, x, h) {\n    function pos(X, x) {\n      var i = 0;\n      var n = X.length;\n      var p;\n      for (; i < n; i++)\n        if (X[i] === x) p = i;\n      return p;\n    }\n    var h_min = Math.abs(x - X[pos(X, x) + 1]);\n    var i = 0;\n    var g = [];\n    var h1 = [];\n    var y1, y2, m, a, j;\n    while (h >= h_min) {\n      y1 = pos(X, x + h);\n      y2 = pos(X, x);\n      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);\n      h /= 2;\n      i++;\n    }\n    a = g.length;\n    m = 1;\n    while (a != 1) {\n      for (j = 0; j < a - 1; j++)\n        h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  simpson: function simpson(f, a, b, n) {\n    var h = (b - a) / n;\n    var I = f(a);\n    var x = [];\n    var j = a;\n    var k = 0;\n    var i = 1;\n    var m;\n    for (; j <= b; j = j + h, k++)\n      x[k] = j;\n    m = x.length;\n    for (; i < m - 1; i++) {\n      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);\n    }\n    return (h / 3) * (I + f(b));\n  },\n\n  hermite: function hermite(X, F, dF, value) {\n    var n = X.length;\n    var p = 0;\n    var i = 0;\n    var l = [];\n    var dl = [];\n    var A = [];\n    var B = [];\n    var j;\n    for (; i < n; i++) {\n      l[i] = 1;\n      for (j = 0; j < n; j++) {\n        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);\n      }\n      dl[i] = 0;\n      for (j = 0; j < n; j++) {\n        if (i != j) dl[i] += 1 / (X [i] - X[j]);\n      }\n      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);\n      B[i] = (value - X[i]) * (l[i] * l[i]);\n      p += (A[i] * F[i] + B[i] * dF[i]);\n    }\n    return p;\n  },\n\n  lagrange: function lagrange(X, F, value) {\n    var p = 0;\n    var i = 0;\n    var j, l;\n    var n = X.length;\n    for (; i < n; i++) {\n      l = F[i];\n      for (j = 0; j < n; j++) {\n        // calculating the lagrange polynomial L_i\n        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);\n      }\n      // adding the lagrange polynomials found above\n      p += l;\n    }\n    return p;\n  },\n\n  cubic_spline: function cubic_spline(X, F, value) {\n    var n = X.length;\n    var i = 0, j;\n    var A = [];\n    var B = [];\n    var alpha = [];\n    var c = [];\n    var h = [];\n    var b = [];\n    var d = [];\n    for (; i < n - 1; i++)\n      h[i] = X[i + 1] - X[i];\n    alpha[0] = 0;\n    for (i = 1; i < n - 1; i++) {\n      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -\n          (3 / h[i-1]) * (F[i] - F[i-1]);\n    }\n    for (i = 1; i < n - 1; i++) {\n      A[i] = [];\n      B[i] = [];\n      A[i][i-1] = h[i-1];\n      A[i][i] = 2 * (h[i - 1] + h[i]);\n      A[i][i+1] = h[i];\n      B[i][0] = alpha[i];\n    }\n    c = jStat.multiply(jStat.inv(A), B);\n    for (j = 0; j < n - 1; j++) {\n      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;\n      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);\n    }\n    for (j = 0; j < n; j++) {\n      if (X[j] > value) break;\n    }\n    j -= 1;\n    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *\n        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];\n  },\n\n  gauss_quadrature: function gauss_quadrature() {\n    throw new Error('gauss_quadrature not yet implemented');\n  },\n\n  PCA: function PCA(X) {\n    var m = X.length;\n    var n = X[0].length;\n    var i = 0;\n    var j, temp1;\n    var u = [];\n    var D = [];\n    var result = [];\n    var temp2 = [];\n    var Y = [];\n    var Bt = [];\n    var B = [];\n    var C = [];\n    var V = [];\n    var Vt = [];\n    for (i = 0; i < m; i++) {\n      u[i] = jStat.sum(X[i]) / n;\n    }\n    for (i = 0; i < n; i++) {\n      B[i] = [];\n      for(j = 0; j < m; j++) {\n        B[i][j] = X[j][i] - u[j];\n      }\n    }\n    B = jStat.transpose(B);\n    for (i = 0; i < m; i++) {\n      C[i] = [];\n      for (j = 0; j < m; j++) {\n        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);\n      }\n    }\n    result = jStat.jacobi(C);\n    V = result[0];\n    D = result[1];\n    Vt = jStat.transpose(V);\n    for (i = 0; i < D.length; i++) {\n      for (j = i; j < D.length; j++) {\n        if(D[i] < D[j])  {\n          temp1 = D[i];\n          D[i] = D[j];\n          D[j] = temp1;\n          temp2 = Vt[i];\n          Vt[i] = Vt[j];\n          Vt[j] = temp2;\n        }\n      }\n    }\n    Bt = jStat.transpose(B);\n    for (i = 0; i < m; i++) {\n      Y[i] = [];\n      for (j = 0; j < Bt.length; j++) {\n        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);\n      }\n    }\n    return [X, D, Vt, Y];\n  }\n});\n\n// extend jStat.fn with methods that require one argument\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function(arg, func) {\n      var tmpthis = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));\n        }, 15);\n        return this;\n      }\n      if (typeof jStat[passfunc](this, arg) === 'number')\n        return jStat[passfunc](this, arg);\n      else\n        return jStat(jStat[passfunc](this, arg));\n    };\n  }(funcs[i]));\n}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\nvar slice = [].slice;\nvar isNumber = jStat.utils.isNumber;\nvar isArray = jStat.utils.isArray;\n\n// flag==true denotes use of sample standard deviation\n// Z Statistics\njStat.extend({\n  // 2 different parameter lists:\n  // (value, mean, sd)\n  // (value, array, flag)\n  zscore: function zscore() {\n    var args = slice.call(arguments);\n    if (isNumber(args[1])) {\n      return (args[0] - args[1]) / args[2];\n    }\n    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, sides)\n  // (zscore, sides)\n  // (value, array, sides, flag)\n  ztest: function ztest() {\n    var args = slice.call(arguments);\n    var z;\n    if (isArray(args[1])) {\n      // (value, array, sides, flag)\n      z = jStat.zscore(args[0],args[1],args[3]);\n      return (args[2] === 1) ?\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);\n    } else {\n      if (args.length > 2) {\n        // (value, mean, sd, sides)\n        z = jStat.zscore(args[0],args[1],args[2]);\n        return (args[3] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);\n      } else {\n        // (zscore, sides)\n        z = args[0];\n        return (args[1] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)*2);\n      }\n    }\n  }\n});\n\njStat.extend(jStat.fn, {\n  zscore: function zscore(value, flag) {\n    return (value - this.mean()) / this.stdev(flag);\n  },\n\n  ztest: function ztest(value, sides, flag) {\n    var zscore = Math.abs(this.zscore(value, flag));\n    return (sides === 1) ?\n      (jStat.normal.cdf(-zscore, 0, 1)) :\n      (jStat.normal.cdf(-zscore, 0, 1) * 2);\n  }\n});\n\n// T Statistics\njStat.extend({\n  // 2 parameter lists\n  // (value, mean, sd, n)\n  // (value, array)\n  tscore: function tscore() {\n    var args = slice.call(arguments);\n    return (args.length === 4) ?\n      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :\n      ((args[0] - jStat.mean(args[1])) /\n       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, n, sides)\n  // (tscore, n, sides)\n  // (value, array, sides)\n  ttest: function ttest() {\n    var args = slice.call(arguments);\n    var tscore;\n    if (args.length === 5) {\n      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));\n      return (args[4] === 1) ?\n        (jStat.studentt.cdf(-tscore, args[3]-1)) :\n        (jStat.studentt.cdf(-tscore, args[3]-1)*2);\n    }\n    if (isNumber(args[1])) {\n      tscore = Math.abs(args[0])\n      return (args[2] == 1) ?\n        (jStat.studentt.cdf(-tscore, args[1]-1)) :\n        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);\n    }\n    tscore = Math.abs(jStat.tscore(args[0], args[1]))\n    return (args[2] == 1) ?\n      (jStat.studentt.cdf(-tscore, args[1].length-1)) :\n      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  tscore: function tscore(value) {\n    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));\n  },\n\n  ttest: function ttest(value, sides) {\n    return (sides === 1) ?\n      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :\n      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);\n  }\n});\n\n// F Statistics\njStat.extend({\n  // Paramter list is as follows:\n  // (array1, array2, array3, ...)\n  // or it is an array of arrays\n  // array of arrays conversion\n  anovafscore: function anovafscore() {\n    var args = slice.call(arguments),\n    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;\n    if (args.length === 1) {\n      tmpargs = new Array(args[0].length);\n      for (i = 0; i < args[0].length; i++) {\n        tmpargs[i] = args[0][i];\n      }\n      args = tmpargs;\n    }\n    // Builds sample array\n    sample = new Array();\n    for (i = 0; i < args.length; i++) {\n      sample = sample.concat(args[i]);\n    }\n    sampMean = jStat.mean(sample);\n    // Computes the explained variance\n    expVar = 0;\n    for (i = 0; i < args.length; i++) {\n      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);\n    }\n    expVar /= (args.length - 1);\n    // Computes unexplained variance\n    unexpVar = 0;\n    for (i = 0; i < args.length; i++) {\n      sampSampMean = jStat.mean(args[i]);\n      for (j = 0; j < args[i].length; j++) {\n        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);\n      }\n    }\n    unexpVar /= (sample.length - args.length);\n    return expVar / unexpVar;\n  },\n\n  // 2 different paramter setups\n  // (array1, array2, array3, ...)\n  // (anovafscore, df1, df2)\n  anovaftest: function anovaftest() {\n    var args = slice.call(arguments),\n    df1, df2, n, i;\n    if (isNumber(args[0])) {\n      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);\n    }\n    var anovafscore = jStat.anovafscore(args);\n    df1 = args.length - 1;\n    n = 0;\n    for (i = 0; i < args.length; i++) {\n      n = n + args[i].length;\n    }\n    df2 = n - df1 - 1;\n    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);\n  },\n\n  ftest: function ftest(fscore, df1, df2) {\n    return 1 - jStat.centralF.cdf(fscore, df1, df2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  anovafscore: function anovafscore() {\n    return jStat.anovafscore(this.toArray());\n  },\n\n  anovaftes: function anovaftes() {\n    var n = 0;\n    var i;\n    for (i = 0; i < this.length; i++) {\n      n = n + this[i].length;\n    }\n    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);\n  }\n});\n\n// Tukey's range test\njStat.extend({\n  // 2 parameter lists\n  // (mean1, mean2, n1, n2, sd)\n  // (array1, array2, sd)\n  qscore: function qscore() {\n    var args = slice.call(arguments);\n    var mean1, mean2, n1, n2, sd;\n    if (isNumber(args[0])) {\n        mean1 = args[0];\n        mean2 = args[1];\n        n1 = args[2];\n        n2 = args[3];\n        sd = args[4];\n    } else {\n        mean1 = jStat.mean(args[0]);\n        mean2 = jStat.mean(args[1]);\n        n1 = args[0].length;\n        n2 = args[1].length;\n        sd = args[2];\n    }\n    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));\n  },\n\n  // 3 different parameter lists:\n  // (qscore, n, k)\n  // (mean1, mean2, n1, n2, sd, n, k)\n  // (array1, array2, sd, n, k)\n  qtest: function qtest() {\n    var args = slice.call(arguments);\n\n    var qscore;\n    if (args.length === 3) {\n      qscore = args[0];\n      args = args.slice(1);\n    } else if (args.length === 7) {\n      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);\n      args = args.slice(5);\n    } else {\n      qscore = jStat.qscore(args[0], args[1], args[2]);\n      args = args.slice(3);\n    }\n\n    var n = args[0];\n    var k = args[1];\n\n    return 1 - jStat.tukey.cdf(qscore, k, n - k);\n  },\n\n  tukeyhsd: function tukeyhsd(arrays) {\n    var sd = jStat.pooledstdev(arrays);\n    var means = arrays.map(function (arr) {return jStat.mean(arr);});\n    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);\n\n    var results = [];\n    for (var i = 0; i < arrays.length; ++i) {\n        for (var j = i + 1; j < arrays.length; ++j) {\n            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);\n            results.push([[i, j], p]);\n        }\n    }\n\n    return results;\n  }\n});\n\n// Error Bounds\njStat.extend({\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  normalci: function normalci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  tci: function tci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *\n                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  significant: function significant(pvalue, alpha) {\n    return pvalue < alpha;\n  }\n});\n\njStat.extend(jStat.fn, {\n  normalci: function normalci(value, alpha) {\n    return jStat.normalci(value, alpha, this.toArray());\n  },\n\n  tci: function tci(value, alpha) {\n    return jStat.tci(value, alpha, this.toArray());\n  }\n});\n\n// internal method for calculating the z-score for a difference of proportions test\nfunction differenceOfProportions(p1, n1, p2, n2) {\n  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {\n    throw new Error(\"Proportions should be greater than 0 and less than 1\")\n  }\n  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);\n  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));\n  return (p1 - p2) / se;\n}\n\n// Difference of Proportions\njStat.extend(jStat.fn, {\n  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 1);\n  },\n\n  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 2);\n  }\n});\n\n}(jStat, Math));\njStat.models = (function(){\n  function sub_regress(exog) {\n    var var_count = exog[0].length;\n    var modelList = jStat.arange(var_count).map(function(endog_index) {\n      var exog_index =\n          jStat.arange(var_count).filter(function(i){return i!==endog_index});\n      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),\n                 jStat.col(exog, exog_index))\n    });\n    return modelList;\n  }\n\n  // do OLS model regress\n  // exog have include const columns ,it will not generate it .In fact, exog is\n  // \"design matrix\" look at\n  //https://en.wikipedia.org/wiki/Design_matrix\n  function ols(endog, exog) {\n    var nobs = endog.length;\n    var df_model = exog[0].length - 1;\n    var df_resid = nobs-df_model - 1;\n    var coef = jStat.lstsq(exog, endog);\n    var predict =\n        jStat.multiply(exog, coef.map(function(x) { return [x] }))\n            .map(function(p) { return p[0] });\n    var resid = jStat.subtract(endog, predict);\n    var ybar = jStat.mean(endog);\n    // constant cause problem\n    // var SST = jStat.sum(endog.map(function(y) {\n    //   return Math.pow(y-ybar,2);\n    // }));\n    var SSE = jStat.sum(predict.map(function(f) {\n      return Math.pow(f - ybar, 2);\n    }));\n    var SSR = jStat.sum(endog.map(function(y, i) {\n      return Math.pow(y - predict[i], 2);\n    }));\n    var SST = SSE + SSR;\n    var R2 = (SSE / SST);\n    return {\n        exog:exog,\n        endog:endog,\n        nobs:nobs,\n        df_model:df_model,\n        df_resid:df_resid,\n        coef:coef,\n        predict:predict,\n        resid:resid,\n        ybar:ybar,\n        SST:SST,\n        SSE:SSE,\n        SSR:SSR,\n        R2:R2\n    };\n  }\n\n  // H0: b_I=0\n  // H1: b_I!=0\n  function t_test(model) {\n    var subModelList = sub_regress(model.exog);\n    //var sigmaHat=jStat.stdev(model.resid);\n    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));\n    var seBetaHat = subModelList.map(function(mod) {\n      var SST = mod.SST;\n      var R2 = mod.R2;\n      return sigmaHat / Math.sqrt(SST * (1 - R2));\n    });\n    var tStatistic = model.coef.map(function(coef, i) {\n      return (coef - 0) / seBetaHat[i];\n    });\n    var pValue = tStatistic.map(function(t) {\n      var leftppf = jStat.studentt.cdf(t, model.df_resid);\n      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;\n    });\n    var c = jStat.studentt.inv(0.975, model.df_resid);\n    var interval95 = model.coef.map(function(coef, i) {\n      var d = c * seBetaHat[i];\n      return [coef - d, coef + d];\n    })\n    return {\n        se: seBetaHat,\n        t: tStatistic,\n        p: pValue,\n        sigmaHat: sigmaHat,\n        interval95: interval95\n    };\n  }\n\n  function F_test(model) {\n    var F_statistic =\n        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);\n    var fcdf = function(x, n1, n2) {\n      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)\n    }\n    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);\n    return { F_statistic: F_statistic, pvalue: pvalue };\n  }\n\n  function ols_wrap(endog, exog) {\n    var model = ols(endog,exog);\n    var ttest = t_test(model);\n    var ftest = F_test(model);\n    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2\n    // Which matches the 'adjusted R^2' provided by R's lm package\n    var adjust_R2 =\n        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));\n    model.t = ttest;\n    model.f = ftest;\n    model.adjust_R2 = adjust_R2;\n    return model;\n  }\n\n  return { ols: ols_wrap };\n})();\n//To regress, simply build X matrix\n//(append column of 1's) using\n//buildxmatrix and build the Y\n//matrix using buildymatrix\n//(simply the transpose)\n//and run regress.\n\n\n\n//Regressions\n\njStat.extend({\n  buildxmatrix: function buildxmatrix(){\n    //Parameters will be passed in as such\n    //(array1,array2,array3,...)\n    //as (x1,x2,x3,...)\n    //needs to be (1,x1,x2,x3,...)\n    var matrixRows = new Array(arguments.length);\n    for(var i=0;i<arguments.length;i++){\n      var array = [1];\n      matrixRows[i]= array.concat(arguments[i]);\n    }\n    return jStat(matrixRows);\n\n  },\n\n  builddxmatrix: function builddxmatrix() {\n    //Paramters will be passed in as such\n    //([array1,array2,...]\n    var matrixRows = new Array(arguments[0].length);\n    for(var i=0;i<arguments[0].length;i++){\n      var array = [1]\n      matrixRows[i]= array.concat(arguments[0][i]);\n    }\n    return jStat(matrixRows);\n\n  },\n\n  buildjxmatrix: function buildjxmatrix(jMat) {\n    //Builds from jStat Matrix\n    var pass = new Array(jMat.length)\n    for(var i=0;i<jMat.length;i++){\n      pass[i] = jMat[i];\n    }\n    return jStat.builddxmatrix(pass);\n\n  },\n\n  buildymatrix: function buildymatrix(array){\n    return jStat(array).transpose();\n  },\n\n  buildjymatrix: function buildjymatrix(jMat){\n    return jMat.transpose();\n  },\n\n  matrixmult: function matrixmult(A,B){\n    var i, j, k, result, sum;\n    if (A.cols() == B.rows()) {\n      if(B.rows()>1){\n        result = [];\n        for (i = 0; i < A.rows(); i++) {\n          result[i] = [];\n          for (j = 0; j < B.cols(); j++) {\n            sum = 0;\n            for (k = 0; k < A.cols(); k++) {\n              sum += A.toArray()[i][k] * B.toArray()[k][j];\n            }\n            result[i][j] = sum;\n          }\n        }\n        return jStat(result);\n      }\n      result = [];\n      for (i = 0; i < A.rows(); i++) {\n        result[i] = [];\n        for (j = 0; j < B.cols(); j++) {\n          sum = 0;\n          for (k = 0; k < A.cols(); k++) {\n            sum += A.toArray()[i][k] * B.toArray()[j];\n          }\n          result[i][j] = sum;\n        }\n      }\n      return jStat(result);\n    }\n  },\n\n  //regress and regresst to be fixed\n\n  regress: function regress(jMatX,jMatY){\n    //print(\"regressin!\");\n    //print(jMatX.toArray());\n    var innerinv = jStat.xtranspxinv(jMatX);\n    //print(innerinv);\n    var xtransp = jMatX.transpose();\n    var next = jStat.matrixmult(jStat(innerinv),xtransp);\n    return jStat.matrixmult(next,jMatY);\n\n  },\n\n  regresst: function regresst(jMatX,jMatY,sides){\n    var beta = jStat.regress(jMatX,jMatY);\n\n    var compile = {};\n    compile.anova = {};\n    var jMatYBar = jStat.jMatYBar(jMatX, beta);\n    compile.yBar = jMatYBar;\n    var yAverage = jMatY.mean();\n    compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);\n\n    compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);\n    compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);\n\n    compile.anova.sse = jStat.sse(jMatY, jMatYBar);\n    compile.anova.mse =\n        compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);\n\n    compile.anova.sst = jStat.sst(jMatY, yAverage);\n    compile.anova.mst = compile.anova.sst / (jMatY.length - 1);\n\n    compile.anova.r2 = 1 - (compile.anova.sse / compile.anova.sst);\n    if (compile.anova.r2 < 0) compile.anova.r2 = 0;\n\n    compile.anova.fratio = compile.anova.msr / compile.anova.mse;\n    compile.anova.pvalue =\n        jStat.anovaftest(compile.anova.fratio,\n                         jMatX[0].length - 1,\n                         jMatY.length - (jMatX[0].length - 1) - 1);\n\n    compile.anova.rmse = Math.sqrt(compile.anova.mse);\n\n    compile.anova.r2adj = 1 - (compile.anova.mse / compile.anova.mst);\n    if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;\n\n    compile.stats = new Array(jMatX[0].length);\n    var covar = jStat.xtranspxinv(jMatX);\n    var sds, ts, ps;\n\n    for(var i=0; i<beta.length;i++){\n      sds=Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));\n      ts= Math.abs(beta[i] / sds);\n      ps= jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);\n\n      compile.stats[i]=[beta[i], sds, ts, ps];\n    }\n\n    compile.regress = beta;\n    return compile;\n  },\n\n  xtranspx: function xtranspx(jMatX){\n    return jStat.matrixmult(jMatX.transpose(),jMatX);\n  },\n\n\n  xtranspxinv: function xtranspxinv(jMatX){\n    var inner = jStat.matrixmult(jMatX.transpose(),jMatX);\n    var innerinv = jStat.inv(inner);\n    return innerinv;\n  },\n\n  jMatYBar: function jMatYBar(jMatX, beta) {\n    var yBar = jStat.matrixmult(jMatX, beta);\n    return new jStat(yBar);\n  },\n\n  residuals: function residuals(jMatY, jMatYBar) {\n    return jStat.matrixsubtract(jMatY, jMatYBar);\n  },\n\n  ssr: function ssr(jMatYBar, yAverage) {\n    var ssr = 0;\n    for(var i = 0; i < jMatYBar.length; i++) {\n      ssr += Math.pow(jMatYBar[i] - yAverage, 2);\n    }\n    return ssr;\n  },\n\n  sse: function sse(jMatY, jMatYBar) {\n    var sse = 0;\n    for(var i = 0; i < jMatY.length; i++) {\n      sse += Math.pow(jMatY[i] - jMatYBar[i], 2);\n    }\n    return sse;\n  },\n\n  sst: function sst(jMatY, yAverage) {\n    var sst = 0;\n    for(var i = 0; i < jMatY.length; i++) {\n      sst += Math.pow(jMatY[i] - yAverage, 2);\n    }\n    return sst;\n  },\n\n  matrixsubtract: function matrixsubtract(A,B){\n    var ans = new Array(A.length);\n    for(var i=0;i<A.length;i++){\n      ans[i] = new Array(A[i].length);\n      for(var j=0;j<A[i].length;j++){\n        ans[i][j]=A[i][j]-B[i][j];\n      }\n    }\n    return jStat(ans);\n  }\n});\n  // Make it compatible with previous version.\n  jStat.jStat = jStat;\n\n  return jStat;\n});\n", "const FormulaError = require('../error');\r\nconst TextFunctions = require('./text');\r\nconst {FormulaHelpers, Types} = require('../helpers');\r\nconst H = FormulaHelpers;\r\nconst bessel = require(\"bessel\");\r\nconst jStat = require(\"jstat\");\r\nconst MAX_OCT = 536870911, // OCT2DEC(3777777777)\r\n    MIN_OCT = -536870912, // OCT2DEC4000000000)\r\n    MAX_HEX = 549755813887,\r\n    MIN_HEX = -549755813888,\r\n    MAX_BIN = 511, // BIN2DEC(111111111)\r\n    MIN_BIN = -512; // BIN2DEC(1000000000)\r\n\r\nconst numberRegex = /^\\s?[+-]?\\s?[0-9]+[.]?[0-9]*([eE][+\\-][0-9]+)?\\s?$/;\r\nconst IMWithoutRealRegex = /^\\s?([+-]?\\s?([0-9]+[.]?[0-9]*([eE][+\\-][0-9]+)?)?)\\s?[ij]\\s?$/;\r\nconst IMRegex = /^\\s?([+-]?\\s?[0-9]+[.]?[0-9]*([eE][+\\-][0-9]+)?)\\s?([+-]?\\s?([0-9]+[.]?[0-9]*([eE][+\\-][0-9]+)?)?)\\s?[ij]\\s?$/;\r\n\r\nfunction parseIM(textOrNumber) {\r\n    textOrNumber = H.accept(textOrNumber);\r\n    let real = 0, im = 0, unit = 'i';\r\n    if (typeof textOrNumber === \"number\")\r\n        return {real: textOrNumber, im, unit};\r\n    if (typeof textOrNumber === \"boolean\")\r\n        throw FormulaError.VALUE;\r\n    let match = textOrNumber.match(numberRegex);\r\n    if (match) {\r\n        real = Number(match[0]);\r\n        return {real, im, unit};\r\n    }\r\n    match = textOrNumber.match(IMWithoutRealRegex);\r\n    if (match) {\r\n        im = Number(/^\\s?[+-]?\\s?$/.test(match[1]) ? match[1] + '1' : match[1]);\r\n        unit = match[0].slice(-1);\r\n        return {real, im, unit};\r\n    }\r\n    match = textOrNumber.match(IMRegex);\r\n    if (match) {\r\n        real = Number(match[1]);\r\n        im = Number(/^\\s?[+-]?\\s?$/.test(match[3]) ? match[3] + '1' : match[3]);\r\n        unit = match[0].slice(-1);\r\n        return {real, im, unit};\r\n    }\r\n    throw FormulaError.NUM;\r\n}\r\n\r\nconst EngineeringFunctions = {\r\n    BESSELI: (x, n) => {\r\n        x = H.accept(x, Types.NUMBER_NO_BOOLEAN);\r\n        n = H.accept(n, Types.NUMBER_NO_BOOLEAN);\r\n        // if n is not an integer, it is truncated.\r\n        n = Math.trunc(n);\r\n        if (n < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        return bessel.besseli(x, n);\r\n    },\r\n\r\n    BESSELJ: (x, n) => {\r\n        x = H.accept(x, Types.NUMBER_NO_BOOLEAN);\r\n        n = H.accept(n, Types.NUMBER_NO_BOOLEAN);\r\n        // if n is not an integer, it is truncated.\r\n        n = Math.trunc(n);\r\n        if (n < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        return bessel.besselj(x, n);\r\n    },\r\n\r\n    BESSELK: (x, n) => {\r\n        x = H.accept(x, Types.NUMBER_NO_BOOLEAN);\r\n        n = H.accept(n, Types.NUMBER_NO_BOOLEAN);\r\n        // if n is not an integer, it is truncated.\r\n        n = Math.trunc(n);\r\n        if (n < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return bessel.besselk(x, n);\r\n    },\r\n\r\n    BESSELY: (x, n) => {\r\n        x = H.accept(x, Types.NUMBER_NO_BOOLEAN);\r\n        n = H.accept(n, Types.NUMBER_NO_BOOLEAN);\r\n        // if n is not an integer, it is truncated.\r\n        n = Math.trunc(n);\r\n        if (n < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return bessel.bessely(x, n);\r\n    },\r\n\r\n    BIN2DEC: (number) => {\r\n        number = H.accept(number, Types.NUMBER_NO_BOOLEAN);\r\n        let numberStr = number.toString();\r\n\r\n        if (numberStr.length > 10) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        if (numberStr.length === 10 && numberStr.substring(0, 1) === '1') {\r\n            return parseInt(numberStr.substring(1), 2) + MIN_BIN;\r\n        } else {\r\n            return parseInt(numberStr, 2);\r\n        }\r\n    },\r\n\r\n    BIN2HEX: (number, places) => {\r\n        number = H.accept(number, Types.NUMBER_NO_BOOLEAN);\r\n        places = H.accept(places, Types.NUMBER_NO_BOOLEAN, null);\r\n\r\n        const numberStr = number.toString();\r\n        if (numberStr.length > 10) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        if (numberStr.length === 10 && numberStr.substring(0, 1) === '1') {\r\n            return (parseInt(numberStr.substring(1), 2) + 1099511627264).toString(16).toUpperCase();\r\n        }\r\n        // convert BIN to HEX\r\n        const result = parseInt(number, 2).toString(16);\r\n\r\n        if (places == null) {\r\n            return result.toUpperCase();\r\n        } else {\r\n            if (places < 0) {\r\n                throw FormulaError.NUM;\r\n            }\r\n            // truncate places in case it is not an integer\r\n            places = Math.trunc(places);\r\n            if (places >= result.length) {\r\n                return (TextFunctions.REPT('0', places - result.length) + result).toUpperCase();\r\n            } else {\r\n                throw FormulaError.NUM;\r\n            }\r\n        }\r\n    },\r\n\r\n    BIN2OCT: (number, places) => {\r\n        number = H.accept(number, Types.NUMBER_NO_BOOLEAN);\r\n        places = H.accept(places, Types.NUMBER, null);\r\n\r\n        let numberStr = number.toString();\r\n        if (numberStr.length > 10) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        if (numberStr.length === 10 && numberStr.substr(0, 1) === \"1\") {\r\n            return (parseInt(numberStr.substr(1), 2) + 1073741312).toString(8);\r\n        }\r\n\r\n        let result = parseInt(number, 2).toString(8);\r\n        if (places == null) {\r\n            return result.toUpperCase();\r\n        } else {\r\n            if (places < 0) {\r\n                throw FormulaError.NUM;\r\n            }\r\n            // truncate places in case it is not an integer\r\n            places = Math.trunc(places);\r\n            if (places >= result.length) {\r\n                return (TextFunctions.REPT('0', places - result.length) + result);\r\n            } else {\r\n                throw FormulaError.NUM;\r\n            }\r\n        }\r\n    },\r\n\r\n    BITAND: (number1, number2) => {\r\n        number1 = H.accept(number1, Types.NUMBER);\r\n        number2 = H.accept(number2, Types.NUMBER);\r\n        if (number1 < 0 || number2 < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // check if they are non-integer, if yes, return error\r\n        if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        if (number1 > 281474976710655 || number2 > 281474976710655) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return number1 & number2;\r\n    },\r\n\r\n    BITLSHIFT: (number, shiftAmount) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        shiftAmount = H.accept(shiftAmount, Types.NUMBER);\r\n        shiftAmount = Math.trunc(shiftAmount);\r\n        if (Math.abs(shiftAmount) > 53) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        if (number < 0 || Math.floor(number) !== number || number > 281474976710655) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        const result = (shiftAmount >= 0) ? number * 2 ** shiftAmount : Math.trunc(number / 2 ** -shiftAmount);\r\n        if (result > 281474976710655)\r\n            throw FormulaError.NUM;\r\n        else\r\n            return result;\r\n    },\r\n\r\n    BITOR: (number1, number2) => {\r\n        number1 = H.accept(number1, Types.NUMBER);\r\n        number2 = H.accept(number2, Types.NUMBER);\r\n        if (number1 < 0 || number2 < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // check if they are non-integer, if yes, return error\r\n        if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        if (number1 > 281474976710655 || number2 > 281474976710655) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return number1 | number2;\r\n    },\r\n\r\n    BITRSHIFT: (number, shiftAmount) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        shiftAmount = H.accept(shiftAmount, Types.NUMBER);\r\n        return EngineeringFunctions.BITLSHIFT(number, -shiftAmount);\r\n    },\r\n\r\n    BITXOR: (number1, number2) => {\r\n        number1 = H.accept(number1, Types.NUMBER);\r\n        number2 = H.accept(number2, Types.NUMBER);\r\n        if (number1 < 0 || number1 > 281474976710655 || Math.floor(number1) !== number1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        if (number2 < 0 || number2 > 281474976710655 || Math.floor(number2) !== number2) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // // to check if the number is a non-integer\r\n        // if (Math.abs(number1) !== number1 || Math.abs(number2) !== number2) {\r\n        //     throw FormulaError.NUM;\r\n        // }\r\n\r\n        return number1 ^ number2;\r\n    },\r\n\r\n    COMPLEX: (realNum, iNum, suffix) => {\r\n        realNum = H.accept(realNum, Types.NUMBER_NO_BOOLEAN);\r\n        iNum = H.accept(iNum, Types.NUMBER_NO_BOOLEAN);\r\n        suffix = H.accept(suffix, Types.STRING, \"i\");\r\n        if (suffix !== \"i\" && suffix !== \"j\") {\r\n            throw FormulaError.VALUE;\r\n        }\r\n        if (realNum === 0 && iNum === 0) {\r\n            return 0;\r\n        } else if (realNum === 0) {\r\n            if (iNum === 1) {\r\n                return suffix;\r\n            } else if (iNum === -1) {\r\n                return \"-\" + suffix;\r\n            } else {\r\n                return iNum.toString() + suffix;\r\n            }\r\n        } else if (iNum === 0) {\r\n            return realNum.toString()\r\n        } else {\r\n            let sign = (iNum > 0) ? \"+\" : \"\";\r\n            if (iNum === 1) {\r\n                return realNum.toString() + sign + suffix;\r\n            } else if (iNum === -1) {\r\n                return realNum.toString() + sign + \"-\" + suffix;\r\n            } else {\r\n                return realNum.toString() + sign + iNum.toString() + suffix;\r\n            }\r\n        }\r\n    },\r\n\r\n    DEC2BIN: (number, places) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        places = H.accept(places, Types.NUMBER, null);\r\n        if (number < MIN_BIN || number > MAX_BIN) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // if the number is negative, valid place values are ignored and it returns a 10-character binary number.\r\n        if (number < 0) {\r\n            return \"1\" + TextFunctions.REPT(\"0\", 9 - (512 + number).toString(2).length) + (512 + number).toString(2);\r\n        }\r\n\r\n        let result = parseInt(number, 10).toString(2);\r\n        if (places == null) {\r\n            return result;\r\n        } else {\r\n            // if places is not an integer, it is truncated\r\n            places = Math.trunc(places);\r\n            if (places <= 0) {\r\n                throw FormulaError.NUM;\r\n            }\r\n            if (places < result.length)\r\n                throw FormulaError.NUM;\r\n            return TextFunctions.REPT(\"0\", places - result.length) + result;\r\n        }\r\n    },\r\n\r\n    DEC2HEX: (number, places) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        places = H.accept(places, Types.NUMBER, null);\r\n        if (number < -549755813888 || number > 549755813888) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // if the number is negative, valid place values are ignored and it returns a 10-character binary number.\r\n        if (number < 0) {\r\n            return (1099511627776 + number).toString(16).toUpperCase();\r\n        }\r\n\r\n        let result = parseInt(number, 10).toString(16);\r\n\r\n        if (places == null) {\r\n            return result.toUpperCase();\r\n        } else {\r\n            // if places is not an integer, it is truncated\r\n            places = Math.trunc(places);\r\n            if (places <= 0) {\r\n                throw FormulaError.NUM;\r\n            }\r\n            if (places < result.length)\r\n                throw FormulaError.NUM;\r\n            return TextFunctions.REPT(\"0\", places - result.length) + result.toUpperCase();\r\n        }\r\n    },\r\n\r\n    DEC2OCT: (number, places) => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        places = H.accept(places, Types.NUMBER, null);\r\n        if (number < -536870912 || number > 536870912) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // if the number is negative, valid place values are ignored and it returns a 10-character binary number.\r\n        if (number < 0) {\r\n            return (number + 1073741824).toString(8);\r\n        }\r\n\r\n        let result = parseInt(number, 10).toString(8);\r\n\r\n        if (places == null) {\r\n            return result.toUpperCase();\r\n        } else {\r\n            // if places is not an integer, it is truncated\r\n            places = Math.trunc(places);\r\n            if (places <= 0) {\r\n                throw FormulaError.NUM;\r\n            }\r\n            if (places < result.length)\r\n                throw FormulaError.NUM;\r\n            return TextFunctions.REPT(\"0\", places - result.length) + result;\r\n        }\r\n    },\r\n\r\n    DELTA: (number1, number2) => {\r\n        number1 = H.accept(number1, Types.NUMBER_NO_BOOLEAN);\r\n        number2 = H.accept(number2, Types.NUMBER_NO_BOOLEAN, 0);\r\n\r\n        return number1 === number2 ? 1 : 0;\r\n    },\r\n\r\n    ERF: (lowerLimit, upperLimit) => {\r\n        lowerLimit = H.accept(lowerLimit, Types.NUMBER_NO_BOOLEAN);\r\n        upperLimit = H.accept(upperLimit, Types.NUMBER_NO_BOOLEAN, 0);\r\n        return jStat.erf(lowerLimit);\r\n    },\r\n\r\n    ERFC: (x) => {\r\n        x = H.accept(x, Types.NUMBER_NO_BOOLEAN);\r\n        return jStat.erfc(x);\r\n    },\r\n\r\n    GESTEP: (number, step) => {\r\n        number = H.accept(number, Types.NUMBER_NO_BOOLEAN);\r\n        step = H.accept(step, Types.NUMBER_NO_BOOLEAN, 0);\r\n        return number >= step ? 1 : 0;\r\n    },\r\n\r\n    HEX2BIN: (number, places) => {\r\n        number = H.accept(number, Types.STRING);\r\n        places = H.accept(places, Types.NUMBER, null);\r\n\r\n        if (number.length > 10 || !/^[0-9a-fA-F]*$/.test(number)) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // to check if the number is negative\r\n        let ifNegative = (number.length === 10 && number.substr(0, 1).toLowerCase() === \"f\");\r\n        // convert HEX to DEC\r\n        let toDecimal = ifNegative ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);\r\n        // if number is lower than -512 or grater than 511, return error\r\n        if (toDecimal < MIN_BIN || toDecimal > MAX_BIN) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // if the number is negative, valid place values are ignored and it returns a 10-character binary number.\r\n        if (ifNegative) {\r\n            return \"1\" + TextFunctions.REPT('0', 9 - (toDecimal + 512).toString(2).length) + (toDecimal + 512).toString(2)\r\n        }\r\n        // convert decimal to binary\r\n        let toBinary = toDecimal.toString(2);\r\n\r\n        if (places == null) {\r\n            return toBinary;\r\n        } else {\r\n            // if places is not an integer, it is truncated\r\n            places = Math.trunc(places);\r\n            if (places <= 0 || places < toBinary.length) {\r\n                throw FormulaError.NUM;\r\n            }\r\n            return TextFunctions.REPT(\"0\", places - toBinary.length) + toBinary;\r\n        }\r\n    },\r\n\r\n    HEX2DEC: (number) => {\r\n        number = H.accept(number, Types.STRING);\r\n        if (number.length > 10 || !/^[0-9a-fA-F]*$/.test(number)) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        let result = parseInt(number, 16);\r\n        //david: validate\r\n        // If the places is larger than 10, or number is larger than, return #NUM!\r\n        // If number is not a valid Hex number,  returns the #NUM! error value.\r\n\r\n        return (result >= 549755813888) ? result - 1099511627776 : result;\r\n    },\r\n\r\n    HEX2OCT: (number, places) => {\r\n        number = H.accept(number, Types.STRING);\r\n        if (number.length > 10 || !/^[0-9a-fA-F]*$/.test(number)) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // convert HEX to DEC\r\n        let toDecimal = EngineeringFunctions.HEX2DEC(number);\r\n        if (toDecimal > MAX_OCT || toDecimal < MIN_OCT) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        return EngineeringFunctions.DEC2OCT(toDecimal, places);\r\n    },\r\n\r\n    IMABS: (iNumber) => {\r\n        const {real, im} = parseIM(iNumber);\r\n        return Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2));\r\n    },\r\n\r\n    IMAGINARY: (iNumber) => {\r\n        return parseIM(iNumber).im;\r\n    },\r\n\r\n    IMARGUMENT: (iNumber) => {\r\n        const {real, im} = parseIM(iNumber);\r\n        // x + yi => x cannot be 0, since theta = tan-1(y / x)\r\n        if (real === 0 && im === 0) {\r\n            throw FormulaError.DIV0;\r\n        }\r\n        // return PI/2 if x is equal to 0 and y is positive\r\n        if (real === 0 && im > 0) {\r\n            return Math.PI / 2;\r\n        }\r\n        // while return -PI/2 if x is equal to 0 and y is negative\r\n        if (real === 0 && im < 0) {\r\n            return -Math.PI / 2;\r\n        }\r\n        // return -PI if x is negative and y is equal to 0\r\n        if (real < 0 && im === 0) {\r\n            return Math.PI\r\n        }\r\n        // return 0 if x is positive and y is equal to 0\r\n        if (real > 0 && im === 0) {\r\n            return 0;\r\n        }\r\n        // return argument of iNumber\r\n        if (real > 0) {\r\n            return Math.atan(im / real);\r\n        } else if (real < 0 && im > 0) {\r\n            return Math.atan(im / real) + Math.PI;\r\n        } else {\r\n            return Math.atan(im / real) - Math.PI;\r\n        }\r\n\r\n    },\r\n\r\n    IMCONJUGATE: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        return (im !== 0) ? EngineeringFunctions.COMPLEX(real, -im, unit) : '' + real;\r\n    },\r\n\r\n    IMCOS: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        let realInput = Math.cos(real) * (Math.exp(im) + Math.exp(-im)) / 2;\r\n        let imaginaryInput = -Math.sin(real) * (Math.exp(im) - Math.exp(-im)) / 2;\r\n\r\n        return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);\r\n    },\r\n\r\n    IMCOSH: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        let realInput = Math.cos(im) * (Math.exp(real) + Math.exp(-real)) / 2;\r\n        let imaginaryInput = -Math.sin(im) * (Math.exp(real) - Math.exp(-real)) / 2;\r\n        return EngineeringFunctions.COMPLEX(realInput, -imaginaryInput, unit);\r\n    },\r\n\r\n    IMCOT: (iNumber) => {\r\n        iNumber = H.accept(iNumber);\r\n        let real = EngineeringFunctions.IMCOS(iNumber);\r\n        let imaginary = EngineeringFunctions.IMSIN(iNumber);\r\n        return EngineeringFunctions.IMDIV(real, imaginary);\r\n    },\r\n\r\n    IMCSC: (iNumber) => {\r\n        iNumber = H.accept(iNumber);\r\n        return EngineeringFunctions.IMDIV('1', EngineeringFunctions.IMSIN(iNumber));\r\n    },\r\n\r\n    IMCSCH: (iNumber) => {\r\n        iNumber = H.accept(iNumber);\r\n        return EngineeringFunctions.IMDIV('1', EngineeringFunctions.IMSINH(iNumber));\r\n    },\r\n\r\n    IMDIV: (iNumber1, iNumber2) => {\r\n        const res1 = parseIM(iNumber1);\r\n        const a = res1.real, b = res1.im, unit1 = res1.unit;\r\n\r\n        const res2 = parseIM(iNumber2);\r\n        const c = res2.real, d = res2.im, unit2 = res2.unit;\r\n\r\n        if (c === 0 && d === 0 || unit1 !== unit2) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        let unit = unit1;\r\n\r\n        let denominator = Math.pow(c, 2) + Math.pow(d, 2);\r\n        return EngineeringFunctions.COMPLEX((a * c + b * d) / denominator, (b * c - a * d) / denominator, unit);\r\n    },\r\n\r\n    IMEXP: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        // return exponential of complex number\r\n        let e = Math.exp(real);\r\n        return EngineeringFunctions.COMPLEX(e * Math.cos(im), e * Math.sin(im), unit)\r\n    },\r\n\r\n    IMLN: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        return EngineeringFunctions.COMPLEX(Math.log(Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2))),\r\n            Math.atan(im / real), unit);\r\n    },\r\n\r\n    IMLOG10: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        let realInput = Math.log(Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2))) / Math.log(10);\r\n        let imaginaryInput = Math.atan(im / real) / Math.log(10);\r\n        return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);\r\n    },\r\n\r\n    IMLOG2: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        let realInput = Math.log(Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2))) / Math.log(2);\r\n        let imaginaryInput = Math.atan(im / real) / Math.log(2);\r\n        return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);\r\n    },\r\n\r\n    IMPOWER: (iNumber, number) => {\r\n        let {unit} = parseIM(iNumber);\r\n        number = H.accept(number, Types.NUMBER_NO_BOOLEAN);\r\n\r\n        // calculate power of modules\r\n        let p = Math.pow(EngineeringFunctions.IMABS(iNumber), number);\r\n        // calculate argument\r\n        let t = EngineeringFunctions.IMARGUMENT(iNumber);\r\n\r\n        let real = p * Math.cos(number * t);\r\n        let imaginary = p * Math.sin(number * t);\r\n        return EngineeringFunctions.COMPLEX(real, imaginary, unit);\r\n    },\r\n\r\n    IMPRODUCT: (...params) => {\r\n        let result;\r\n        let i = 0;\r\n        H.flattenParams(params, null, false, (item) => {\r\n            if (i === 0) {\r\n                result = H.accept(item);\r\n                parseIM(result);\r\n            } else {\r\n                const res1 = parseIM(result);\r\n                const a = res1.real, b = res1.im, unit1 = res1.unit;\r\n                const res2 = parseIM(item);\r\n                const c = res2.real, d = res2.im, unit2 = res2.unit;\r\n                if (unit1 !== unit2)\r\n                    throw FormulaError.VALUE;\r\n                result = EngineeringFunctions.COMPLEX(a * c - b * d, a * d + b * c);\r\n            }\r\n            i++;\r\n        }, 1);\r\n        return result;\r\n    },\r\n\r\n    IMREAL: (iNumber) => {\r\n        return parseIM(iNumber).real;\r\n    },\r\n\r\n    IMSEC: (iNumber) => {\r\n        return EngineeringFunctions.IMDIV('1', EngineeringFunctions.IMCOS(iNumber));\r\n    },\r\n\r\n    IMSECH: (iNumber) => {\r\n        return EngineeringFunctions.IMDIV('1', EngineeringFunctions.IMCOSH(iNumber));\r\n    },\r\n\r\n    IMSIN: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n\r\n        let realInput = Math.sin(real) * (Math.exp(im) + Math.exp(-im)) / 2;\r\n        let imaginaryInput = Math.cos(real) * (Math.exp(im) - Math.exp(-im)) / 2;\r\n        return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);\r\n    },\r\n\r\n    IMSINH: (iNumber) => {\r\n        const {real, im, unit} = parseIM(iNumber);\r\n        let realInput = Math.cos(im) * (Math.exp(real) - Math.exp(-real)) / 2;\r\n        let imaginaryInput = Math.sin(im) * (Math.exp(real) + Math.exp(-real)) / 2;\r\n        return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);\r\n    },\r\n\r\n    IMSQRT: (iNumber) => {\r\n        const {unit} = parseIM(iNumber);\r\n        // calculate the power of modulus\r\n        let power = Math.sqrt(EngineeringFunctions.IMABS(iNumber));\r\n        // calculate argument\r\n        let argument = EngineeringFunctions.IMARGUMENT(iNumber);\r\n        return EngineeringFunctions.COMPLEX(power * Math.cos(argument / 2), power * Math.sin(argument / 2), unit);\r\n    },\r\n\r\n    IMSUB: (iNumber1, iNumber2) => {\r\n        const res1 = parseIM(iNumber1);\r\n        const a = res1.real, b = res1.im, unit1 = res1.unit;\r\n        const res2 = parseIM(iNumber2);\r\n        const c = res2.real, d = res2.im, unit2 = res2.unit;\r\n\r\n        if (unit1 !== unit2) {\r\n            throw FormulaError.VALUE;\r\n        }\r\n        return EngineeringFunctions.COMPLEX(a - c, b - d, unit1);\r\n    },\r\n\r\n    IMSUM: (...params) => {\r\n        let realSum = 0, imSum = 0, prevUnit;\r\n        H.flattenParams(params, null, false, (item) => {\r\n            const {real, im, unit} = parseIM(item);\r\n            if (!prevUnit) prevUnit = unit;\r\n            if (prevUnit !== unit)\r\n                throw FormulaError.VALUE;\r\n            realSum += real;\r\n            imSum += im;\r\n        });\r\n        return EngineeringFunctions.COMPLEX(realSum, imSum, prevUnit);\r\n    },\r\n\r\n    IMTAN: (iNumber) => {\r\n        const {unit} = parseIM(iNumber);\r\n        return EngineeringFunctions.IMDIV(EngineeringFunctions.IMSIN(iNumber), EngineeringFunctions.IMCOS(iNumber), unit);\r\n    },\r\n\r\n    // FIXME: need to check the test cases\r\n    OCT2BIN: (number, places) => {\r\n        // office: If number is not a valid octal number, OCT2BIN returns the #NUM! error value.\r\n        // office: If places is nonnumeric, OCT2BIN returns the #VALUE! error value.\r\n        number = H.accept(number, Types.STRING);\r\n        places = H.accept(places, Types.NUMBER, null);\r\n\r\n        // 1. If number's length larger than 10, returns #NUM!\r\n        if (number.length > 10) {\r\n            throw FormulaError.NUM\r\n        }\r\n        // In microsoft Excel, if places is larger than 10, it will return #NUM!\r\n        if (places > 10) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // 2. office: If places is negative, OCT2BIN returns the #NUM! error value.\r\n        if (places !== null && places < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // if places is not an integer, it is truncated\r\n        // office: If places is not an integer, it is truncated.\r\n        places = Math.trunc(places);\r\n\r\n        // to check if the Oct number is negative\r\n        let isNegative = (number.length === 10 && number.substring(0, 1) === '7');\r\n        // convert OCT to DEC\r\n        let toDecimal = EngineeringFunctions.OCT2DEC(number);\r\n        // 2.\r\n        // office: If number is negative, it cannot be less than 7777777000, and if number is positive, it cannot be greater than 777.\r\n        // MiN_BIN = -512, MAX_BIN = 511\r\n        if (toDecimal < MIN_BIN || toDecimal > MAX_BIN) {\r\n            return FormulaError.NUM;\r\n        }\r\n        // if number is negative, ignores places and return a 10-character binary number\r\n        // office: If number is negative, OCT2BIN ignores places and returns a 10-character binary number.\r\n        if (isNegative) {\r\n            return '1' + TextFunctions.REPT('0', 9 - (512 + toDecimal).toString(2).length) + (512 + toDecimal).toString(2);\r\n        }\r\n\r\n        // convert DEC to BIN\r\n        let result = toDecimal.toString(2);\r\n\r\n\r\n        //if (places === null) {\r\n        if (places === 0) {\r\n            return result;\r\n        }\r\n\r\n        // office: If OCT2BIN requires more than places characters, it returns the #NUM! error value.\r\n        if (places < result.length) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return TextFunctions.REPT('0', places - result.length) + result;\r\n    },\r\n\r\n    OCT2DEC: (number) => {\r\n        number = H.accept(number, Types.STRING);\r\n        // In microsoft Excel, if number contains more than ten characters (10 digits), it will return #NUM!\r\n        if (number.length > 10) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If number is not a valid octal number, OCT2DEC returns the #NUM! error value.\r\n        for (const n of number) {\r\n            if (n < '0' || n > '7') {\r\n                throw FormulaError.NUM;\r\n            }\r\n        }\r\n        // convert to DEC\r\n        let result = parseInt(number, 8);\r\n        return (result >= 536870912) ? result - 1073741824 : result;\r\n        //  536870912(4000000000) : -536870912;   1073741823(7777777777) : -1\r\n    },\r\n\r\n    OCT2HEX: (number, places) => {\r\n        number = H.accept(number, Types.STRING);\r\n        places = H.accept(places, Types.NUMBER_NO_BOOLEAN, null);\r\n        if (number.length > 10) {\r\n            throw FormulaError.NUM\r\n        }\r\n        // office: If number is not a valid octal number, OCT2DEC returns the #NUM! error value.\r\n        for (const n of number) {\r\n            if (n < '0' || n > '7') {\r\n                throw FormulaError.NUM;\r\n            }\r\n        }\r\n        // if places is not an integer, it is truncated\r\n        places = Math.trunc(places);\r\n        // office: If places is negative, OCT2HEX returns the #NUM! error value.\r\n        if (places < 0 || places > 10) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // convert OCT to DEC\r\n        let toDecimal = EngineeringFunctions.OCT2DEC(number);\r\n\r\n        // convert DEC to HEX\r\n        // let toHex = EngineeringFunctions.DEC2HEX(toDecimal, places);\r\n        let toHex = EngineeringFunctions.DEC2HEX(toDecimal);\r\n        //if (places === null) {\r\n        if (places === 0) {\r\n            return toHex;\r\n        }\r\n        if (places < toHex.length) {\r\n            throw FormulaError.NUM;\r\n        } else {\r\n            return TextFunctions.REPT('0', places - toHex.length) + toHex;\r\n        }\r\n    },\r\n};\r\n\r\nmodule.exports = EngineeringFunctions;\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types, WildCard, Address} = require('../helpers');\r\nconst Collection = require('../../grammar/type/collection');\r\nconst H = FormulaHelpers;\r\n\r\nconst ReferenceFunctions = {\r\n\r\n    ADDRESS: (rowNumber, columnNumber, absNum, a1, sheetText) => {\r\n        rowNumber = H.accept(rowNumber, Types.NUMBER);\r\n        columnNumber = H.accept(columnNumber, Types.NUMBER);\r\n        absNum = H.accept(absNum, Types.NUMBER, 1);\r\n        a1 = H.accept(a1, Types.BOOLEAN, true);\r\n        sheetText = H.accept(sheetText, Types.STRING, '');\r\n\r\n        if (rowNumber < 1 || columnNumber < 1 || absNum < 1 || absNum > 4)\r\n            throw FormulaError.VALUE;\r\n\r\n        let result = '';\r\n        if (sheetText.length > 0) {\r\n            if (/[^A-Za-z_.\\d\\u007F-\\uFFFF]/.test(sheetText)) {\r\n                result += `'${sheetText}'!`;\r\n            } else {\r\n                result += sheetText + '!';\r\n            }\r\n        }\r\n        if (a1) {\r\n            // A1 style\r\n            result += (absNum === 1 || absNum === 3) ? '$' : '';\r\n            result += Address.columnNumberToName(columnNumber);\r\n            result += (absNum === 1 || absNum === 2) ? '$' : '';\r\n            result += rowNumber;\r\n        } else {\r\n            // R1C1 style\r\n            result += 'R';\r\n            result += (absNum === 4 || absNum === 3) ? `[${rowNumber}]` : rowNumber;\r\n            result += 'C';\r\n            result += (absNum === 4 || absNum === 2) ? `[${columnNumber}]` : columnNumber;\r\n        }\r\n        return result;\r\n    },\r\n\r\n    AREAS: refs => {\r\n        refs = H.accept(refs);\r\n        if (refs instanceof Collection) {\r\n            return refs.length;\r\n        }\r\n        return 1;\r\n    },\r\n\r\n    CHOOSE: (indexNum, ...values) => {\r\n\r\n    },\r\n\r\n    // Special\r\n    COLUMN: (context, obj) => {\r\n        if (obj == null) {\r\n            if (context.position.col != null)\r\n                return context.position.col;\r\n            else\r\n                throw Error('FormulaParser.parse is called without position parameter.')\r\n        } else {\r\n            if (typeof obj !== 'object' || Array.isArray(obj))\r\n                throw FormulaError.VALUE;\r\n            if (H.isCellRef(obj)) {\r\n                return obj.ref.col;\r\n            } else if (H.isRangeRef(obj)) {\r\n                return obj.ref.from.col;\r\n            } else {\r\n                throw Error('ReferenceFunctions.COLUMN should not reach here.')\r\n            }\r\n        }\r\n    },\r\n\r\n    // Special\r\n    COLUMNS: (context, obj) => {\r\n        if (obj == null) {\r\n            throw Error('COLUMNS requires one argument');\r\n        }\r\n        if (typeof obj != 'object' || Array.isArray(obj))\r\n            throw FormulaError.VALUE;\r\n        if (H.isCellRef(obj)) {\r\n            return 1;\r\n        } else if (H.isRangeRef(obj)) {\r\n            return Math.abs(obj.ref.from.col - obj.ref.to.col) + 1;\r\n        } else {\r\n            throw Error('ReferenceFunctions.COLUMNS should not reach here.')\r\n        }\r\n    },\r\n\r\n    HLOOKUP: (lookupValue, tableArray, rowIndexNum, rangeLookup) => {\r\n        // preserve type of lookupValue\r\n        lookupValue = H.accept(lookupValue);\r\n        try {\r\n            tableArray = H.accept(tableArray, Types.ARRAY, undefined, false);\r\n        } catch (e) {\r\n            // catch #VALUE! and throw #N/A\r\n            if (e instanceof FormulaError)\r\n                throw FormulaError.NA;\r\n            throw e;\r\n        }\r\n        rowIndexNum = H.accept(rowIndexNum, Types.NUMBER);\r\n        rangeLookup = H.accept(rangeLookup, Types.BOOLEAN, true);\r\n\r\n        // check if rowIndexNum out of bound\r\n        if (rowIndexNum < 1)\r\n            throw FormulaError.VALUE;\r\n        if (tableArray[rowIndexNum - 1] === undefined)\r\n            throw FormulaError.REF;\r\n\r\n        const lookupType = typeof lookupValue; // 'number', 'string', 'boolean'\r\n\r\n        // approximate lookup (assume the array is sorted)\r\n        if (rangeLookup) {\r\n            let prevValue = lookupType === typeof tableArray[0][0] ? tableArray[0][0] : null;\r\n            for (let i = 1; i < tableArray[0].length; i++) {\r\n                const currValue = tableArray[0][i];\r\n                const type = typeof currValue;\r\n                // skip the value if type does not match\r\n                if (type !== lookupType)\r\n                    continue;\r\n                // if the previous two values are greater than lookup value, throw #N/A\r\n                if (prevValue > lookupValue && currValue > lookupValue) {\r\n                    throw FormulaError.NA;\r\n                }\r\n                if (currValue === lookupValue)\r\n                    return tableArray[rowIndexNum - 1][i];\r\n                // if previous value <= lookup value and current value > lookup value\r\n                if (prevValue != null && currValue > lookupValue && prevValue <= lookupValue) {\r\n                    return tableArray[rowIndexNum - 1][i - 1];\r\n                }\r\n                prevValue = currValue;\r\n            }\r\n            if (prevValue == null)\r\n                throw FormulaError.NA;\r\n            return prevValue;\r\n        }\r\n        // exact lookup with wildcard support\r\n        else {\r\n            let index = -1;\r\n            if (WildCard.isWildCard(lookupValue)) {\r\n                index = tableArray[0].findIndex(item => {\r\n                    return WildCard.toRegex(lookupValue, 'i').test(item);\r\n                });\r\n            } else {\r\n                index = tableArray[0].findIndex(item => {\r\n                    return item === lookupValue;\r\n                });\r\n            }\r\n            // the exact match is not found\r\n            if (index === -1) throw FormulaError.NA;\r\n            return tableArray[rowIndexNum - 1][index];\r\n        }\r\n    },\r\n\r\n    // Special\r\n    INDEX: (context, ranges, rowNum, colNum, areaNum) => {\r\n        // retrieve values\r\n        rowNum = context.utils.extractRefValue(rowNum);\r\n        rowNum = {value: rowNum.val, isArray: rowNum.isArray};\r\n        rowNum = H.accept(rowNum, Types.NUMBER);\r\n        rowNum = Math.trunc(rowNum);\r\n\r\n        if (colNum == null) {\r\n            colNum = 1;\r\n        } else {\r\n            colNum = context.utils.extractRefValue(colNum);\r\n            colNum = {value: colNum.val, isArray: colNum.isArray};\r\n            colNum = H.accept(colNum, Types.NUMBER, 1);\r\n            colNum = Math.trunc(colNum);\r\n        }\r\n\r\n        if (areaNum == null) {\r\n            areaNum = 1;\r\n        } else {\r\n            areaNum = context.utils.extractRefValue(areaNum);\r\n            areaNum = {value: areaNum.val, isArray: areaNum.isArray};\r\n            areaNum = H.accept(areaNum, Types.NUMBER, 1);\r\n            areaNum = Math.trunc(areaNum);\r\n        }\r\n\r\n        // get the range area that we want to index\r\n        // ranges can be cell ref, range ref or array constant\r\n        let range = ranges;\r\n        // many ranges (Reference form)\r\n        if (ranges instanceof Collection) {\r\n            range = ranges.refs[areaNum - 1];\r\n        } else if (areaNum > 1) {\r\n            throw FormulaError.REF;\r\n        }\r\n\r\n        if (rowNum === 0 && colNum === 0) {\r\n            return range;\r\n        }\r\n\r\n        // query the whole column\r\n        if (rowNum === 0) {\r\n            if (H.isRangeRef(range)) {\r\n                if (range.ref.to.col - range.ref.from.col < colNum - 1)\r\n                    throw FormulaError.REF;\r\n                range.ref.from.col += colNum - 1;\r\n                range.ref.to.col = range.ref.from.col;\r\n                return range;\r\n            } else if (Array.isArray(range)) {\r\n                const res = [];\r\n                range.forEach(row => res.push([row[colNum - 1]]));\r\n                return res;\r\n            }\r\n        }\r\n        // query the whole row\r\n        if (colNum === 0) {\r\n            if (H.isRangeRef(range)) {\r\n                if (range.ref.to.row - range.ref.from.row < rowNum - 1)\r\n                    throw FormulaError.REF;\r\n                range.ref.from.row += rowNum - 1;\r\n                range.ref.to.row =  range.ref.from.row;\r\n                return range;\r\n            } else if (Array.isArray(range)) {\r\n                return range[colNum - 1];\r\n            }\r\n        }\r\n        // query single cell\r\n        if (rowNum !== 0 && colNum !== 0) {\r\n            // range reference\r\n            if (H.isRangeRef(range)) {\r\n                range = range.ref;\r\n                if (range.to.row - range.from.row < rowNum - 1 || range.to.col - range.from.col < colNum - 1)\r\n                    throw FormulaError.REF;\r\n                return {ref: {row: range.from.row + rowNum - 1, col: range.from.col + colNum - 1}};\r\n            }\r\n            // cell reference\r\n            else if (H.isCellRef(range)) {\r\n                range = range.ref;\r\n                if (rowNum > 1 || colNum > 1)\r\n                    throw FormulaError.REF;\r\n                return {ref: {row: range.row + rowNum - 1, col: range.col + colNum - 1}};\r\n            }\r\n            // array constant\r\n            else if (Array.isArray(range)) {\r\n                if (range.length < rowNum || range[0].length < colNum)\r\n                    throw FormulaError.REF;\r\n                return range[rowNum - 1][colNum - 1];\r\n            }\r\n        }\r\n    },\r\n\r\n    MATCH: () => {\r\n\r\n    },\r\n\r\n    // Special\r\n    ROW: (context, obj) => {\r\n        if (obj == null) {\r\n            if (context.position.row != null)\r\n                return context.position.row;\r\n            else\r\n                throw Error('FormulaParser.parse is called without position parameter.')\r\n        } else {\r\n            if (typeof obj !== 'object' || Array.isArray(obj))\r\n                throw FormulaError.VALUE;\r\n            if (H.isCellRef(obj)) {\r\n                return obj.ref.row;\r\n            } else if (H.isRangeRef(obj)) {\r\n                return obj.ref.from.row;\r\n            } else {\r\n                throw Error('ReferenceFunctions.ROW should not reach here.')\r\n            }\r\n        }\r\n    },\r\n\r\n    // Special\r\n    ROWS: (context, obj) => {\r\n        if (obj == null) {\r\n            throw Error('ROWS requires one argument');\r\n        }\r\n        if (typeof obj != 'object' || Array.isArray(obj))\r\n            throw FormulaError.VALUE;\r\n        if (H.isCellRef(obj)) {\r\n            return 1;\r\n        } else if (H.isRangeRef(obj)) {\r\n            return Math.abs(obj.ref.from.row - obj.ref.to.row) + 1;\r\n        } else {\r\n            throw Error('ReferenceFunctions.ROWS should not reach here.')\r\n        }\r\n    },\r\n\r\n    TRANSPOSE: (array) => {\r\n        array = H.accept(array, Types.ARRAY, undefined, false);\r\n        // https://github.com/numbers/numbers.js/blob/master/lib/numbers/matrix.js#L171\r\n        const result = [];\r\n\r\n        for (let i = 0; i < array[0].length; i++) {\r\n            result[i] = [];\r\n\r\n            for (let j = 0; j < array.length; j++) {\r\n                result[i][j] = array[j][i];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    VLOOKUP: (lookupValue, tableArray, colIndexNum, rangeLookup) => {\r\n        // preserve type of lookupValue\r\n        lookupValue = H.accept(lookupValue);\r\n        try {\r\n            tableArray = H.accept(tableArray, Types.ARRAY, undefined, false);\r\n        } catch (e) {\r\n            // catch #VALUE! and throw #N/A\r\n            if (e instanceof FormulaError)\r\n                throw FormulaError.NA;\r\n            throw e;\r\n        }\r\n        colIndexNum = H.accept(colIndexNum, Types.NUMBER);\r\n        rangeLookup = H.accept(rangeLookup, Types.BOOLEAN, true);\r\n\r\n        // check if colIndexNum out of bound\r\n        if (colIndexNum < 1)\r\n            throw FormulaError.VALUE;\r\n        if (tableArray[0][colIndexNum - 1] === undefined)\r\n            throw FormulaError.REF;\r\n\r\n        const lookupType = typeof lookupValue; // 'number', 'string', 'boolean'\r\n\r\n        // approximate lookup (assume the array is sorted)\r\n        if (rangeLookup) {\r\n            let prevValue = lookupType === typeof tableArray[0][0] ? tableArray[0][0] : null;\r\n            for (let i = 1; i < tableArray.length; i++) {\r\n                const currRow = tableArray[i];\r\n                const currValue = tableArray[i][0];\r\n                const type = typeof currValue;\r\n                // skip the value if type does not match\r\n                if (type !== lookupType)\r\n                    continue;\r\n                // if the previous two values are greater than lookup value, throw #N/A\r\n                if (prevValue > lookupValue && currValue > lookupValue) {\r\n                    throw FormulaError.NA;\r\n                }\r\n                if (currValue === lookupValue)\r\n                    return currRow[colIndexNum - 1];\r\n                // if previous value <= lookup value and current value > lookup value\r\n                if (prevValue != null && currValue > lookupValue && prevValue <= lookupValue) {\r\n                    return tableArray[i - 1][colIndexNum - 1];\r\n                }\r\n                prevValue = currValue;\r\n            }\r\n            if (prevValue == null)\r\n                throw FormulaError.NA;\r\n            return prevValue;\r\n        }\r\n        // exact lookup with wildcard support\r\n        else {\r\n            let index = -1;\r\n            if (WildCard.isWildCard(lookupValue)) {\r\n                index = tableArray.findIndex(currRow => {\r\n                    return WildCard.toRegex(lookupValue, 'i').test(currRow[0]);\r\n                });\r\n            } else {\r\n                index = tableArray.findIndex(currRow => {\r\n                    return currRow[0] === lookupValue;\r\n                });\r\n            }\r\n            // the exact match is not found\r\n            if (index === -1) throw FormulaError.NA;\r\n            return tableArray[index][colIndexNum - 1];\r\n        }\r\n    },\r\n};\r\n\r\nmodule.exports = ReferenceFunctions;\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types} = require('../helpers');\r\nconst H = FormulaHelpers;\r\n\r\nconst error2Number = {\r\n    '#NULL!': 1, '#DIV/0!': 2, '#VALUE!': 3, '#REF!': 4, '#NAME?': 5,\r\n    '#NUM!': 6, '#N/A': 7\r\n};\r\n\r\nconst InfoFunctions = {\r\n\r\n    CELL: (infoType, reference) => {\r\n        // throw FormulaError.NOT_IMPLEMENTED('CELL');\r\n    },\r\n\r\n    'ERROR.TYPE': (value) => {\r\n        value = H.accept(value);\r\n        if ( value instanceof FormulaError)\r\n            return error2Number[value.toString()];\r\n        throw FormulaError.NA;\r\n    },\r\n\r\n    INFO: () => {\r\n    },\r\n\r\n    ISBLANK: (value) => {\r\n        if (!value.ref)\r\n            return false;\r\n        // null and undefined are also blank\r\n        return value.value == null || value.value === '';\r\n    },\r\n\r\n    ISERR: (value) => {\r\n        value = H.accept(value);\r\n        return value instanceof FormulaError && value.toString() !== '#N/A';\r\n    },\r\n\r\n    ISERROR: (value) => {\r\n        value = H.accept(value);\r\n        return value instanceof FormulaError;\r\n    },\r\n\r\n    ISEVEN: number => {\r\n        number = H.accept(number, Types.NUMBER);\r\n        number = Math.trunc(number);\r\n        return number % 2 === 0;\r\n    },\r\n\r\n    ISLOGICAL: (value) => {\r\n        value = H.accept(value);\r\n        return typeof value === 'boolean';\r\n    },\r\n\r\n    ISNA: (value) => {\r\n        value = H.accept(value);\r\n        return value instanceof FormulaError && value.toString() === '#N/A';\r\n    },\r\n\r\n    ISNONTEXT: (value) => {\r\n        value = H.accept(value);\r\n        return typeof value !== 'string';\r\n    },\r\n\r\n    ISNUMBER: (value) => {\r\n        value = H.accept(value);\r\n        return typeof value === \"number\";\r\n    },\r\n\r\n    ISREF: (value) => {\r\n        if (!value.ref)\r\n            return false;\r\n        if (H.isCellRef(value) && (value.ref.row > 1048576 || value.ref.col > 16384)) {\r\n            return false;\r\n        }\r\n        if (H.isRangeRef(value) && (value.ref.from.row > 1048576 || value.ref.from.col > 16384\r\n            || value.ref.to.row > 1048576 || value.ref.to.col > 16384)) {\r\n            return false;\r\n        }\r\n        value = H.accept(value);\r\n        return !(value instanceof FormulaError && value.toString() === '#REF!');\r\n    },\r\n\r\n    ISTEXT: (value) => {\r\n        value = H.accept(value);\r\n        return typeof value === 'string';\r\n    },\r\n\r\n    N: value => {\r\n        value = H.accept(value);\r\n        const type = typeof value;\r\n        if (type === 'number')\r\n            return value;\r\n        else if (type === \"boolean\")\r\n            return Number(value);\r\n        else if (value instanceof FormulaError)\r\n            throw value;\r\n        return 0;\r\n    },\r\n\r\n    NA: () => {\r\n        throw FormulaError.NA;\r\n    },\r\n\r\n    TYPE: value => {\r\n        // a reference\r\n        if (value.ref) {\r\n            if (H.isRangeRef(value)) {\r\n                return 16;\r\n            } else if (H.isCellRef(value)) {\r\n                value = H.accept(value);\r\n                // empty cell is number type\r\n                if (typeof value === \"string\" && value.length === 0)\r\n                    return 1;\r\n            }\r\n        }\r\n        value = H.accept(value);\r\n        const type = typeof value;\r\n        if (type === 'number')\r\n            return 1;\r\n        else if (type === \"string\")\r\n            return 2;\r\n        else if (type === \"boolean\")\r\n            return 4;\r\n        else if (value instanceof FormulaError)\r\n            return 16;\r\n        else if (Array.isArray(value))\r\n            return 64;\r\n    },\r\n};\r\n\r\n\r\nmodule.exports = InfoFunctions;\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types} = require('../helpers');\r\nconst H = FormulaHelpers;\r\nconst jStat = require(\"jstat\");\r\nconst MathFunctions = require('./math');\r\nconst SQRT2PI = 2.5066282746310002;\r\n\r\nconst DistributionFunctions = {\r\n    'BETA.DIST': (x, alpha, beta, cumulative, a, b) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        beta = H.accept(beta, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        a = H.accept(a, Types.NUMBER, 0);\r\n        b = H.accept(b, Types.NUMBER, 1);\r\n        if (alpha <= 0 || beta <= 0 || x < a || x > b || a === b)\r\n            throw FormulaError.NUM;\r\n\r\n        x = (x - a) / (b - a);\r\n        return cumulative ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta) / (b - a);\r\n    },\r\n\r\n    'BETA.INV': (probability, alpha, beta, a, b) => {\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        beta = H.accept(beta, Types.NUMBER);\r\n        a = H.accept(a, Types.NUMBER, 0);\r\n        b = H.accept(b, Types.NUMBER, 1);\r\n        if (alpha <= 0 || beta <= 0 || probability <= 0 || probability > 1)\r\n            throw FormulaError.NUM;\r\n        return jStat.beta.inv(probability, alpha, beta) * (b - a) + a;\r\n    },\r\n\r\n    'BINOM.DIST': (numberS, trials, probabilityS, cumulative) => {\r\n        numberS = H.accept(numberS, Types.NUMBER);\r\n        trials = H.accept(trials, Types.NUMBER);\r\n        probabilityS = H.accept(probabilityS, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        if (trials < 0 || probabilityS < 0 || probabilityS > 1 || numberS < 0 || numberS > trials)\r\n            throw FormulaError.NUM;\r\n\r\n        return cumulative ? jStat.binomial.cdf(numberS, trials, probabilityS)\r\n            : jStat.binomial.pdf(numberS, trials, probabilityS);\r\n    },\r\n\r\n    'BINOM.DIST.RANGE': (trials, probabilityS, numberS, numberS2) => {\r\n        trials = H.accept(trials, Types.NUMBER);\r\n        probabilityS = H.accept(probabilityS, Types.NUMBER);\r\n        numberS = H.accept(numberS, Types.NUMBER);\r\n        numberS2 = H.accept(numberS2, Types.NUMBER, numberS);\r\n        if (trials < 0 || probabilityS < 0 || probabilityS > 1 || numberS < 0 || numberS > trials || numberS2 < numberS || numberS2 > trials)\r\n            throw FormulaError.NUM;\r\n\r\n        let result = 0;\r\n        for (let i = numberS; i <= numberS2; i++) {\r\n            result += MathFunctions.COMBIN(trials, i) * Math.pow(probabilityS, i) * Math.pow(1 - probabilityS, trials - i);\r\n        }\r\n        return result;\r\n    },\r\n\r\n    'BINOM.INV': (trials, probabilityS, alpha) => {\r\n        trials = H.accept(trials, Types.NUMBER);\r\n        probabilityS = H.accept(probabilityS, Types.NUMBER);\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        if (trials < 0 || probabilityS < 0 || probabilityS > 1 || alpha < 0 || alpha > 1)\r\n            throw FormulaError.NUM;\r\n\r\n        let x = 0;\r\n        while (x <= trials) {\r\n            if (jStat.binomial.cdf(x, trials, probabilityS) >= alpha) {\r\n                return x;\r\n            }\r\n            x++;\r\n        }\r\n    },\r\n\r\n    'CHISQ.DIST': (x, degFreedom, cumulative) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        degFreedom = H.accept(degFreedom, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.NUMBER);\r\n        degFreedom = Math.trunc(degFreedom);\r\n        if (x < 0 || degFreedom < 1 || degFreedom > 10 ** 10)\r\n            throw FormulaError.NUM;\r\n\r\n        return cumulative ? jStat.chisquare.cdf(x, degFreedom) : jStat.chisquare.pdf(x, degFreedom);\r\n    },\r\n\r\n    'CHISQ.DIST.RT': (x, degFreedom) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        degFreedom = H.accept(degFreedom, Types.NUMBER);\r\n        degFreedom = Math.trunc(degFreedom);\r\n        if (x < 0 || degFreedom < 1 || degFreedom > 10 ** 10)\r\n            throw FormulaError.NUM;\r\n\r\n        return 1 - jStat.chisquare.cdf(x, degFreedom);\r\n    },\r\n\r\n    'CHISQ.INV': (probability, degFreedom) => {\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        degFreedom = H.accept(degFreedom, Types.NUMBER);\r\n        degFreedom = Math.trunc(degFreedom);\r\n        if (probability < 0 || probability > 1 || degFreedom < 1 || degFreedom > 10 ** 10)\r\n            throw FormulaError.NUM;\r\n\r\n        return jStat.chisquare.inv(probability, degFreedom);\r\n    },\r\n\r\n    'CHISQ.INV.RT': (probability, degFreedom) => {\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        degFreedom = H.accept(degFreedom, Types.NUMBER);\r\n        degFreedom = Math.trunc(degFreedom);\r\n        if (probability < 0 || probability > 1 || degFreedom < 1 || degFreedom > 10 ** 10)\r\n            throw FormulaError.NUM;\r\n\r\n        return jStat.chisquare.inv(1 - probability, degFreedom);\r\n    },\r\n\r\n    'CHISQ.TEST': (actualRange, expectedRange) => {\r\n        const actual = H.accept(actualRange, Types.ARRAY, undefined, false, false);\r\n        const expected = H.accept(expectedRange, Types.ARRAY, undefined, false, false);\r\n\r\n        if (actual.length !== expected.length || actual[0].length !== expected[0].length\r\n            || actual.length === 1 && actual[0].length === 1)\r\n            throw FormulaError.NA;\r\n\r\n        const row = actual.length;\r\n        const col = actual[0].length;\r\n        let dof = (row - 1) * (col - 1);\r\n        if (row === 1)\r\n            dof = col - 1;\r\n        else\r\n            dof = row - 1;\r\n        let xsqr = 0;\r\n\r\n        for (let i = 0; i < row; i++) {\r\n            for (let j = 0; j < col; j++) {\r\n                if (typeof actual[i][j] !== \"number\" || typeof expected[i][j] !== \"number\")\r\n                    continue;\r\n                if (expected[i][j] === 0) throw FormulaError.DIV0;\r\n                xsqr += Math.pow((actual[i][j] - expected[i][j]), 2) / expected[i][j];\r\n            }\r\n        }\r\n\r\n        // Get independent by X square and its degree of freedom\r\n        let p = Math.exp(-0.5 * xsqr);\r\n        if ((dof % 2) === 1) {\r\n            p = p * Math.sqrt(2 * xsqr / Math.PI);\r\n        }\r\n        let k = dof;\r\n        while (k >= 2) {\r\n            p = p * xsqr / k;\r\n            k = k - 2;\r\n        }\r\n        let t = p, a = dof;\r\n        while (t > 0.000000000000001 * p) {\r\n            a = a + 2;\r\n            t = t * xsqr / a;\r\n            p = p + t;\r\n        }\r\n        return 1 - p;\r\n    },\r\n\r\n    'CONFIDENCE.NORM': (alpha, std, size) => {\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        std = H.accept(std, Types.NUMBER);\r\n        size = H.accept(size, Types.NUMBER);\r\n        size = Math.trunc(size);\r\n        if (alpha <= 0 || alpha >= 1 || std <= 0 || size < 1)\r\n            throw FormulaError.NUM;\r\n        return jStat.normalci(1, alpha, std, size)[1] - 1;\r\n    },\r\n\r\n    'CONFIDENCE.T': (alpha, std, size) => {\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        std = H.accept(std, Types.NUMBER);\r\n        size = H.accept(size, Types.NUMBER);\r\n        size = Math.trunc(size);\r\n        if (alpha <= 0 || alpha >= 1 || std <= 0 || size < 1)\r\n            throw FormulaError.NUM;\r\n        if (size === 1)\r\n            throw FormulaError.DIV0;\r\n        return jStat.tci(1, alpha, std, size)[1] - 1;\r\n    },\r\n\r\n    CORREL: (array1, array2) => {\r\n        array1 = H.accept(array1, Types.ARRAY, undefined, true, true);\r\n        array2 = H.accept(array2, Types.ARRAY, undefined, true, true);\r\n        if (array1.length !== array2.length)\r\n            throw FormulaError.NA;\r\n\r\n        // filter out values that are not number\r\n        const filterArr1 = [], filterArr2 = [];\r\n        for (let i = 0; i < array1.length; i++) {\r\n            if (typeof array1[i] !== \"number\" || typeof array2[i] !== \"number\")\r\n                continue;\r\n            filterArr1.push(array1[i]);\r\n            filterArr2.push(array2[i]);\r\n        }\r\n        if (filterArr1.length <= 1)\r\n            throw FormulaError.DIV0;\r\n\r\n        return jStat.corrcoeff(filterArr1, filterArr2);\r\n    },\r\n\r\n    'COVARIANCE.P': (array1, array2) => {\r\n        array1 = H.accept(array1, Types.ARRAY, undefined, true, true);\r\n        array2 = H.accept(array2, Types.ARRAY, undefined, true, true);\r\n        if (array1.length !== array2.length)\r\n            throw FormulaError.NA;\r\n\r\n        // filter out values that are not number\r\n        const filterArr1 = [], filterArr2 = [];\r\n        for (let i = 0; i < array1.length; i++) {\r\n            if (typeof array1[i] !== \"number\" || typeof array2[i] !== \"number\")\r\n                continue;\r\n            filterArr1.push(array1[i]);\r\n            filterArr2.push(array2[i]);\r\n        }\r\n        const mean1 = jStat.mean(filterArr1), mean2 = jStat.mean(filterArr2);\r\n        let result = 0;\r\n        for (let i = 0; i < filterArr1.length; i++) {\r\n            result += (filterArr1[i] - mean1) * (filterArr2[i] - mean2);\r\n        }\r\n        return result / filterArr1.length;\r\n    },\r\n\r\n    'COVARIANCE.S': (array1, array2) => {\r\n        array1 = H.accept(array1, Types.ARRAY, undefined, true, true);\r\n        array2 = H.accept(array2, Types.ARRAY, undefined, true, true);\r\n        if (array1.length !== array2.length)\r\n            throw FormulaError.NA;\r\n\r\n        // filter out values that are not number\r\n        const filterArr1 = [], filterArr2 = [];\r\n        for (let i = 0; i < array1.length; i++) {\r\n            if (typeof array1[i] !== \"number\" || typeof array2[i] !== \"number\")\r\n                continue;\r\n            filterArr1.push(array1[i]);\r\n            filterArr2.push(array2[i]);\r\n        }\r\n\r\n        if (filterArr1.length <= 1)\r\n            throw FormulaError.DIV0;\r\n\r\n        return jStat.covariance(filterArr1, filterArr2);\r\n    },\r\n\r\n    DEVSQ: (...numbers) => {\r\n        let sum = 0, x = [];\r\n        // parse number only if the input is literal\r\n        H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {\r\n            if (typeof item === \"number\") {\r\n                sum += item;\r\n                x.push(item);\r\n            }\r\n        });\r\n        const mean = sum / x.length;\r\n        sum = 0;\r\n        for (let i = 0; i < x.length; i++) {\r\n            sum += (x[i] - mean) ** 2;\r\n        }\r\n        return sum;\r\n    },\r\n\r\n    'EXPON.DIST': (x, lambda, cumulative) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        lambda = H.accept(lambda, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        if (x < 0 || lambda <= 0)\r\n            throw FormulaError.NUM;\r\n        return cumulative ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);\r\n    },\r\n\r\n    'F.DIST': (x, d1, d2, cumulative) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        d1 = H.accept(d1, Types.NUMBER);\r\n        d2 = H.accept(d2, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n\r\n        // If x is negative, F.DIST returns the #NUM! error value.\r\n        // If deg_freedom1 < 1, F.DIST returns the #NUM! error value.\r\n        // If deg_freedom2 < 1, F.DIST returns the #NUM! error value.\r\n        if (x < 0 || d1 < 1 || d2 < 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If deg_freedom1 or deg_freedom2 is not an integer, it is truncated.\r\n        d1 = Math.trunc(d1);\r\n        d2 = Math.trunc(d2);\r\n\r\n        return cumulative ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);\r\n    },\r\n\r\n    'F.DIST.RT': (x, d1, d2) => {\r\n        // David\r\n        x = H.accept(x, Types.NUMBER);\r\n        d1 = H.accept(d1, Types.NUMBER);\r\n        d2 = H.accept(d2, Types.NUMBER);\r\n        // If deg_freedom1 < 1 F.DIST.RT returns the #NUM! error value.\r\n        // If deg_freedom2 < 1 F.DIST.RT returns the #NUM! error value.\r\n        // If x is negative, F.DIST.RT returns the #NUM! error value.\r\n        if (x < 0 || d1 < 1 || d2 < 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If deg_freedom1 or deg_freedom2 is not an integer, it is truncated.\r\n        d1 = Math.trunc(d1);\r\n        d2 = Math.trunc(d2);\r\n\r\n        return 1 - jStat.centralF.cdf(x, d1, d2);\r\n    },\r\n\r\n    'F.INV': (probability, d1, d2) => {\r\n        // David\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        d1 = H.accept(d1, Types.NUMBER);\r\n        d2 = H.accept(d2, Types.NUMBER);\r\n        // If probability < 0 or probability > 1, F.INV returns the #NUM! error value.\r\n        if (probability < 0.0 || probability > 1.0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If deg_freedom1 < 1, or deg_freedom2 < 1, F.INV returns the #NUM! error value.\r\n        if (d1 < 1.0 || d2 < 1.0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If deg_freedom1 or deg_freedom2 is not an integer, it is truncated.\r\n        d1 = Math.trunc(d1);\r\n        d2 = Math.trunc(d2);\r\n\r\n        return jStat.centralF.inv(probability, d1, d2);\r\n    },\r\n\r\n    'F.INV.RT': (probability, d1, d2) => {\r\n        // David\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        d1 = H.accept(d1, Types.NUMBER);\r\n        d2 = H.accept(d2, Types.NUMBER);\r\n        // If Probability is < 0 or probability is > 1, F.INV.RT returns the #NUM! error value.\r\n        if (probability < 0.0 || probability > 1.0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If Deg_freedom1 is < 1, or Deg_freedom2 is < 1, F.INV.RT returns the #NUM! error value.\r\n        if (d1 < 1.0 || d1 >= Math.pow(10, 10)) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If Deg_freedom2 is < 1 or Deg_freedom2 is \u2265 10^10, F.INV.RT returns the #NUM! error value.\r\n        if (d2 < 1.0 || d2 >= Math.pow(10, 10)) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If Deg_freedom1 or Deg_freedom2 is not an integer, it is truncated.\r\n        d1 = Math.trunc(d1);\r\n        d2 = Math.trunc(d2);\r\n\r\n        return jStat.centralF.inv(1.0 - probability, d1, d2);\r\n    },\r\n\r\n    /**\r\n     * https://en.wikipedia.org/wiki/F-test_of_equality_of_variances\r\n     */\r\n    'F.TEST': (array1, array2) => {\r\n        array1 = H.accept(array1, Types.ARRAY, undefined, true, true);\r\n        array2 = H.accept(array2, Types.ARRAY, undefined, true, true);\r\n\r\n        // filter out values that are not number\r\n        const x1 = [], x2 = [];\r\n        let x1Mean = 0, x2Mean = 0;\r\n        for (let i = 0; i < Math.max(array1.length, array2.length); i++) {\r\n            if (typeof array1[i] === \"number\") {\r\n                x1.push(array1[i]);\r\n                x1Mean += array1[i];\r\n            }\r\n            if (typeof array2[i] === \"number\") {\r\n                x2.push(array2[i]);\r\n                x2Mean += array2[i];\r\n            }\r\n        }\r\n        if (x1.length <= 1 || x2.length <= 1)\r\n            throw FormulaError.DIV0;\r\n\r\n        x1Mean /= x1.length;\r\n        x2Mean /= x2.length;\r\n        let s1 = 0, s2 = 0; // sample variance S^2\r\n        for (let i = 0; i < x1.length; i++) {\r\n            s1 += (x1Mean - x1[i]) ** 2\r\n        }\r\n        s1 /= x1.length - 1;\r\n        for (let i = 0; i < x2.length; i++) {\r\n            s2 += (x2Mean - x2[i]) ** 2\r\n        }\r\n        s2 /= x2.length - 1;\r\n        // P(F<=f) one-tail * 2\r\n        return jStat.centralF.cdf(s1 / s2, x1.length - 1, x2.length - 1) * 2;\r\n    },\r\n\r\n    FISHER: (x) => {\r\n        // David\r\n        x = H.accept(x, Types.NUMBER);\r\n        // If x \u2264 -1 or if x \u2265 1, FISHER returns the #NUM! error value.\r\n        if (x <= -1 || x >= 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        return Math.log((1 + x) / (1 - x)) / 2;\r\n    },\r\n\r\n    FISHERINV: (x) => {\r\n        // David\r\n        x = H.accept(x, Types.NUMBER);\r\n        let e2y = Math.exp(2 * x);\r\n        return (e2y - 1) / (e2y + 1);\r\n    },\r\n\r\n    // FIXME\r\n    FORECAST: (x, knownYs, knownXs) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        knownYs = H.accept(knownYs, Types.ARRAY, undefined, true, true);\r\n        knownXs = H.accept(knownXs, Types.ARRAY, undefined, true, true);\r\n\r\n        if (knownXs.length !== knownYs.length)\r\n            throw FormulaError.NA;\r\n\r\n        // filter out values that are not number\r\n        const filteredY = [], filteredX = [];\r\n        let xAllEqual = true;\r\n        for (let i = 0; i < knownYs.length; i++) {\r\n            if (typeof knownYs[i] !== \"number\" || typeof knownXs[i] !== \"number\")\r\n                continue;\r\n            filteredY.push(knownYs[i]);\r\n            filteredX.push(knownXs[i]);\r\n            if (knownXs[i] !== knownXs[0])\r\n                xAllEqual = false;\r\n        }\r\n        if (xAllEqual)\r\n            throw FormulaError.DIV0;\r\n        const yMean = jStat.mean(filteredY);\r\n        const xMean = jStat.mean(filteredX);\r\n        let numerator = 0, denominator = 0;\r\n        for (let i = 0; i < filteredY.length; i++) {\r\n            numerator += (filteredX[i] - xMean) * (filteredY[i] - yMean);\r\n            denominator += (filteredX[i] - xMean) ** 2;\r\n        }\r\n        const b = numerator / denominator;\r\n        const a = yMean - b * xMean;\r\n        return a + b * x;\r\n    },\r\n\r\n    'FORECAST.ETS': () => {\r\n        // skip, not yet possible to implement, may need tensorflow.js ?\r\n    },\r\n\r\n    'FORECAST.ETS.CONFINT': () => {\r\n        // skip\r\n    },\r\n\r\n    'FORECAST.ETS.SEASONALITY': () => {\r\n        // skip\r\n    },\r\n\r\n    'FORECAST.ETS.STAT': () => {\r\n        // skip\r\n    },\r\n\r\n    'FORECAST.LINEAR': (...params) => {\r\n        return DistributionFunctions.FORECAST(...params);\r\n    },\r\n\r\n    FREQUENCY: (dataArray, binsArray) => {\r\n        dataArray = H.accept(dataArray, Types.ARRAY, undefined, true, true);\r\n        binsArray = H.accept(binsArray, Types.ARRAY, undefined, true, true);\r\n\r\n        const binsArrayFiltered = [];\r\n        for (let i = 0; i < binsArray.length; i++) {\r\n            if (typeof binsArray[i] !== \"number\")\r\n                continue;\r\n            binsArrayFiltered.push(binsArray[i]);\r\n        }\r\n        binsArrayFiltered.sort();\r\n        binsArrayFiltered.push(Infinity);\r\n\r\n        const result = [];\r\n        for (let j = 0; j < binsArrayFiltered.length; j++) {\r\n            result[j] = [];\r\n            result[j][0] = 0;\r\n            for (let i = 0; i < dataArray.length; i++) {\r\n                if (typeof dataArray[i] !== \"number\") {\r\n                    continue;\r\n                }\r\n                const curr = dataArray[i];\r\n                if (curr <= binsArrayFiltered[j]) {\r\n                    result[j][0]++;\r\n                    dataArray[i] = null;\r\n                }\r\n            }\r\n        }\r\n        // return a 2d array\r\n        return result;\r\n    },\r\n\r\n    GAMMA: (x) => {\r\n        // David\r\n\r\n        // If Number contains characters that are not valid, GAMMA returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n\r\n        // If Number is a negative integer or 0, GAMMA returns the #NUM! error value.\r\n        if (x === 0 || (x < 0 && x === Math.trunc(x))) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return jStat.gammafn(x);\r\n    },\r\n\r\n    'GAMMA.DIST': (x, alpha, beta, cumulative) => {\r\n        // David\r\n        // If x, alpha, or beta is nonnumeric, GAMMA.DIST returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        beta = H.accept(beta, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n\r\n        // If x < 0, GAMMA.DIST returns the #NUM! error value.\r\n        // If alpha \u2264 0 or if beta \u2264 0, GAMMA.DIST returns the #NUM! error value.\r\n        if (x < 0 || alpha <= 0 || beta <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return cumulative ? jStat.gamma.cdf(x, alpha, beta, true) : jStat.gamma.pdf(x, alpha, beta, false);\r\n    },\r\n\r\n    'GAMMA.INV': (probability, alpha, beta) => {\r\n        // David\r\n        // If any argument is text, GAMMA.INV returns the #VALUE! error value.\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        beta = H.accept(beta, Types.NUMBER);\r\n\r\n        // If probability < 0 or probability > 1, GAMMA.INV returns the #NUM! error value.\r\n        // If alpha \u2264 0 or if beta \u2264 0, GAMMA.INV returns the #NUM! error value.\r\n        if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return jStat.gamma.inv(probability, alpha, beta);\r\n    },\r\n\r\n    GAMMALN: (x) => {\r\n        // David\r\n\r\n        x = H.accept(x, Types.NUMBER);\r\n        // If x is nonnumeric, GAMMALN returns the #VALUE! error value.\r\n        // If x \u2264 0, GAMMALN returns the #NUM! error value.\r\n        if (x <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return jStat.gammaln(x);\r\n    },\r\n\r\n    'GAMMALN.PRECISE': (x) => {\r\n        // David\r\n        // return distribution.GAMMALN(x);\r\n        x = H.accept(x, Types.NUMBER);\r\n        // If x is nonnumeric, GAMMALN returns the #VALUE! error value.\r\n        // If x \u2264 0, GAMMALN returns the #NUM! error value.\r\n        if (x <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return jStat.gammaln(x);\r\n    },\r\n\r\n    GAUSS: (z) => {\r\n        // David\r\n        // If z is not a valid number, GAUSS returns the #NUM! error value.\r\n        // If z is not a valid data type, GAUSS returns the #VALUE! error value.\r\n        z = H.accept(z, Types.NUMBER);\r\n\r\n        return jStat.normal.cdf(z, 0, 1) - 0.5;\r\n    },\r\n\r\n    GEOMEAN: (...numbers) => {\r\n        // David\r\n        const filterArr = [];\r\n        // parse number only if the input is literal\r\n        H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {\r\n            if (typeof item === \"number\") {\r\n                filterArr.push(item);\r\n            }\r\n        });\r\n        return jStat.geomean(filterArr);\r\n    },\r\n\r\n    GROWTH: (knownY, knownX, newX, useConst) => {\r\n        // Credits: Ilmari Karonen (http://stackoverflow.com/questions/14161990/how-to-implement-growth-function-in-javascript)\r\n        knownY = H.accept(knownY, Types.ARRAY, undefined, true, true);\r\n        for (let i = 0; i < knownY.length; i++) {\r\n            if (typeof knownY[i] !== \"number\")\r\n                throw FormulaError.VALUE;\r\n        }\r\n\r\n        knownX = H.accept(knownX, Types.ARRAY, null, true, true);\r\n        const isKnownXOmitted = knownX == null;\r\n        if (knownX == null) {\r\n            knownX = [];\r\n            for (let i = 1; i <= knownY.length; i++) {\r\n                knownX.push(i);\r\n            }\r\n        } else {\r\n            if (knownX.length !== knownY.length)\r\n                throw FormulaError.REF;\r\n            for (let i = 0; i < knownX.length; i++) {\r\n                if (typeof knownX[i] !== \"number\")\r\n                    throw FormulaError.VALUE;\r\n            }\r\n        }\r\n\r\n        newX = H.accept(newX, Types.ARRAY, null, false, true);\r\n        if (newX == null && isKnownXOmitted) {\r\n            newX = [];\r\n            for (let i = 1; i <= knownY.length; i++) {\r\n                newX.push(i);\r\n            }\r\n            newX = [newX];\r\n        } else if (newX == null) {\r\n            newX = Array.isArray(knownX[0]) ? knownX : [knownX];\r\n        }\r\n        useConst = H.accept(useConst, Types.BOOLEAN, true);\r\n\r\n        // Calculate sums over the data:\r\n        const n = knownY.length;\r\n        let avg_x = 0, avg_y = 0, avg_xy = 0, avg_xx = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            const x = knownX[i];\r\n            const y = Math.log(knownY[i]);\r\n            avg_x += x;\r\n            avg_y += y;\r\n            avg_xy += x * y;\r\n            avg_xx += x * x;\r\n        }\r\n        avg_x /= n;\r\n        avg_y /= n;\r\n        avg_xy /= n;\r\n        avg_xx /= n;\r\n\r\n        // Compute linear regression coefficients:\r\n        let beta;\r\n        let alpha;\r\n        if (useConst) {\r\n            beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);\r\n            alpha = avg_y - beta * avg_x;\r\n        } else {\r\n            beta = avg_xy / avg_xx;\r\n            alpha = 0;\r\n        }\r\n\r\n        // Compute and return result array:\r\n        const new_y = [];\r\n        for (let i = 0; i < newX.length; i++) {\r\n            new_y[i] = [];\r\n            for (let j = 0; j < newX[0].length; j++) {\r\n                if (typeof newX[i][j] !== \"number\")\r\n                    throw FormulaError.VALUE;\r\n                new_y[i][j] = Math.exp(alpha + beta * newX[i][j]);\r\n            }\r\n        }\r\n        return new_y;\r\n    },\r\n\r\n    HARMEAN: (...numbers) => {\r\n        let cnt = 0, denominator = 0;\r\n        // parse number only if the input is literal\r\n        H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {\r\n            if (typeof item === \"number\") {\r\n                denominator += 1 / item;\r\n                cnt++;\r\n            }\r\n        });\r\n        return cnt / denominator;\r\n    },\r\n\r\n    'HYPGEOM.DIST': (sample_s, number_sample, population_s, number_pop, cumulative) => {\r\n        //          num_successes, num_draws, successes_in_pop, pop_size\r\n        // If any argument is nonnumeric, HYPGEOM.DIST returns the #VALUE! error value.\r\n        sample_s = H.accept(sample_s, Types.NUMBER);\r\n        number_sample = H.accept(number_sample, Types.NUMBER);\r\n        population_s = H.accept(population_s, Types.NUMBER);\r\n        number_pop = H.accept(number_pop, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n\r\n        // All arguments are truncated to integers.\r\n        sample_s = Math.trunc(sample_s);\r\n        number_sample = Math.trunc(number_sample);\r\n        population_s = Math.trunc(population_s);\r\n        number_pop = Math.trunc(number_pop);\r\n\r\n        // // If number_pop \u2264 0, HYPGEOM.DIST returns the #NUM! error value.\r\n        if (number_pop <= 0 || sample_s < 0 || number_sample <= 0 || population_s <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // // If number_sample \u2264 0 or number_sample > number_population, HYPGEOM.DIST returns the #NUM! error value.\r\n        if (number_sample > number_pop) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // // If population_s \u2264 0 or population_s > number_population, HYPGEOM.DIST returns the #NUM! error value.\r\n        if (population_s > number_pop) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If sample_s < 0 or sample_s is greater than the lesser of number_sample or population_s, HYPGEOM.DIST returns the #NUM! error value.\r\n        // Google and Mircrosoft has different version on this funtion\r\n        if (number_sample < sample_s || population_s < sample_s) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If sample_s is less than the larger of 0 or (number_sample - number_population + population_s), HYPGEOM.DIST returns the #NUM! error value.\r\n        if (sample_s < (number_sample - number_pop + population_s)) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        function pdf(x, n, M, N) {\r\n            return MathFunctions.COMBIN(M, x) * MathFunctions.COMBIN(N - M, n - x) / MathFunctions.COMBIN(N, n);\r\n        }\r\n\r\n        function cdf(x, n, M, N) {\r\n            let result = 0;\r\n            for (let i = 0; i <= x; i++) {\r\n                result += pdf(i, n, M, N);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        return cumulative ? cdf(sample_s, number_sample, population_s, number_pop) : pdf(sample_s, number_sample, population_s, number_pop);\r\n    },\r\n\r\n    INTERCEPT: (knownYs, knownXs) => {\r\n        // similar to FORECAST\r\n        knownYs = H.accept(knownYs, Types.ARRAY, undefined, true, true);\r\n        knownXs = H.accept(knownXs, Types.ARRAY, undefined, true, true);\r\n\r\n        if (knownXs.length !== knownYs.length)\r\n            throw FormulaError.NA;\r\n\r\n        // filter out values that are not number\r\n        const filteredY = [], filteredX = [];\r\n        for (let i = 0; i < knownYs.length; i++) {\r\n            if (typeof knownYs[i] !== \"number\" || typeof knownXs[i] !== \"number\")\r\n                continue;\r\n            filteredY.push(knownYs[i]);\r\n            filteredX.push(knownXs[i]);\r\n        }\r\n        if (filteredY.length <= 1)\r\n            throw FormulaError.DIV0;\r\n        const yMean = jStat.mean(filteredY);\r\n        const xMean = jStat.mean(filteredX);\r\n        let numerator = 0, denominator = 0;\r\n        for (let i = 0; i < filteredY.length; i++) {\r\n            numerator += (filteredX[i] - xMean) * (filteredY[i] - yMean);\r\n            denominator += (filteredX[i] - xMean) ** 2;\r\n        }\r\n        const b = numerator / denominator;\r\n        return yMean - b * xMean;\r\n    },\r\n\r\n    KURT: (...numbers) => {\r\n        let mean = 0, range = [];\r\n        // parse number only if the input is literal\r\n        H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {\r\n            if (typeof item === \"number\") {\r\n                mean += item;\r\n                range.push(item);\r\n            }\r\n        });\r\n        const n = range.length;\r\n        mean /= n;\r\n        let sigma = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            sigma += Math.pow(range[i] - mean, 4);\r\n        }\r\n        sigma = sigma / Math.pow(jStat.stdev(range, true), 4);\r\n        return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));\r\n    },\r\n\r\n    LINEST: () => {\r\n\r\n    },\r\n\r\n    LOGEST: () => {\r\n\r\n    },\r\n\r\n    'LOGNORM.DIST': (x, mean, standard_dev, cumulative) => {\r\n        // if any argument is nonnumeric, LOGNORM.DIST returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        mean = H.accept(mean, Types.NUMBER);\r\n        standard_dev = H.accept(standard_dev, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        // If x \u2264 0 or if standard_dev \u2264 0, LOGNORM.DIST returns the #NUM! error value.\r\n        if (x <= 0 || standard_dev <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return cumulative ? jStat.lognormal.cdf(x, mean, standard_dev) : jStat.lognormal.pdf(x, mean, standard_dev);\r\n    },\r\n\r\n    'LOGNORM.INV': (probability, mean, standard_dev) => {\r\n        // If any argument is nonnumeric, LOGNORM.INV returns the #VALUE! error value.\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        mean = H.accept(mean, Types.NUMBER);\r\n        standard_dev = H.accept(standard_dev, Types.NUMBER);\r\n        // If probability <= 0 or probability >= 1, LOGNORM.INV returns the #NUM! error value.\r\n        if (probability <= 0 || probability >= 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If standard_dev <= 0, LOGNORM.INV returns the #NUM! error value.\r\n        if (standard_dev <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return jStat.lognormal.inv(probability, mean, standard_dev);\r\n    },\r\n\r\n    'MODE.MULT': () => {\r\n\r\n    },\r\n\r\n    'MODE.SNGL': () => {\r\n\r\n    },\r\n\r\n    'NEGBINOM.DIST': (number_f, number_s, probability_s, cumulative) => {\r\n        // If any argument is nonnumeric, NEGBINOM.DIST returns the #VALUE! error value.\r\n        number_f = H.accept(number_f, Types.NUMBER);\r\n        number_s = H.accept(number_s, Types.NUMBER);\r\n        probability_s = H.accept(probability_s, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        // Number_f and number_s are truncated to integers.\r\n        number_f = Math.trunc(number_f);\r\n        number_s = Math.trunc(number_s);\r\n\r\n        // If probability_s < 0 or if probability > 1, NEGBINOM.DIST returns the #NUM! error value.\r\n        if (probability_s < 0 || probability_s > 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If number_f < 0 or number_s < 1, NEGBINOM.DIST returns the #NUM! error value.\r\n        if (number_f < 0 || number_s < 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return cumulative ? jStat.negbin.cdf(number_f, number_s, probability_s) : jStat.negbin.pdf(number_f, number_s, probability_s);\r\n    },\r\n\r\n    'NORM.DIST': (x, mean, standard_dev, cumulative) => {\r\n        // If mean or standard_dev is nonnumeric, NORM.DIST returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        mean = H.accept(mean, Types.NUMBER);\r\n        standard_dev = H.accept(standard_dev, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n\r\n        // If standard_dev \u2264 0, NORM.DIST returns the #NUM! error value.\r\n        if (standard_dev <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If mean = 0, standard_dev = 1, and cumulative = TRUE, NORM.DIST returns the standard normal distribution, NORM.S.DIST.\r\n        return cumulative ? jStat.normal.cdf(x, mean, standard_dev) : jStat.normal.pdf(x, mean, standard_dev);\r\n\r\n    },\r\n\r\n    'NORM.INV': (probability, mean, standard_dev) => {\r\n        // If any argument is nonnumeric, NORM.INV returns the #VALUE! error value.\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        mean = H.accept(mean, Types.NUMBER);\r\n        standard_dev = H.accept(standard_dev, Types.NUMBER);\r\n\r\n        // If probability <= 0 or if probability >= 1, NORM.INV returns the #NUM! error value.\r\n        if (probability <= 0 || probability >= 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If standard_dev \u2264 0, NORM.INV returns the #NUM! error value.\r\n        if (standard_dev <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If mean = 0 and standard_dev = 1, NORM.INV uses the standard normal distribution (see NORMS.INV).\r\n        // if(mean === 0 && standard_dev === 1){\r\n        // }\r\n\r\n        return jStat.normal.inv(probability, mean, standard_dev);\r\n\r\n    },\r\n\r\n    'NORM.S.DIST': (z, cumulative) => {\r\n        // If z is nonnumeric, NORM.S.DIST returns the #VALUE! error value.\r\n        z = H.accept(z, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n\r\n        return (cumulative) ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);\r\n    },\r\n\r\n    'NORM.S.INV': (probability) => {\r\n        // If probability is nonnumeric, NORMS.INV returns the #VALUE! error value.\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        // If probability <= 0 or if probability >= 1, NORMS.INV returns the #NUM! error value.\r\n        if (probability <= 0 || probability >= 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        return jStat.normal.inv(probability, 0, 1);\r\n    },\r\n\r\n    PEARSON: () => {\r\n\r\n    },\r\n\r\n    'PERCENTILE.EXC': () => {\r\n\r\n    },\r\n\r\n    'PERCENTILE.INC': () => {\r\n\r\n    },\r\n\r\n    'PERCENTRANK.EXC': () => {\r\n\r\n    },\r\n\r\n    'PERCENTRANK.INC': () => {\r\n\r\n    },\r\n\r\n    PERMUTATIONA: () => {\r\n\r\n    },\r\n\r\n    PHI: (x) => {\r\n        // If x is a numeric value that is not valid, PHI returns the #NUM! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n\r\n        return Math.exp(-0.5 * x * x) / SQRT2PI;\r\n    },\r\n\r\n    'POISSON.DIST': (x, mean, cumulative) => {\r\n        // If x or mean is nonnumeric, POISSON.DIST returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        mean = H.accept(mean, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        // If x < 0, POISSON.DIST returns the #NUM! error value.\r\n        // If mean < 0, POISSON.DIST returns the #NUM! error value.\r\n        if (x < 0 || mean < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If x is not an integer, it is truncated.\r\n        x = Math.trunc(x);\r\n\r\n        return cumulative ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);\r\n    },\r\n\r\n    'PROB': () => {\r\n\r\n    },\r\n\r\n    'QUARTILE.EXC': () => {\r\n\r\n    },\r\n\r\n    'QUARTILE.INC': () => {\r\n\r\n    },\r\n\r\n    'RANK.AVG': () => {\r\n\r\n    },\r\n\r\n    'RANK.EQ': () => {\r\n\r\n    },\r\n\r\n    RSQ: () => {\r\n\r\n    },\r\n\r\n    SKEW: () => {\r\n\r\n    },\r\n\r\n    'SKEW.P': () => {\r\n\r\n    },\r\n\r\n    SLOPE: () => {\r\n\r\n    },\r\n\r\n    STANDARDIZE: (x, mean, standard_dev) => {\r\n        x = H.accept(x, Types.NUMBER);\r\n        mean = H.accept(mean, Types.NUMBER);\r\n        standard_dev = H.accept(standard_dev, Types.NUMBER);\r\n        // If standard_dev \u2264 0, STANDARDIZE returns the #NUM! error value.\r\n        if (standard_dev <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return (x - mean) / standard_dev;\r\n    },\r\n\r\n    'STDEV.P': () => {\r\n\r\n    },\r\n\r\n    'STDEV.S': () => {\r\n\r\n    },\r\n\r\n    STDEVA: () => {\r\n\r\n    },\r\n\r\n    STDEVPA: () => {\r\n\r\n    },\r\n\r\n    STEYX: () => {\r\n\r\n    },\r\n\r\n    'T.DIST': (x, deg_freedom, cumulative) => {\r\n        // If any argument is nonnumeric, T.DIST returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        deg_freedom = H.accept(deg_freedom, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        // If deg_freedom < 1, T.DIST returns an error value. Deg_freedom needs to be at least 1.\r\n        if (deg_freedom < 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return cumulative ? jStat.studentt.cdf(x, deg_freedom) : jStat.studentt.pdf(x, deg_freedom);\r\n    },\r\n\r\n    'T.DIST.2T': (x, deg_freedom) => {\r\n        // If any argument is nonnumeric, T.DIST.2T returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        deg_freedom = H.accept(deg_freedom, Types.NUMBER);\r\n        // If deg_freedom < 1, T.DIST.2T returns the #NUM! error value.\r\n        // If x < 0, then T.DIST.2T returns the #NUM! error value.\r\n        if (deg_freedom < 1 || x < 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return (1 - jStat.studentt.cdf(x, deg_freedom)) * 2;\r\n    },\r\n\r\n    'T.DIST.RT': (x, deg_freedom) => {\r\n        // If any argument is nonnumeric, T.DIST.RT returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        deg_freedom = H.accept(deg_freedom, Types.NUMBER);\r\n        // If deg_freedom < 1, T.DIST.RT returns the #NUM! error value.\r\n        if (deg_freedom < 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return 1 - jStat.studentt.cdf(x, deg_freedom);\r\n    },\r\n\r\n    'T.INV': (probability, deg_freedom) => {\r\n        // If either argument is nonnumeric, T.INV returns the #VALUE! error value.\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        deg_freedom = H.accept(deg_freedom, Types.NUMBER);\r\n        // If probability <= 0 or if probability > 1, T.INV returns the #NUM! error value.\r\n        // If deg_freedom < 1, T.INV returns the #NUM! error value.\r\n        if (probability <= 0 || probability > 1 || deg_freedom < 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        // If deg_freedom is not an integer, it is truncated.\r\n        deg_freedom = deg_freedom % 1 === 0 ? deg_freedom : Math.trunc(deg_freedom);\r\n\r\n        return jStat.studentt.inv(probability, deg_freedom);\r\n    },\r\n\r\n    'T.INV.2T': (probability, deg_freedom) => {\r\n        // If either argument is nonnumeric, T.INV.2T returns the #VALUE! error value.\r\n        probability = H.accept(probability, Types.NUMBER);\r\n        deg_freedom = H.accept(deg_freedom, Types.NUMBER);\r\n        // If probability <= 0 or if probability > 1, T.INV.2T returns the #NUM! error value.\r\n        // If deg_freedom < 1, T.INV.2T returns the #NUM! error value.\r\n        if (probability <= 0 || probability > 1 || deg_freedom < 1) {\r\n            throw FormulaError.NUM;\r\n        }\r\n        // If deg_freedom is not an integer, it is truncated.\r\n        deg_freedom = deg_freedom % 1 === 0 ? deg_freedom : Math.trunc(deg_freedom);\r\n\r\n        return Math.abs(jStat.studentt.inv(probability / 2, deg_freedom));\r\n\r\n    },\r\n\r\n    'T.TEST': () => {\r\n\r\n    },\r\n\r\n    TREND: () => {\r\n\r\n    },\r\n\r\n    TRIMMEAN: () => {\r\n\r\n    },\r\n\r\n    'VAR.P': () => {\r\n\r\n    },\r\n\r\n    'VAR.S': () => {\r\n\r\n    },\r\n\r\n    'VARA': () => {\r\n\r\n    },\r\n\r\n    'VARPA': () => {\r\n\r\n    },\r\n\r\n    'WEIBULL.DIST': (x, alpha, beta, cumulative) => {\r\n        // If x, alpha, or beta is nonnumeric, WEIBULL.DIST returns the #VALUE! error value.\r\n        x = H.accept(x, Types.NUMBER);\r\n        alpha = H.accept(alpha, Types.NUMBER);\r\n        beta = H.accept(beta, Types.NUMBER);\r\n        cumulative = H.accept(cumulative, Types.BOOLEAN);\r\n        // If x < 0, WEIBULL.DIST returns the #NUM! error value.\r\n        // If alpha \u2264 0 or if beta \u2264 0, WEIBULL.DIST returns the #NUM! error value.\r\n        if (x < 0 || alpha <= 0 || beta <= 0) {\r\n            throw FormulaError.NUM;\r\n        }\r\n\r\n        return cumulative\r\n            ? 1 - Math.exp(-Math.pow(x / beta, alpha))\r\n            : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);\r\n    },\r\n\r\n    'Z.TEST': () => {\r\n\r\n    }\r\n};\r\n\r\n\r\nmodule.exports = {\r\n    DistributionFunctions,\r\n};\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types, Criteria, Address} = require('../helpers');\r\nconst {Infix} = require('../operators');\r\nconst H = FormulaHelpers;\r\nconst {DistributionFunctions} = require('./distribution');\r\n\r\nconst StatisticalFunctions = {\r\n    AVEDEV: (...numbers) => {\r\n        let sum = 0;\r\n        const arr = [];\r\n        // parse number only if the input is literal\r\n        H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {\r\n            if (typeof item === \"number\") {\r\n                sum += item;\r\n                arr.push(item);\r\n            }\r\n        });\r\n        const avg = sum / arr.length;\r\n        sum = 0;\r\n        for (let i = 0; i < arr.length; i++) {\r\n            sum += Math.abs(arr[i] - avg);\r\n        }\r\n        return sum / arr.length;\r\n    },\r\n\r\n    AVERAGE: (...numbers) => {\r\n        let sum = 0, cnt = 0;\r\n        // parse number only if the input is literal\r\n        H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {\r\n            if (typeof item === \"number\") {\r\n                sum += item;\r\n                cnt++;\r\n            }\r\n        });\r\n        return sum / cnt;\r\n    },\r\n\r\n    AVERAGEA: (...numbers) => {\r\n        let sum = 0, cnt = 0;\r\n        // parse number only if the input is literal\r\n        H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {\r\n            const type = typeof item;\r\n            if (type === \"number\") {\r\n                sum += item;\r\n                cnt++;\r\n            } else if (type === \"string\") {\r\n                cnt++;\r\n            }\r\n        });\r\n        return sum / cnt;\r\n    },\r\n\r\n    // special\r\n    AVERAGEIF: (context, range, criteria, averageRange) => {\r\n        const ranges = H.retrieveRanges(context, range, averageRange);\r\n        range = ranges[0];\r\n        averageRange = ranges[1];\r\n\r\n        criteria = H.retrieveArg(context, criteria);\r\n        const isCriteriaArray = criteria.isArray;\r\n        criteria = Criteria.parse(H.accept(criteria));\r\n\r\n        let sum = 0, cnt = 0;\r\n        range.forEach((row, rowNum) => {\r\n            row.forEach((value, colNum) => {\r\n                const valueToAdd = averageRange[rowNum][colNum];\r\n                if (typeof valueToAdd !== \"number\")\r\n                    return;\r\n                // wildcard\r\n                if (criteria.op === 'wc') {\r\n                    if (criteria.match === criteria.value.test(value)) {\r\n                        sum += valueToAdd;\r\n                        cnt++;\r\n                    }\r\n                } else if (Infix.compareOp(value, criteria.op, criteria.value, Array.isArray(value), isCriteriaArray)) {\r\n                    sum += valueToAdd;\r\n                    cnt++;\r\n                }\r\n            })\r\n        });\r\n        if (cnt === 0) throw FormulaError.DIV0;\r\n        return sum / cnt;\r\n    },\r\n\r\n    AVERAGEIFS: () => {\r\n\r\n    },\r\n\r\n    COUNT: (...ranges) => {\r\n        let cnt = 0;\r\n        H.flattenParams(ranges, null, true,\r\n            (item, info) => {\r\n                // literal will be parsed to Type.NUMBER\r\n                if (info.isLiteral && !isNaN(item)) {\r\n                    cnt++;\r\n                } else {\r\n                    if (typeof item === \"number\")\r\n                        cnt++;\r\n                }\r\n            });\r\n        return cnt;\r\n    },\r\n\r\n    COUNTIF: (range, criteria) => {\r\n        // do not flatten the array\r\n        range = H.accept(range, Types.ARRAY, undefined, false, true);\r\n        const isCriteriaArray = criteria.isArray;\r\n        criteria = H.accept(criteria);\r\n\r\n        let cnt = 0;\r\n        // parse criteria\r\n        criteria = Criteria.parse(criteria);\r\n\r\n        range.forEach(row => {\r\n            row.forEach(value => {\r\n                // wildcard\r\n                if (criteria.op === 'wc') {\r\n                    if (criteria.match === criteria.value.test(value))\r\n                        cnt++;\r\n                } else if (Infix.compareOp(value, criteria.op, criteria.value, Array.isArray(value), isCriteriaArray)) {\r\n                    cnt++;\r\n                }\r\n            })\r\n        });\r\n        return cnt;\r\n    },\r\n\r\n    LARGE: () => {\r\n\r\n    },\r\n\r\n    MAX: () => {\r\n\r\n    },\r\n\r\n    MAXA: () => {\r\n\r\n    },\r\n\r\n    MAXIFS: () => {\r\n\r\n    },\r\n\r\n    MEDIAN: () => {\r\n\r\n    },\r\n\r\n    MIN: () => {\r\n\r\n    },\r\n\r\n    MINA: () => {\r\n\r\n    },\r\n\r\n    MINIFS: () => {\r\n\r\n    },\r\n\r\n    PERMUT: () => {\r\n\r\n    },\r\n\r\n    PERMUTATIONA: () => {\r\n\r\n    },\r\n\r\n    SMALL: () => {\r\n\r\n    },\r\n\r\n};\r\n\r\n\r\nmodule.exports = Object.assign(StatisticalFunctions, DistributionFunctions);\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types} = require('../helpers');\r\nconst H = FormulaHelpers;\r\n\r\nconst MS_PER_DAY = 1000 * 60 * 60 * 24;\r\nconst d1900 = new Date(Date.UTC(1900, 0, 1));\r\nconst WEEK_STARTS = [\r\n    undefined, 0, 1, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, 1, 2, 3, 4, 5, 6, 0];\r\nconst WEEK_TYPES = [\r\n    undefined,\r\n    [1, 2, 3, 4, 5, 6, 7],\r\n    [7, 1, 2, 3, 4, 5, 6],\r\n    [6, 0, 1, 2, 3, 4, 5],\r\n    undefined,\r\n    undefined,\r\n    undefined,\r\n    undefined,\r\n    undefined,\r\n    undefined,\r\n    undefined,\r\n    [7, 1, 2, 3, 4, 5, 6],\r\n    [6, 7, 1, 2, 3, 4, 5],\r\n    [5, 6, 7, 1, 2, 3, 4],\r\n    [4, 5, 6, 7, 1, 2, 3],\r\n    [3, 4, 5, 6, 7, 1, 2],\r\n    [2, 3, 4, 5, 6, 7, 1],\r\n    [1, 2, 3, 4, 5, 6, 7]\r\n];\r\nconst WEEKEND_TYPES = [\r\n    undefined,\r\n    [6, 0],\r\n    [0, 1],\r\n    [1, 2],\r\n    [2, 3],\r\n    [3, 4],\r\n    [4, 5],\r\n    [5, 6],\r\n    undefined,\r\n    undefined,\r\n    undefined,\r\n    [0],\r\n    [1],\r\n    [2],\r\n    [3],\r\n    [4],\r\n    [5],\r\n    [6]\r\n];\r\n\r\n// Formats: h:mm:ss A, h:mm A, H:mm, H:mm:ss, H A\r\nconst timeRegex = /^\\s*(\\d\\d?)\\s*(:\\s*\\d\\d?)?\\s*(:\\s*\\d\\d?)?\\s*(pm|am)?\\s*$/i;\r\n// 12-3, 12/3\r\nconst dateRegex1 = /^\\s*((\\d\\d?)\\s*([-\\/])\\s*(\\d\\d?))([\\d:.apm\\s]*)$/i;\r\n// 3-Dec, 3/Dec\r\nconst dateRegex2 = /^\\s*((\\d\\d?)\\s*([-/])\\s*(jan\\w*|feb\\w*|mar\\w*|apr\\w*|may\\w*|jun\\w*|jul\\w*|aug\\w*|sep\\w*|oct\\w*|nov\\w*|dec\\w*))([\\d:.apm\\s]*)$/i;\r\n// Dec-3, Dec/3\r\nconst dateRegex3 = /^\\s*((jan\\w*|feb\\w*|mar\\w*|apr\\w*|may\\w*|jun\\w*|jul\\w*|aug\\w*|sep\\w*|oct\\w*|nov\\w*|dec\\w*)\\s*([-/])\\s*(\\d\\d?))([\\d:.apm\\s]*)$/i;\r\n\r\nfunction parseSimplifiedDate(text) {\r\n    const fmt1 = text.match(dateRegex1);\r\n    const fmt2 = text.match(dateRegex2);\r\n    const fmt3 = text.match(dateRegex3);\r\n    if (fmt1) {\r\n        text = fmt1[1] + fmt1[3] + new Date().getFullYear() + fmt1[5];\r\n    } else if (fmt2) {\r\n        text = fmt2[1] + fmt2[3] + new Date().getFullYear() + fmt2[5];\r\n    } else if (fmt3) {\r\n        text = fmt3[1] + fmt3[3] + new Date().getFullYear() + fmt3[5];\r\n    }\r\n    return new Date(Date.parse(`${text} UTC`));\r\n}\r\n\r\n/**\r\n * Parse time string to date in UTC.\r\n * @param {string} text\r\n */\r\nfunction parseTime(text) {\r\n    const res = text.match(timeRegex);\r\n    if (!res) return;\r\n\r\n    // \u00A0[\"4:50:55 pm\", \"4\", \":50\", \":55\", \"pm\", ...]\r\n    const minutes = res[2] ? res[2] : ':00';\r\n    const seconds = res[3] ? res[3] : ':00';\r\n    const ampm = res[4] ? ' ' + res[4] : '';\r\n\r\n    const date = new Date(Date.parse(`1/1/1900 ${res[1] + minutes + seconds + ampm} UTC`));\r\n    let now = new Date();\r\n    now = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate(),\r\n        now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds()));\r\n\r\n    return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(),\r\n        date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()));\r\n}\r\n\r\n/**\r\n * Parse a UTC date to excel serial number.\r\n * @param {Date|number} date - A UTC date.\r\n * @returns {number}\r\n */\r\nfunction toSerial(date) {\r\n    const addOn = (date > -2203891200000) ? 2 : 1;\r\n    return Math.floor((date - d1900) / 86400000) + addOn;\r\n}\r\n\r\n/**\r\n * Parse an excel serial number to UTC date.\r\n * @param serial\r\n * @returns {Date}\r\n */\r\nfunction toDate(serial) {\r\n    if (serial < 0) {\r\n        throw FormulaError.VALUE;\r\n    }\r\n    if (serial <= 60) {\r\n        return new Date(d1900.getTime() + (serial - 1) * 86400000);\r\n    }\r\n    return new Date(d1900.getTime() + (serial - 2) * 86400000);\r\n}\r\n\r\nfunction parseDateWithExtra(serialOrString) {\r\n    if (serialOrString instanceof Date) return {date: serialOrString};\r\n    serialOrString = H.accept(serialOrString);\r\n    let isDateGiven = true, date;\r\n    if (!isNaN(serialOrString)) {\r\n        serialOrString = Number(serialOrString);\r\n        date = toDate(serialOrString);\r\n    } else {\r\n        // support time without date\r\n        date = parseTime(serialOrString);\r\n\r\n        if (!date) {\r\n            date = parseSimplifiedDate(serialOrString);\r\n        } else {\r\n            isDateGiven = false;\r\n        }\r\n    }\r\n    return {date, isDateGiven};\r\n}\r\n\r\nfunction parseDate(serialOrString) {\r\n    return parseDateWithExtra(serialOrString).date;\r\n}\r\n\r\nfunction compareDateIgnoreTime(date1, date2) {\r\n    return date1.getUTCFullYear() === date2.getUTCFullYear() &&\r\n        date1.getUTCMonth() === date2.getUTCMonth() &&\r\n        date1.getUTCDate() === date2.getUTCDate();\r\n}\r\n\r\nfunction isLeapYear(year) {\r\n    if (year === 1900) {\r\n        return true;\r\n    }\r\n    return new Date(year, 1, 29).getMonth() === 1;\r\n}\r\n\r\nconst DateFunctions = {\r\n    DATE: (year, month, day) => {\r\n        year = H.accept(year, Types.NUMBER);\r\n        month = H.accept(month, Types.NUMBER);\r\n        day = H.accept(day, Types.NUMBER);\r\n        if (year < 0 || year >= 10000)\r\n            throw FormulaError.NUM;\r\n\r\n        // If year is between 0 (zero) and 1899 (inclusive), Excel adds that value to 1900 to calculate the year.\r\n        if (year < 1900) {\r\n            year += 1900;\r\n        }\r\n\r\n        return toSerial(Date.UTC(year, month - 1, day));\r\n    },\r\n\r\n    DATEDIF: (startDate, endDate, unit) => {\r\n        startDate = parseDate(startDate);\r\n        endDate = parseDate(endDate);\r\n        unit = H.accept(unit, Types.STRING).toLowerCase();\r\n\r\n        if (startDate > endDate)\r\n            throw FormulaError.NUM;\r\n        const yearDiff = endDate.getUTCFullYear() - startDate.getUTCFullYear();\r\n        const monthDiff = endDate.getUTCMonth() - startDate.getUTCMonth();\r\n        const dayDiff = endDate.getUTCDate() - startDate.getUTCDate();\r\n        let offset;\r\n        switch (unit) {\r\n            case 'y':\r\n                offset = monthDiff < 0 || monthDiff === 0 && dayDiff < 0 ? -1 : 0;\r\n                return offset + yearDiff;\r\n            case 'm':\r\n                offset = dayDiff < 0 ? -1 : 0;\r\n                return yearDiff * 12 + monthDiff + offset;\r\n            case 'd':\r\n                return Math.floor(endDate - startDate) / MS_PER_DAY;\r\n            case 'md':\r\n                // The months and years of the dates are ignored.\r\n                startDate.setUTCFullYear(endDate.getUTCFullYear());\r\n                if (dayDiff < 0) {\r\n                    startDate.setUTCMonth(endDate.getUTCMonth() - 1)\r\n                } else {\r\n                    startDate.setUTCMonth(endDate.getUTCMonth())\r\n                }\r\n                return Math.floor(endDate - startDate) / MS_PER_DAY;\r\n            case 'ym':\r\n                // The days and years of the dates are ignored\r\n                offset = dayDiff < 0 ? -1 : 0;\r\n                return (offset + yearDiff * 12 + monthDiff) % 12;\r\n            case 'yd':\r\n                // The years of the dates are ignored.\r\n                if (monthDiff < 0 || monthDiff === 0 && dayDiff < 0) {\r\n                    startDate.setUTCFullYear(endDate.getUTCFullYear() - 1);\r\n                } else {\r\n                    startDate.setUTCFullYear(endDate.getUTCFullYear());\r\n                }\r\n                return Math.floor(endDate - startDate) / MS_PER_DAY;\r\n\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Limitation: Year must be four digit, only support ISO 8016 date format.\r\n     * Does not support date without year, i.e. \"5-JUL\".\r\n     * @param {string} dateText\r\n     */\r\n    DATEVALUE: (dateText) => {\r\n        dateText = H.accept(dateText, Types.STRING);\r\n        const {date, isDateGiven} = parseDateWithExtra(dateText);\r\n        if (!isDateGiven) return 0;\r\n        const serial = toSerial(date);\r\n        if (serial < 0 || serial > 2958465)\r\n            throw FormulaError.VALUE;\r\n        return serial;\r\n    },\r\n\r\n    DAY: serialOrString => {\r\n        const date = parseDate(serialOrString);\r\n        return date.getUTCDate();\r\n    },\r\n\r\n    DAYS: (endDate, startDate) => {\r\n        endDate = parseDate(endDate);\r\n        startDate = parseDate(startDate);\r\n        let offset = 0;\r\n        if (startDate < -2203891200000 && -2203891200000 < endDate) {\r\n            offset = 1;\r\n        }\r\n        return Math.floor(endDate - startDate) / MS_PER_DAY + offset;\r\n    },\r\n\r\n    DAYS360: (startDate, endDate, method) => {\r\n        startDate = parseDate(startDate);\r\n        endDate = parseDate(endDate);\r\n        // default is US method\r\n        method = H.accept(method, Types.BOOLEAN, false);\r\n\r\n        if (startDate.getUTCDate() === 31) {\r\n            startDate.setUTCDate(30);\r\n        }\r\n        if (!method && startDate.getUTCDate() < 30 && endDate.getUTCDate() > 30) {\r\n            endDate.setUTCMonth(endDate.getUTCMonth() + 1, 1);\r\n        } else {\r\n            // European method\r\n            if (endDate.getUTCDate() === 31) {\r\n                endDate.setUTCDate(30);\r\n            }\r\n        }\r\n\r\n        const yearDiff = endDate.getUTCFullYear() - startDate.getUTCFullYear();\r\n        const monthDiff = endDate.getUTCMonth() - startDate.getUTCMonth();\r\n        const dayDiff = endDate.getUTCDate() - startDate.getUTCDate();\r\n\r\n        return (monthDiff) * 30 + dayDiff + yearDiff * 12 * 30;\r\n    },\r\n\r\n    EDATE: (startDate, months) => {\r\n        startDate = parseDate(startDate);\r\n        months = H.accept(months, Types.NUMBER);\r\n        startDate.setUTCMonth(startDate.getUTCMonth() + months);\r\n        return toSerial(startDate);\r\n    },\r\n\r\n    EOMONTH: (startDate, months) => {\r\n        startDate = parseDate(startDate);\r\n        months = H.accept(months, Types.NUMBER);\r\n        startDate.setUTCMonth(startDate.getUTCMonth() + months + 1, 0);\r\n        return toSerial(startDate);\r\n    },\r\n\r\n    HOUR: serialOrString => {\r\n        const date = parseDate(serialOrString);\r\n        return date.getUTCHours();\r\n    },\r\n\r\n    ISOWEEKNUM: (serialOrString) => {\r\n        const date = parseDate(serialOrString);\r\n\r\n        // https://stackoverflow.com/questions/6117814/get-week-of-year-in-javascript-like-in-php\r\n        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\r\n        const dayNum = d.getUTCDay();\r\n        d.setUTCDate(d.getUTCDate() + 4 - dayNum);\r\n        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\r\n        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7)\r\n    },\r\n\r\n    MINUTE: serialOrString => {\r\n        const date = parseDate(serialOrString);\r\n        return date.getUTCMinutes();\r\n    },\r\n\r\n    MONTH: serialOrString => {\r\n        const date = parseDate(serialOrString);\r\n        return date.getUTCMonth() + 1;\r\n    },\r\n\r\n    NETWORKDAYS: (startDate, endDate, holidays) => {\r\n        startDate = parseDate(startDate);\r\n        endDate = parseDate(endDate);\r\n        let sign = 1;\r\n        if (startDate > endDate) {\r\n            sign = -1;\r\n            const temp = startDate;\r\n            startDate = endDate;\r\n            endDate = temp;\r\n        }\r\n        const holidaysArr = [];\r\n        if (holidays != null) {\r\n            H.flattenParams([holidays], Types.NUMBER, false, item => {\r\n                holidaysArr.push(parseDate(item));\r\n            });\r\n        }\r\n        let numWorkDays = 0;\r\n        while (startDate <= endDate) {\r\n            // Skips Sunday and Saturday\r\n            if (startDate.getUTCDay() !== 0 && startDate.getUTCDay() !== 6) {\r\n                let found = false;\r\n                for (let i = 0; i < holidaysArr.length; i++) {\r\n                    if (compareDateIgnoreTime(startDate, holidaysArr[i])) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) numWorkDays++;\r\n            }\r\n            startDate.setUTCDate(startDate.getUTCDate() + 1);\r\n        }\r\n        return sign * numWorkDays;\r\n\r\n    },\r\n\r\n    'NETWORKDAYS.INTL': (startDate, endDate, weekend, holidays) => {\r\n        startDate = parseDate(startDate);\r\n        endDate = parseDate(endDate);\r\n        let sign = 1;\r\n        if (startDate > endDate) {\r\n            sign = -1;\r\n            const temp = startDate;\r\n            startDate = endDate;\r\n            endDate = temp;\r\n        }\r\n        weekend = H.accept(weekend, null, 1);\r\n        // Using 1111111 will always return 0.\r\n        if (weekend === '1111111')\r\n            return 0;\r\n\r\n        // using weekend string, i.e, 0000011\r\n        if (typeof weekend === \"string\" && Number(weekend).toString() !== weekend) {\r\n            if (weekend.length !== 7) throw FormulaError.VALUE;\r\n            weekend = weekend.charAt(6) + weekend.slice(0, 6);\r\n            const weekendArr = [];\r\n            for (let i = 0; i < weekend.length; i++) {\r\n                if (weekend.charAt(i) === '1')\r\n                    weekendArr.push(i);\r\n            }\r\n            weekend = weekendArr;\r\n        } else {\r\n            // using weekend number\r\n            if (typeof weekend !== \"number\")\r\n                throw FormulaError.VALUE;\r\n            weekend = WEEKEND_TYPES[weekend];\r\n        }\r\n\r\n        const holidaysArr = [];\r\n        if (holidays != null) {\r\n            H.flattenParams([holidays], Types.NUMBER, false, item => {\r\n                holidaysArr.push(parseDate(item));\r\n            });\r\n        }\r\n        let numWorkDays = 0;\r\n        while (startDate <= endDate) {\r\n            let skip = false;\r\n            for (let i = 0; i < weekend.length; i++) {\r\n                if (weekend[i] === startDate.getUTCDay()) {\r\n                    skip = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!skip) {\r\n                let found = false;\r\n                for (let i = 0; i < holidaysArr.length; i++) {\r\n                    if (compareDateIgnoreTime(startDate, holidaysArr[i])) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) numWorkDays++;\r\n            }\r\n            startDate.setUTCDate(startDate.getUTCDate() + 1);\r\n        }\r\n        return sign * numWorkDays;\r\n\r\n    },\r\n\r\n    NOW: () => {\r\n        const now = new Date();\r\n        return toSerial(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate(),\r\n            now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds()))\r\n            + (3600 * now.getHours() + 60 * now.getMinutes() + now.getSeconds()) / 86400;\r\n    },\r\n\r\n    SECOND: (serialOrString) => {\r\n        const date = parseDate(serialOrString);\r\n        return date.getUTCSeconds();\r\n    },\r\n\r\n    TIME: (hour, minute, second) => {\r\n        hour = H.accept(hour, Types.NUMBER);\r\n        minute = H.accept(minute, Types.NUMBER);\r\n        second = H.accept(second, Types.NUMBER);\r\n\r\n        if (hour < 0 || hour > 32767 || minute < 0 || minute > 32767 || second < 0 || second > 32767)\r\n            throw FormulaError.NUM;\r\n        return (3600 * hour + 60 * minute + second) / 86400;\r\n    },\r\n\r\n    TIMEVALUE: (timeText) => {\r\n        timeText = parseDate(timeText);\r\n        return (3600 * timeText.getUTCHours() + 60 * timeText.getUTCMinutes() + timeText.getUTCSeconds()) / 86400;\r\n    },\r\n\r\n    TODAY: () => {\r\n        const now = new Date();\r\n        return toSerial(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));\r\n    },\r\n\r\n    WEEKDAY: (serialOrString, returnType) => {\r\n        const date = parseDate(serialOrString);\r\n        returnType = H.accept(returnType, Types.NUMBER, 1);\r\n\r\n        const day = date.getUTCDay();\r\n        const weekTypes = WEEK_TYPES[returnType];\r\n        if (!weekTypes)\r\n            throw FormulaError.NUM;\r\n        return weekTypes[day];\r\n\r\n    },\r\n\r\n    WEEKNUM: (serialOrString, returnType) => {\r\n        const date = parseDate(serialOrString);\r\n        returnType = H.accept(returnType, Types.NUMBER, 1);\r\n        if (returnType === 21) {\r\n            return DateFunctions.ISOWEEKNUM(serialOrString);\r\n        }\r\n        const weekStart = WEEK_STARTS[returnType];\r\n        const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));\r\n        const offset = yearStart.getUTCDay() < weekStart ? 1 : 0;\r\n        return Math.ceil((((date - yearStart) / 86400000) + 1) / 7) + offset;\r\n    },\r\n\r\n    WORKDAY: (startDate, days, holidays) => {\r\n        return DateFunctions[\"WORKDAY.INTL\"](startDate, days, 1, holidays);\r\n    },\r\n\r\n    'WORKDAY.INTL': (startDate, days, weekend, holidays) => {\r\n        startDate = parseDate(startDate);\r\n        days = H.accept(days, Types.NUMBER);\r\n\r\n        weekend = H.accept(weekend, null, 1);\r\n        // Using 1111111 will always return value error.\r\n        if (weekend === '1111111')\r\n            throw FormulaError.VALUE;\r\n\r\n        // using weekend string, i.e, 0000011\r\n        if (typeof weekend === \"string\" && Number(weekend).toString() !== weekend) {\r\n            if (weekend.length !== 7)\r\n                throw FormulaError.VALUE;\r\n            weekend = weekend.charAt(6) + weekend.slice(0, 6);\r\n            const weekendArr = [];\r\n            for (let i = 0; i < weekend.length; i++) {\r\n                if (weekend.charAt(i) === '1')\r\n                    weekendArr.push(i);\r\n            }\r\n            weekend = weekendArr;\r\n        } else {\r\n            // using weekend number\r\n            if (typeof weekend !== \"number\")\r\n                throw FormulaError.VALUE;\r\n            weekend = WEEKEND_TYPES[weekend];\r\n            if (weekend == null)\r\n                throw FormulaError.NUM;\r\n        }\r\n\r\n        const holidaysArr = [];\r\n        if (holidays != null) {\r\n            H.flattenParams([holidays], Types.NUMBER, false, item => {\r\n                holidaysArr.push(parseDate(item));\r\n            });\r\n        }\r\n        startDate.setUTCDate(startDate.getUTCDate() + 1);\r\n        let cnt = 0;\r\n        while (cnt < days) {\r\n            let skip = false;\r\n            for (let i = 0; i < weekend.length; i++) {\r\n                if (weekend[i] === startDate.getUTCDay()) {\r\n                    skip = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!skip) {\r\n                let found = false;\r\n                for (let i = 0; i < holidaysArr.length; i++) {\r\n                    if (compareDateIgnoreTime(startDate, holidaysArr[i])) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) cnt++;\r\n            }\r\n            startDate.setUTCDate(startDate.getUTCDate() + 1);\r\n        }\r\n        return toSerial(startDate) - 1;\r\n    },\r\n\r\n    YEAR: (serialOrString) => {\r\n        const date = parseDate(serialOrString);\r\n        return date.getUTCFullYear();\r\n    },\r\n\r\n    // Warning: may have bugs\r\n    YEARFRAC: (startDate, endDate, basis) => {\r\n        startDate = parseDate(startDate);\r\n        endDate = parseDate(endDate);\r\n        if (startDate > endDate) {\r\n            const temp = startDate;\r\n            startDate = endDate;\r\n            endDate = temp;\r\n        }\r\n        basis = H.accept(basis, Types.NUMBER, 0);\r\n        basis = Math.trunc(basis);\r\n\r\n        if (basis < 0 || basis > 4)\r\n            throw FormulaError.VALUE;\r\n\r\n        // https://github.com/LesterLyu/formula.js/blob/develop/lib/date-time.js#L508\r\n        let sd = startDate.getUTCDate();\r\n        const sm = startDate.getUTCMonth() + 1;\r\n        const sy = startDate.getUTCFullYear();\r\n        let ed = endDate.getUTCDate();\r\n        const em = endDate.getUTCMonth() + 1;\r\n        const ey = endDate.getUTCFullYear();\r\n\r\n        switch (basis) {\r\n            case 0:\r\n                // US (NASD) 30/360\r\n                if (sd === 31 && ed === 31) {\r\n                    sd = 30;\r\n                    ed = 30;\r\n                } else if (sd === 31) {\r\n                    sd = 30;\r\n                } else if (sd === 30 && ed === 31) {\r\n                    ed = 30;\r\n                }\r\n                return Math.abs((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;\r\n            case 1:\r\n                // Actual/actual\r\n                if (ey - sy < 2) {\r\n                    const yLength = isLeapYear(sy) && sy !== 1900 ? 366 : 365;\r\n                    const days = DateFunctions.DAYS(endDate, startDate);\r\n                    return days / yLength;\r\n                } else {\r\n                    const years = (ey - sy) + 1;\r\n                    const days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;\r\n                    const average = days / years;\r\n                    return DateFunctions.DAYS(endDate, startDate) / average;\r\n                }\r\n            case 2:\r\n                // Actual/360\r\n                return Math.abs(DateFunctions.DAYS(endDate, startDate) / 360);\r\n            case 3:\r\n                // Actual/365\r\n                return Math.abs(DateFunctions.DAYS(endDate, startDate) / 365);\r\n            case 4:\r\n                // European 30/360\r\n                return Math.abs((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;\r\n        }\r\n    },\r\n};\r\n\r\nmodule.exports = DateFunctions;\r\n", "const FormulaError = require('../error');\r\nconst {FormulaHelpers, Types} = require('../helpers');\r\nconst H = FormulaHelpers;\r\n\r\nconst WebFunctions = {\r\n    ENCODEURL: text => {\r\n        return encodeURIComponent(H.accept(text, Types.STRING));\r\n    },\r\n\r\n    FILTERXML: () => {\r\n        // Not implemented due to extra dependency\r\n    },\r\n\r\n    WEBSERVICE: (context, url) => {\r\n        throw FormulaError.ERROR('WEBSERVICE is not supported in sync mode.');\r\n        if (typeof fetch === \"function\") {\r\n            url = H.accept(url, Types.STRING);\r\n            return fetch(url).then(res => res.text());\r\n        } else {\r\n            // Not implemented for Node.js due to extra dependency\r\n            // Sample code for Node.js\r\n            // const fetch = require('node-fetch');\r\n            // url = H.accept(url, Types.STRING);\r\n            // return fetch(url).then(res => res.text());\r\n            throw FormulaError.ERROR('WEBSERVICE only available to browser with fetch.' +\r\n                'If you want to use WEBSERVICE in Node.js, please override this function: \\n' +\r\n                'new FormulaParser({\\n' +\r\n                '    functionsNeedContext: {\\n' +\r\n                '        WEBSERVICE: (context, url) => {...}}\\n' +\r\n                '})');\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = WebFunctions;\r\n", "// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nexport const VERSION = \"7.1.2\"\n", "/*\n Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.\n These utils should replace usage of lodash in the production code base. not because they are any better...\n but for the purpose of being a dependency free library.\n\n The hotspots in the code are already written in imperative style for performance reasons.\n so writing several dozen utils which may be slower than the original lodash, does not matter as much\n considering they will not be invoked in hotspots...\n */\n\nexport function isEmpty(arr: any[]): boolean {\n  return arr && arr.length === 0\n}\n\nexport function keys(obj: any): string[] {\n  if (obj === undefined || obj === null) {\n    return []\n  }\n  return Object.keys(obj)\n}\n\nexport function values(obj: any): any[] {\n  let vals = []\n  let keys = Object.keys(obj)\n  for (let i = 0; i < keys.length; i++) {\n    vals.push(obj[keys[i]])\n  }\n  return vals\n}\n\nexport function mapValues<I, O>(\n  obj: Object,\n  callback: (value: I, key?: string) => O\n): O[] {\n  let result: O[] = []\n  let objKeys = keys(obj)\n  for (let idx = 0; idx < objKeys.length; idx++) {\n    let currKey = objKeys[idx]\n    result.push(callback.call(null, obj[currKey], currKey))\n  }\n  return result\n}\n\nexport function map<I, O>(arr: I[], callback: (I, idx?: number) => O): O[] {\n  let result: O[] = []\n  for (let idx = 0; idx < arr.length; idx++) {\n    result.push(callback.call(null, arr[idx], idx))\n  }\n  return result\n}\n\nexport function flatten<T>(arr: any[]): T[] {\n  let result = []\n\n  for (let idx = 0; idx < arr.length; idx++) {\n    let currItem = arr[idx]\n    if (Array.isArray(currItem)) {\n      result = result.concat(flatten(currItem))\n    } else {\n      result.push(currItem)\n    }\n  }\n  return result\n}\n\nexport function first<T>(arr: T[]): T {\n  return isEmpty(arr) ? undefined : arr[0]\n}\n\nexport function last<T>(arr: T[]): T {\n  let len = arr && arr.length\n  return len ? arr[len - 1] : undefined\n}\n\nexport function forEach(collection: any, iteratorCallback: Function): void {\n  /* istanbul ignore else */\n  if (Array.isArray(collection)) {\n    for (let i = 0; i < collection.length; i++) {\n      iteratorCallback.call(null, collection[i], i)\n    }\n  } else if (isObject(collection)) {\n    let colKeys = keys(collection)\n    for (let i = 0; i < colKeys.length; i++) {\n      let key = colKeys[i]\n      let value = collection[key]\n      iteratorCallback.call(null, value, key)\n    }\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function isString(item: any): boolean {\n  return typeof item === \"string\"\n}\n\nexport function isUndefined(item: any): boolean {\n  return item === undefined\n}\n\nexport function isFunction(item: any): boolean {\n  return item instanceof Function\n}\n\nexport function drop<T>(arr: T[], howMuch: number = 1): T[] {\n  return arr.slice(howMuch, arr.length)\n}\n\nexport function dropRight<T>(arr: T[], howMuch: number = 1): T[] {\n  return arr.slice(0, arr.length - howMuch)\n}\n\nexport function filter<T>(arr: T[], predicate: (T) => boolean): T[] {\n  let result = []\n  if (Array.isArray(arr)) {\n    for (let i = 0; i < arr.length; i++) {\n      let item = arr[i]\n      if (predicate.call(null, item)) {\n        result.push(item)\n      }\n    }\n  }\n  return result\n}\n\nexport function reject<T>(arr: T[], predicate: (T) => boolean): T[] {\n  return filter(arr, (item) => !predicate(item))\n}\n\nexport function pick(obj: Object, predicate: (item) => boolean) {\n  let keys = Object.keys(obj)\n  let result = {}\n\n  for (let i = 0; i < keys.length; i++) {\n    let currKey = keys[i]\n    let currItem = obj[currKey]\n    if (predicate(currItem)) {\n      result[currKey] = currItem\n    }\n  }\n\n  return result\n}\n\nexport function has(obj: any, prop: string): boolean {\n  if (isObject(obj)) {\n    return obj.hasOwnProperty(prop)\n  }\n  return false\n}\n\nexport function contains<T>(arr: T[], item): boolean {\n  return find(arr, (currItem) => currItem === item) !== undefined ? true : false\n}\n\n/**\n * shallow clone\n */\nexport function cloneArr<T>(arr: T[]): T[] {\n  let newArr = []\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i])\n  }\n  return newArr\n}\n\n/**\n * shallow clone\n */\nexport function cloneObj(obj: Object): any {\n  let clonedObj = {}\n  for (let key in obj) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clonedObj[key] = obj[key]\n    }\n  }\n  return clonedObj\n}\n\nexport function find<T>(arr: T[], predicate: (item: T) => boolean): T {\n  for (let i = 0; i < arr.length; i++) {\n    let item = arr[i]\n    if (predicate.call(null, item)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findAll<T>(arr: T[], predicate: (item: T) => boolean): T[] {\n  let found = []\n  for (let i = 0; i < arr.length; i++) {\n    let item = arr[i]\n    if (predicate.call(null, item)) {\n      found.push(item)\n    }\n  }\n  return found\n}\n\nexport function reduce<T, A>(\n  arrOrObj: Array<T> | Object,\n  iterator: (result: A, item, idx?) => A,\n  initial: A\n): A {\n  const isArr = Array.isArray(arrOrObj)\n\n  let vals: T[] = isArr ? <Array<T>>arrOrObj : values(arrOrObj)\n  let objKeys = isArr ? [] : keys(arrOrObj)\n\n  let accumulator = initial\n  for (let i = 0; i < vals.length; i++) {\n    accumulator = iterator.call(\n      null,\n      accumulator,\n      vals[i],\n      isArr ? i : objKeys[i]\n    )\n  }\n  return accumulator\n}\n\nexport function compact<T>(arr: T[]): T[] {\n  return reject(arr, (item) => item === null || item === undefined)\n}\n\nexport function uniq<T>(\n  arr: T[],\n  identity: (item: T) => any = (item) => item\n): T[] {\n  let identities = []\n  return reduce(\n    arr,\n    (result, currItem) => {\n      let currIdentity = identity(currItem)\n      if (contains(identities, currIdentity)) {\n        return result\n      } else {\n        identities.push(currIdentity)\n        return result.concat(currItem)\n      }\n    },\n    []\n  )\n}\n\nexport function partial(func: Function, ...restArgs: any[]): Function {\n  let firstArg = [null]\n  let allArgs = firstArg.concat(restArgs)\n  return Function.bind.apply(func, allArgs)\n}\n\nexport function isArray(obj: any): obj is any[] {\n  return Array.isArray(obj)\n}\n\nexport function isRegExp(obj: any): obj is RegExp {\n  return obj instanceof RegExp\n}\n\nexport function isObject(obj: any): obj is Object {\n  return obj instanceof Object\n}\n\nexport function every<T>(\n  arr: T[],\n  predicate: (item: T, idx?) => boolean\n): boolean {\n  for (let i = 0; i < arr.length; i++) {\n    if (!predicate(arr[i], i)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function difference<T>(arr: T[], values: T[]): T[] {\n  return reject(arr, (item) => contains(values, item))\n}\n\nexport function some<T>(arr: T[], predicate: (item: T) => boolean): boolean {\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function indexOf<T>(arr: T[], value: T): number {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      return i\n    }\n  }\n  return -1\n}\n\nexport function sortBy<T>(arr: T[], orderFunc: (item: T) => number): T[] {\n  let result = cloneArr(arr)\n  result.sort((a, b) => orderFunc(a) - orderFunc(b))\n  return result\n}\n\nexport function zipObject(keys: any[], values: any[]): Object {\n  if (keys.length !== values.length) {\n    throw Error(\"can't zipObject with different number of keys and values!\")\n  }\n\n  let result = {}\n  for (let i = 0; i < keys.length; i++) {\n    result[keys[i]] = values[i]\n  }\n  return result\n}\n\n/**\n * mutates! (and returns) target\n */\nexport function assign(target: Object, ...sources: Object[]): Object {\n  for (let i = 0; i < sources.length; i++) {\n    let curSource = sources[i]\n    let currSourceKeys = keys(curSource)\n    for (let j = 0; j < currSourceKeys.length; j++) {\n      let currKey = currSourceKeys[j]\n      target[currKey] = curSource[currKey]\n    }\n  }\n  return target\n}\n\n/**\n * mutates! (and returns) target\n */\nexport function assignNoOverwrite(\n  target: Object,\n  ...sources: Object[]\n): Object {\n  for (let i = 0; i < sources.length; i++) {\n    let curSource = sources[i]\n    let currSourceKeys = keys(curSource)\n    for (let j = 0; j < currSourceKeys.length; j++) {\n      let currKey = currSourceKeys[j]\n      if (!has(target, currKey)) {\n        target[currKey] = curSource[currKey]\n      }\n    }\n  }\n  return target\n}\n\nexport function defaults(...sources: any[]): any {\n  return assignNoOverwrite.apply(null, [{}].concat(sources))\n}\n\nexport function groupBy<T>(\n  arr: T[],\n  groupKeyFunc: (item: T) => string\n): { [groupKey: string]: T[] } {\n  let result: { [groupKey: string]: T[] } = {}\n\n  forEach(arr, (item) => {\n    let currGroupKey = groupKeyFunc(item)\n    let currGroupArr = result[currGroupKey]\n\n    if (currGroupArr) {\n      currGroupArr.push(item)\n    } else {\n      result[currGroupKey] = [item]\n    }\n  })\n\n  return result\n}\n\n/**\n * Merge obj2 into obj1.\n * Will overwrite existing properties with the same name\n */\nexport function merge(obj1: Object, obj2: Object): any {\n  let result = cloneObj(obj1)\n  let keys2 = keys(obj2)\n  for (let i = 0; i < keys2.length; i++) {\n    let key = keys2[i]\n    let value = obj2[key]\n    result[key] = value\n  }\n\n  return result\n}\n\nexport function NOOP() {}\n\nexport function IDENTITY(item) {\n  return item\n}\n\n/**\n * Will return a new packed array with same values.\n */\nexport function packArray<T>(holeyArr: T[]): T[] {\n  const result = []\n  for (let i = 0; i < holeyArr.length; i++) {\n    const orgValue = holeyArr[i]\n    result.push(orgValue !== undefined ? orgValue : undefined)\n  }\n  return result\n}\n\nexport function PRINT_ERROR(msg) {\n  /* istanbul ignore else - can't override global.console in node.js */\n  if (console && console.error) {\n    console.error(`Error: ${msg}`)\n  }\n}\n\nexport function PRINT_WARNING(msg) {\n  /* istanbul ignore else - can't override global.console in node.js*/\n  if (console && console.warn) {\n    // TODO: modify docs accordingly\n    console.warn(`Warning: ${msg}`)\n  }\n}\n\nexport function isES2015MapSupported(): boolean {\n  return typeof Map === \"function\"\n}\n\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return\n      }\n\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(\n        baseProto,\n        propName\n      )\n      // Handle Accessors\n      if (\n        basePropDescriptor &&\n        (basePropDescriptor.get || basePropDescriptor.set)\n      ) {\n        Object.defineProperty(\n          derivedCtor.prototype,\n          propName,\n          basePropDescriptor\n        )\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName]\n      }\n    })\n  })\n}\n\n// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast) {\n  function FakeConstructor() {}\n  // If our object is used as a constructor it would receive\n  FakeConstructor.prototype = toBecomeFast\n  const fakeInstance = new FakeConstructor()\n  function fakeAccess() {\n    return typeof fakeInstance.bar\n  }\n  // help V8 understand this is a \"real\" prototype by actually using\n  // the fake instance.\n  fakeAccess()\n  fakeAccess()\n\n  return toBecomeFast\n  // Eval prevents optimization of this method (even though this is dead code)\n  /* istanbul ignore next */\n  // tslint:disable-next-line\n  eval(toBecomeFast)\n}\n\nexport function peek<T>(arr: T[]): T {\n  return arr[arr.length - 1]\n}\n\n/* istanbul ignore next - for performance tracing*/\nexport function timer<T>(func: () => T): { time: number; value: T } {\n  const start = new Date().getTime()\n  const val = func()\n  const end = new Date().getTime()\n  const total = end - start\n  return { time: total, value: val }\n}\n", ";(function(root, factory) {\n    // istanbul ignore next\n    if (typeof define === \"function\" && define.amd) {\n        // istanbul ignore next\n        define([], factory)\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n    } else {\n        // istanbul ignore next\n        root.regexpToAst = factory()\n    }\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead \u2209 DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n", "import { RegExpParser, RegExpPattern } from \"regexp-to-ast\"\n\nlet regExpAstCache = {}\nconst regExpParser = new RegExpParser()\n\nexport function getRegExpAst(regExp: RegExp): RegExpPattern {\n  const regExpStr = regExp.toString()\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr]\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr)\n    regExpAstCache[regExpStr] = regExpAst\n    return regExpAst\n  }\n}\n\nexport function clearRegExpParserCache() {\n  regExpAstCache = {}\n}\n", "import { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\"\nimport {\n  flatten,\n  map,\n  forEach,\n  contains,\n  PRINT_ERROR,\n  PRINT_WARNING,\n  find,\n  isArray,\n  every,\n  values\n} from \"../utils/utils\"\nimport { getRegExpAst } from \"./reg_exp_parser\"\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\"\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\"\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n'\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp)\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase\n    )\n    return firstChars\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"\n        )\n      }\n    } else {\n      let msgSuffix = \"\"\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the regexp-to-ast library version: ${VERSION}\\n` +\n          \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n          msgSuffix\n      )\n    }\n  }\n\n  return []\n}\n\nexport function firstCharOptimizedIndices(ast, result, ignoreCase): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n      }\n      break\n    case \"Alternative\":\n      const terms = ast.value\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i]\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue\n        }\n\n        const atom = term\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase)\n            break\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage)\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase)\n              } else {\n                // range\n                const range = code\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal\n                    const maxUnOptVal = range.to\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx\n                    }\n                  }\n                }\n              }\n            })\n            break\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase)\n            break\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\")\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break\n        }\n      }\n      break\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\")\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result)\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: number[],\n  ignoreCase: boolean\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code)\n  result[optimizedCharIdx] = optimizedCharIdx\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result)\n  }\n}\n\nfunction handleIgnoreCase(code: number, result: number[]) {\n  const char = String.fromCharCode(code)\n  const upperChar = char.toUpperCase()\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n    result[optimizedCharIdx] = optimizedCharIdx\n  } else {\n    const lowerChar = char.toLowerCase()\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    }\n  }\n}\n\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return contains(targetCharCodes, codeOrRange)\n    } else {\n      // range\n      const range = <any>codeOrRange\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to\n        ) !== undefined\n      )\n    }\n  })\n}\n\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true\n  }\n\n  if (!ast.value) {\n    return false\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value)\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false\n\n  constructor(private targetCharCodes: number[]) {\n    super()\n  }\n\n  visitChildren(node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node)\n        return\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node)\n        return\n    }\n\n    super.visitChildren(node)\n  }\n\n  visitCharacter(node) {\n    if (contains(this.targetCharCodes, node.value)) {\n      this.found = true\n    }\n  }\n\n  visitSet(node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern)\n    const charCodeFinder = new CharCodeFinder(charCodes)\n    charCodeFinder.visit(ast)\n    return charCodeFinder.found\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return contains(charCodes, (<string>char).charCodeAt(0))\n      }) !== undefined\n    )\n  }\n}\n", "import { BaseRegExpVisitor } from \"regexp-to-ast\"\nimport { IRegExpExec, Lexer, LexerDefinitionErrorType } from \"./lexer_public\"\nimport {\n  compact,\n  contains,\n  defaults,\n  difference,\n  filter,\n  find,\n  first,\n  flatten,\n  forEach,\n  has,\n  indexOf,\n  isArray,\n  isEmpty,\n  isFunction,\n  isRegExp,\n  isString,\n  isUndefined,\n  keys,\n  map,\n  mapValues,\n  packArray,\n  PRINT_ERROR,\n  reduce,\n  reject\n} from \"../utils/utils\"\nimport {\n  canMatchCharCode,\n  failedOptimizationPrefixMsg,\n  getOptimizedStartCodesIndices\n} from \"./reg_exp\"\nimport {\n  ILexerDefinitionError,\n  ILineTerminatorsTester,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"../../api\"\nimport { getRegExpAst } from \"./reg_exp_parser\"\n\nconst PATTERN = \"PATTERN\"\nexport const DEFAULT_MODE = \"defaultMode\"\nexport const MODES = \"modes\"\n\nexport interface IPatternConfig {\n  pattern: IRegExpExec\n  longerAlt: number\n  canLineTerminator: boolean\n  isCustom: boolean\n  short: number | boolean\n  group: any\n  push: string\n  pop: boolean\n  tokenTypeIdx: number\n}\n\nexport interface IAnalyzeResult {\n  patternIdxToConfig: IPatternConfig[]\n  charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] }\n  emptyGroups: { [groupName: string]: IToken[] }\n  hasCustom: boolean\n  canBeOptimized: boolean\n}\n\nexport let SUPPORT_STICKY =\n  typeof (<any>new RegExp(\"(?:)\")).sticky === \"boolean\"\n\nexport function disableSticky() {\n  SUPPORT_STICKY = false\n}\n\nexport function enableSticky() {\n  SUPPORT_STICKY = true\n}\n\nexport function analyzeTokenTypes(\n  tokenTypes: TokenType[],\n  options: {\n    positionTracking?: \"full\" | \"onlyStart\" | \"onlyOffset\"\n    ensureOptimizations?: boolean\n    lineTerminatorCharacters?: (number | string)[]\n    // TODO: should `useSticky` be an argument here?\n    useSticky?: boolean\n    safeMode?: boolean\n    tracer?: (msg: string, action: Function) => void\n  }\n): IAnalyzeResult {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg, action) => action()\n  })\n\n  const tracer = options.tracer\n\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap()\n  })\n\n  let onlyRelevantTypes\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA\n    })\n  })\n\n  let hasCustom = false\n  let allTransformedPatterns\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false\n    allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n      let currPattern = currType[PATTERN]\n\n      /* istanbul ignore else */\n      if (isRegExp(currPattern)) {\n        let regExpSource = currPattern.source\n        if (\n          regExpSource.length === 1 &&\n          // only these regExp meta characters which can appear in a length one regExp\n          regExpSource !== \"^\" &&\n          regExpSource !== \"$\" &&\n          regExpSource !== \".\" &&\n          !currPattern.ignoreCase\n        ) {\n          return regExpSource\n        } else if (\n          regExpSource.length === 2 &&\n          regExpSource[0] === \"\\\\\" &&\n          // not a meta character\n          !contains(\n            [\n              \"d\",\n              \"D\",\n              \"s\",\n              \"S\",\n              \"t\",\n              \"r\",\n              \"n\",\n              \"t\",\n              \"0\",\n              \"c\",\n              \"b\",\n              \"B\",\n              \"f\",\n              \"v\",\n              \"w\",\n              \"W\"\n            ],\n            regExpSource[1]\n          )\n        ) {\n          // escaped meta Characters: /\\+/ /\\[/\n          // or redundant escaping: /\\a/\n          // without the escaping \"\\\"\n          return regExpSource[1]\n        } else {\n          return options.useSticky\n            ? addStickyFlag(currPattern)\n            : addStartOfInput(currPattern)\n        }\n      } else if (isFunction(currPattern)) {\n        hasCustom = true\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return { exec: currPattern }\n      } else if (has(currPattern, \"exec\")) {\n        hasCustom = true\n        // ICustomPattern\n        return currPattern\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern\n        } else {\n          let escapedRegExpString = currPattern.replace(\n            /[\\\\^$.*+?()[\\]{}|]/g,\n            \"\\\\$&\"\n          )\n          let wrappedRegExp = new RegExp(escapedRegExpString)\n          return options.useSticky\n            ? addStickyFlag(wrappedRegExp)\n            : addStartOfInput(wrappedRegExp)\n        }\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n  })\n\n  let patternIdxToType\n  let patternIdxToGroup\n  let patternIdxToLongerAltIdx\n  let patternIdxToPushMode\n  let patternIdxToPopMode\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map(\n      onlyRelevantTypes,\n      (currType) => currType.tokenTypeIdx\n    )\n\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz: any) => {\n      let groupName = clazz.GROUP\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined\n      } else if (isString(groupName)) {\n        return groupName\n      } else if (isUndefined(groupName)) {\n        return false\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n\n    patternIdxToLongerAltIdx = map(onlyRelevantTypes, (clazz: any) => {\n      let longerAltType = clazz.LONGER_ALT\n\n      if (longerAltType) {\n        let longerAltIdx = indexOf(onlyRelevantTypes, longerAltType)\n        return longerAltIdx\n      }\n    })\n\n    patternIdxToPushMode = map(\n      onlyRelevantTypes,\n      (clazz: any) => clazz.PUSH_MODE\n    )\n\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz: any) =>\n      has(clazz, \"POP_MODE\")\n    )\n  })\n\n  let patternIdxToCanLineTerminator\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(\n      options.lineTerminatorCharacters\n    )\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false)\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return tokType.LINE_BREAKS\n        } else {\n          if (\n            checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false\n          ) {\n            return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n          }\n        }\n      })\n    }\n  })\n\n  let patternIdxToIsCustom\n  let patternIdxToShort\n  let emptyGroups\n  let patternIdxToConfig\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern)\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern)\n\n    emptyGroups = reduce(\n      onlyRelevantTypes,\n      (acc, clazz: any) => {\n        let groupName = clazz.GROUP\n        if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n          acc[groupName] = []\n        }\n        return acc\n      },\n      {}\n    )\n\n    patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdx[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      }\n    })\n  })\n\n  let canBeOptimized = true\n  let charCodeToPatternIdxToConfig = []\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce(\n        onlyRelevantTypes,\n        (result, currTokType, idx) => {\n          if (typeof currTokType.PATTERN === \"string\") {\n            const charCode = currTokType.PATTERN.charCodeAt(0)\n            const optimizedIdx = charCodeToOptimizedIndex(charCode)\n            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx])\n          } else if (isArray(currTokType.START_CHARS_HINT)) {\n            let lastOptimizedIdx\n            forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n              const charCode =\n                typeof charOrInt === \"string\"\n                  ? charOrInt.charCodeAt(0)\n                  : charOrInt\n              const currOptimizedIdx = charCodeToOptimizedIndex(charCode)\n              // Avoid adding the config multiple times\n              /* istanbul ignore else */\n              // - Difficult to check this scenario effects as it is only a performance\n              //   optimization that does not change correctness\n              if (lastOptimizedIdx !== currOptimizedIdx) {\n                lastOptimizedIdx = currOptimizedIdx\n                addToMapOfArrays(\n                  result,\n                  currOptimizedIdx,\n                  patternIdxToConfig[idx]\n                )\n              }\n            })\n          } else if (isRegExp(currTokType.PATTERN)) {\n            if (currTokType.PATTERN.unicode) {\n              canBeOptimized = false\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                    \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\"\n                )\n              }\n            } else {\n              let optimizedCodes = getOptimizedStartCodesIndices(\n                currTokType.PATTERN,\n                options.ensureOptimizations\n              )\n              /* istanbul ignore if */\n              // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n              // the first should be a different validation and the second cannot be tested.\n              if (isEmpty(optimizedCodes)) {\n                // we cannot understand what codes may start possible matches\n                // The optimization correctness requires knowing start codes for ALL patterns.\n                // Not actually sure this is an error, no debug message\n                canBeOptimized = false\n              }\n              forEach(optimizedCodes, (code) => {\n                addToMapOfArrays(result, code, patternIdxToConfig[idx])\n              })\n            }\n          } else {\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\n                `${failedOptimizationPrefixMsg}` +\n                  `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                  \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                  \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"\n              )\n            }\n            canBeOptimized = false\n          }\n\n          return result\n        },\n        []\n      )\n    })\n  }\n  tracer(\"ArrayPacking\", () => {\n    charCodeToPatternIdxToConfig = packArray(charCodeToPatternIdxToConfig)\n  })\n\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  }\n}\n\nexport function validatePatterns(\n  tokenTypes: TokenType[],\n  validModesNames: string[]\n): ILexerDefinitionError[] {\n  let errors = []\n\n  let missingResult = findMissingPatterns(tokenTypes)\n  errors = errors.concat(missingResult.errors)\n\n  let invalidResult = findInvalidPatterns(missingResult.valid)\n  let validTokenTypes = invalidResult.valid\n  errors = errors.concat(invalidResult.errors)\n\n  errors = errors.concat(validateRegExpPattern(validTokenTypes))\n\n  errors = errors.concat(findInvalidGroupType(validTokenTypes))\n\n  errors = errors.concat(\n    findModesThatDoNotExist(validTokenTypes, validModesNames)\n  )\n\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes))\n\n  return errors\n}\n\nfunction validateRegExpPattern(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let errors = []\n  let withRegExpPatterns = filter(tokenTypes, (currTokType) =>\n    isRegExp(currTokType[PATTERN])\n  )\n\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns))\n\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns))\n\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns))\n\n  return errors\n}\n\nexport interface ILexerFilterResult {\n  errors: ILexerDefinitionError[]\n  valid: TokenType[]\n}\n\nexport function findMissingPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  let tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n    return !has(currType, PATTERN)\n  })\n\n  let errors = map(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  let valid = difference(tokenTypes, tokenTypesWithMissingPattern)\n  return { errors, valid }\n}\n\nexport function findInvalidPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  let tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n    let pattern = currType[PATTERN]\n    return (\n      !isRegExp(pattern) &&\n      !isFunction(pattern) &&\n      !has(pattern, \"exec\") &&\n      !isString(pattern)\n    )\n  })\n\n  let errors = map(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' can only be a RegExp, a\" +\n        \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  let valid = difference(tokenTypes, tokenTypesWithInvalidPattern)\n  return { errors, valid }\n}\n\nconst end_of_input = /[^\\\\][\\$]/\n\nexport function findEndOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitEndAnchor(node) {\n      this.found = true\n    }\n  }\n\n  let invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n\n    try {\n      const regexpAst = getRegExpAst(pattern)\n      const endAnchorVisitor = new EndAnchorFinder()\n      endAnchorVisitor.visit(regexpAst)\n\n      return endAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test(pattern.source)\n    }\n  })\n\n  let errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n        \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findEmptyMatchRegExps(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let matchesEmptyString = filter(tokenTypes, (currType) => {\n    let pattern = currType[PATTERN]\n    return pattern.test(\"\")\n  })\n\n  let errors = map(matchesEmptyString, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nconst start_of_input = /[^\\\\[][\\^]|^\\^/\n\nexport function findStartOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitStartAnchor(node) {\n      this.found = true\n    }\n  }\n\n  let invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n    try {\n      const regexpAst = getRegExpAst(pattern)\n      const startAnchorVisitor = new StartAnchorFinder()\n      startAnchorVisitor.visit(regexpAst)\n\n      return startAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source)\n    }\n  })\n\n  let errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnsupportedFlags(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let invalidFlags = filter(tokenTypes, (currType) => {\n    let pattern = currType[PATTERN]\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global)\n  })\n\n  let errors = map(invalidFlags, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let found = []\n  let identicalPatterns = map(tokenTypes, (outerType: any) => {\n    return reduce(\n      tokenTypes,\n      (result, innerType: any) => {\n        if (\n          outerType.PATTERN.source === innerType.PATTERN.source &&\n          !contains(found, innerType) &&\n          innerType.PATTERN !== Lexer.NA\n        ) {\n          // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n          // in essence we are creating Equivalence classes on equality relation.\n          found.push(innerType)\n          result.push(innerType)\n          return result\n        }\n        return result\n      },\n      []\n    )\n  })\n\n  identicalPatterns = compact(identicalPatterns)\n\n  let duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1\n  })\n\n  let errors = map(duplicatePatterns, (setOfIdentical: any) => {\n    let tokenTypeNames = map(setOfIdentical, (currType: any) => {\n      return currType.name\n    })\n\n    let dupPatternSrc = (<any>first(setOfIdentical)).PATTERN\n    return {\n      message:\n        `The same RegExp pattern ->${dupPatternSrc}<-` +\n        `has been used in all of the following Token Types: ${tokenTypeNames.join(\n          \", \"\n        )} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    }\n  })\n\n  return errors\n}\n\nexport function findInvalidGroupType(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let invalidTypes = filter(tokenTypes, (clazz: any) => {\n    if (!has(clazz, \"GROUP\")) {\n      return false\n    }\n    let group = clazz.GROUP\n\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group)\n  })\n\n  let errors = map(invalidTypes, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findModesThatDoNotExist(\n  tokenTypes: TokenType[],\n  validModes: string[]\n): ILexerDefinitionError[] {\n  let invalidModes = filter(tokenTypes, (clazz: any) => {\n    return (\n      clazz.PUSH_MODE !== undefined && !contains(validModes, clazz.PUSH_MODE)\n    )\n  })\n\n  let errors = map(invalidModes, (tokType) => {\n    let msg =\n      `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n      `which does not exist`\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnreachablePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const errors = []\n\n  const canBeTested = reduce(\n    tokenTypes,\n    (result, tokType, idx) => {\n      const pattern = tokType.PATTERN\n\n      if (pattern === Lexer.NA) {\n        return result\n      }\n\n      // a more comprehensive validation for all forms of regExps would require\n      // deeper regExp analysis capabilities\n      if (isString(pattern)) {\n        result.push({ str: pattern, idx, tokenType: tokType })\n      } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n        result.push({ str: pattern.source, idx, tokenType: tokType })\n      }\n      return result\n    },\n    []\n  )\n\n  forEach(tokenTypes, (tokType, testIdx) => {\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        let msg =\n          `Token: ->${tokenType.name}<- can never be matched.\\n` +\n          `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n          `in the lexer's definition.\\n` +\n          `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nfunction testTokenType(str: string, pattern: any): boolean {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    const regExpArray = pattern.exec(str)\n    return regExpArray !== null && regExpArray.index === 0\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {})\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {})\n  } else if (typeof pattern === \"string\") {\n    return pattern === str\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction noMetaChar(regExp: RegExp): boolean {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\"\n  ]\n  return (\n    find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  )\n}\n\nexport function addStartOfInput(pattern: RegExp): RegExp {\n  let flags = pattern.ignoreCase ? \"i\" : \"\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`^(?:${pattern.source})`, flags)\n}\n\nexport function addStickyFlag(pattern: RegExp): RegExp {\n  let flags = pattern.ignoreCase ? \"iy\" : \"y\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`${pattern.source}`, flags)\n}\n\nexport function performRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  let errors = []\n\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        DEFAULT_MODE +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    })\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        MODES +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    })\n  }\n\n  if (\n    has(lexerDefinition, MODES) &&\n    has(lexerDefinition, DEFAULT_MODE) &&\n    !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n  ) {\n    errors.push({\n      message:\n        `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n        `which does not exist\\n`,\n      type:\n        LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    })\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message:\n              `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n              `<${currModeName}> at index: <${currIdx}>\\n`,\n            type:\n              LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          })\n        }\n      })\n    })\n  }\n\n  return errors\n}\n\nexport function performWarningRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  const warnings = []\n  let hasAnyLineBreak = false\n  const allTokenTypes = compact(\n    flatten(mapValues(lexerDefinition.modes, (tokTypes) => tokTypes))\n  )\n\n  const concreteTokenTypes = reject(\n    allTokenTypes,\n    (currType) => currType[PATTERN] === Lexer.NA\n  )\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters)\n  if (trackLines) {\n    forEach(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes)\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue)\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType\n        }\n        warnings.push(warningDescriptor)\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true\n          }\n        }\n      }\n    })\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message:\n        \"Warning: No LINE_BREAKS Found.\\n\" +\n        \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n        \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    })\n  }\n  return warnings\n}\n\nexport function cloneEmptyGroups(emptyGroups: {\n  [groupName: string]: IToken\n}): { [groupName: string]: IToken } {\n  let clonedResult: any = {}\n  let groupKeys = keys(emptyGroups)\n\n  forEach(groupKeys, (currKey) => {\n    let currGroupValue = emptyGroups[currKey]\n\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = []\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  })\n\n  return clonedResult\n}\n\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType: any): boolean {\n  let pattern = tokenType.PATTERN\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true\n  } else if (isString(pattern)) {\n    return false\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function isShortPattern(pattern: any): number | boolean {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0)\n  } else {\n    return false\n  }\n}\n\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester: ILineTerminatorsTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    let len = text.length\n    for (let i = this.lastIndex; i < len; i++) {\n      let c = text.charCodeAt(i)\n      if (c === 10) {\n        this.lastIndex = i + 1\n        return true\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2\n        } else {\n          this.lastIndex = i + 1\n        }\n        return true\n      }\n    }\n    return false\n  },\n\n  lastIndex: 0\n}\n\nfunction checkLineBreaksIssues(\n  tokType: TokenType,\n  lineTerminatorCharCodes: number[]\n):\n  | {\n      issue:\n        | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n        | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      errMsg?: string\n    }\n  | false {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        }\n      }\n      return false\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK }\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(\n  tokType: TokenType,\n  details: {\n    issue:\n      | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n      | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n    errMsg?: string\n  }\n): string {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return (\n      \"Warning: unable to identify line terminator usage in pattern.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      `\\t Root cause: ${details.errMsg}.\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\"\n    )\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return (\n      \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\"\n    )\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction getCharCodes(charsOrCodes: (number | string)[]): number[] {\n  const charCodes = map(charsOrCodes, (numOrString) => {\n    if (isString(numOrString) && numOrString.length > 0) {\n      return numOrString.charCodeAt(0)\n    } else {\n      return numOrString\n    }\n  })\n\n  return charCodes\n}\n\nfunction addToMapOfArrays(map, key, value): void {\n  if (map[key] === undefined) {\n    map[key] = [value]\n  } else {\n    map[key].push(value)\n  }\n}\n\nexport const minOptimizationVal = 256\n\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nexport function charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal\n    ? charCode\n    : charCodeToOptimizedIdxMap[charCode]\n}\n\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nlet charCodeToOptimizedIdxMap = []\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536)\n    for (let i = 0; i < 65536; i++) {\n      /* tslint:disable */\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i\n      /* tslint:enable */\n    }\n  }\n}\n", "import {\n  cloneArr,\n  compact,\n  contains,\n  difference,\n  flatten,\n  forEach,\n  has,\n  isArray,\n  isEmpty,\n  map\n} from \"../utils/utils\"\nimport { TokenType } from \"../../api\"\n\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n  const instanceType = tokInstance.tokenTypeIdx\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true\n  } else {\n    return (\n      tokConstructor.isParent === true &&\n      tokConstructor.categoryMatchesMap[instanceType] === true\n    )\n  }\n}\n\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx\n}\n\nexport let tokenShortNameIdx = 1\nexport const tokenIdxToClass = {}\n\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\n  // collect the parent Token Types as well.\n  let tokenTypesAndParents = expandCategories(tokenTypes)\n\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents)\n\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents)\n  assignCategoriesTokensProp(tokenTypesAndParents)\n\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches.length > 0\n  })\n}\n\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\n  let result = cloneArr(tokenTypes)\n\n  let categories = tokenTypes\n  let searching = true\n  while (searching) {\n    categories = compact(\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES))\n    )\n\n    let newCategories = difference(categories, result)\n\n    result = result.concat(newCategories)\n\n    if (isEmpty(newCategories)) {\n      searching = false\n    } else {\n      categories = newCategories\n    }\n  }\n  return result\n}\n\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType\n      ;(<any>currTokType).tokenTypeIdx = tokenShortNameIdx++\n    }\n\n    // CATEGORIES? : TokenType | TokenType[]\n    if (\n      hasCategoriesProperty(currTokType) &&\n      !isArray(currTokType.CATEGORIES)\n      // &&\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES]\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = []\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = []\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {}\n    }\n  })\n}\n\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    // avoid duplications\n    currTokType.categoryMatches = []\n    forEach(currTokType.categoryMatchesMap, (val, key) => {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx)\n    })\n  })\n}\n\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType)\n  })\n}\n\nexport function singleAssignCategoriesToksMap(\n  path: TokenType[],\n  nextNode: TokenType\n): void {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true\n  })\n\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode)\n    // avoids infinite loops due to cyclic categories.\n    if (!contains(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory)\n    }\n  })\n}\n\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"CATEGORIES\")\n}\n\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"categoryMatches\")\n}\n\nexport function hasExtendingTokensTypesMapProperty(\n  tokType: TokenType\n): boolean {\n  return has(tokType, \"categoryMatchesMap\")\n}\n\nexport function isTokenType(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n", "import { ILexerErrorMessageProvider, IToken } from \"../../api\"\n\nexport const defaultLexerErrorProvider: ILexerErrorMessageProvider = {\n  buildUnableToPopLexerModeMessage(token: IToken): string {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`\n  },\n\n  buildUnexpectedCharactersMessage(\n    fullText: string,\n    startOffset: number,\n    length: number,\n    line?: number,\n    column?: number\n  ): string {\n    return (\n      `unexpected character: ->${fullText.charAt(\n        startOffset\n      )}<- at offset: ${startOffset},` + ` skipped ${length} characters.`\n    )\n  }\n}\n", "import {\n  analyzeTokenTypes,\n  charCodeToOptimizedIndex,\n  cloneEmptyGroups,\n  DEFAULT_MODE,\n  LineTerminatorOptimizedTester,\n  performRuntimeChecks,\n  performWarningRuntimeChecks,\n  SUPPORT_STICKY,\n  validatePatterns\n} from \"./lexer\"\nimport {\n  cloneArr,\n  cloneObj,\n  forEach,\n  IDENTITY,\n  isArray,\n  isEmpty,\n  isUndefined,\n  keys,\n  last,\n  map,\n  merge,\n  NOOP,\n  PRINT_WARNING,\n  reduce,\n  reject,\n  timer,\n  toFastProperties\n} from \"../utils/utils\"\nimport { augmentTokenTypes } from \"./tokens\"\nimport {\n  CustomPatternMatcherFunc,\n  ILexerConfig,\n  ILexerDefinitionError,\n  ILexingError,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"../../api\"\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\"\nimport { clearRegExpParserCache } from \"./reg_exp_parser\"\n\nexport interface ILexingResult {\n  tokens: IToken[]\n  groups: { [groupName: string]: IToken[] }\n  errors: ILexingError[]\n}\n\nexport enum LexerDefinitionErrorType {\n  MISSING_PATTERN,\n  INVALID_PATTERN,\n  EOI_ANCHOR_FOUND,\n  UNSUPPORTED_FLAGS_FOUND,\n  DUPLICATE_PATTERNS_FOUND,\n  INVALID_GROUP_TYPE_FOUND,\n  PUSH_MODE_DOES_NOT_EXIST,\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n  SOI_ANCHOR_FOUND,\n  EMPTY_MATCH_PATTERN,\n  NO_LINE_BREAKS_FLAGS,\n  UNREACHABLE_PATTERN,\n  IDENTIFY_TERMINATOR,\n  CUSTOM_LINE_BREAK\n}\n\nexport interface IRegExpExec {\n  exec: CustomPatternMatcherFunc\n}\n\nconst DEFAULT_LEXER_CONFIG: ILexerConfig = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n}\n\nObject.freeze(DEFAULT_LEXER_CONFIG)\n\nexport class Lexer {\n  public static SKIPPED =\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\"\n\n  public static NA = /NOT_APPLICABLE/\n  public lexerDefinitionErrors: ILexerDefinitionError[] = []\n  public lexerDefinitionWarning: ILexerDefinitionError[] = []\n\n  protected patternIdxToConfig: any = {}\n  protected charCodeToPatternIdxToConfig: any = {}\n\n  protected modes: string[] = []\n  protected defaultMode: string\n  protected emptyGroups: { [groupName: string]: IToken } = {}\n\n  private config: ILexerConfig = undefined\n  private trackStartLines: boolean = true\n  private trackEndLines: boolean = true\n  private hasCustom: boolean = false\n  private canModeBeOptimized: any = {}\n\n  private traceInitPerf: boolean | number\n  private traceInitMaxIdent: number\n  private traceInitIndent: number\n\n  constructor(\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG\n  ) {\n    if (typeof config === \"boolean\") {\n      throw Error(\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n          \"a boolean 2nd argument is no longer supported\"\n      )\n    }\n\n    // todo: defaults func?\n    this.config = merge(DEFAULT_LEXER_CONFIG, config)\n\n    const traceInitVal = this.config.traceInitPerf\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity\n      this.traceInitPerf = true\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal\n      this.traceInitPerf = true\n    }\n    this.traceInitIndent = -1\n\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition: IMultiModeLexerDefinition\n      let hasOnlySingleMode = true\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (\n          this.config.lineTerminatorsPattern ===\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\n        ) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n        } else {\n          if (\n            this.config.lineTerminatorCharacters ===\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\n          ) {\n            throw Error(\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\"\n            )\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error(\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.'\n          )\n        }\n\n        this.trackStartLines = /full|onlyStart/i.test(\n          this.config.positionTracking\n        )\n        this.trackEndLines = /full/i.test(this.config.positionTracking)\n\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = <any>{ modes: {} }\n          actualDefinition.modes[DEFAULT_MODE] = cloneArr(\n            <TokenType[]>lexerDefinition\n          )\n          actualDefinition[DEFAULT_MODE] = DEFAULT_MODE\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false\n          actualDefinition = cloneObj(\n            <IMultiModeLexerDefinition>lexerDefinition\n          )\n        }\n      })\n\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n            performRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n            performWarningRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n      }\n\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes\n        ? actualDefinition.modes\n        : {}\n\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject<TokenType>(\n          currModeValue,\n          (currTokType) => isUndefined(currTokType)\n        )\n      })\n\n      let allModeNames = keys(actualDefinition.modes)\n\n      forEach(\n        actualDefinition.modes,\n        (currModDef: TokenType[], currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(<TokenType[]>currModDef, allModeNames)\n                )\n              })\n            }\n\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n\n              let currAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters: this.config\n                    .lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT.bind(this)\n                })\n              })\n\n              this.patternIdxToConfig[currModName] =\n                currAnalyzeResult.patternIdxToConfig\n\n              this.charCodeToPatternIdxToConfig[currModName] =\n                currAnalyzeResult.charCodeToPatternIdxToConfig\n\n              this.emptyGroups = merge(\n                this.emptyGroups,\n                currAnalyzeResult.emptyGroups\n              )\n\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n\n              this.canModeBeOptimized[currModName] =\n                currAnalyzeResult.canBeOptimized\n            }\n          })\n        }\n      )\n\n      this.defaultMode = actualDefinition.defaultMode\n\n      if (\n        !isEmpty(this.lexerDefinitionErrors) &&\n        !this.config.deferDefinitionErrorsHandling\n      ) {\n        let allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        let allErrMessagesString = allErrMessages.join(\n          \"-----------------------\\n\"\n        )\n        throw new Error(\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString\n        )\n      }\n\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message)\n      })\n\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          this.chopInput = <any>IDENTITY\n          this.match = this.matchWithTest\n        } else {\n          this.updateLastIndex = NOOP\n          this.match = this.matchWithExec\n        }\n\n        if (hasOnlySingleMode) {\n          this.handleModes = NOOP\n        }\n\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = IDENTITY\n        }\n\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = NOOP\n        }\n\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken\n        } else {\n          throw Error(\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`\n          )\n        }\n\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush\n          this.handlePayload = this.handlePayloadWithCustom\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess\n          this.handlePayload = this.handlePayloadNoCustom\n        }\n      })\n\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(\n          this.canModeBeOptimized,\n          (cannotBeOptimized, canBeOptimized, modeName) => {\n            if (canBeOptimized === false) {\n              cannotBeOptimized.push(modeName)\n            }\n            return cannotBeOptimized\n          },\n          []\n        )\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\n            `Lexer Modes: < ${unOptimizedModes.join(\n              \", \"\n            )} > cannot be optimized.\\n` +\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n              \"\\t Or inspect the console log for details on how to resolve these issues.\"\n          )\n        }\n      })\n\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache()\n      })\n\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this)\n      })\n    })\n  }\n\n  public tokenize(\n    text: string,\n    initialMode: string = this.defaultMode\n  ): ILexingResult {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      let allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message\n      })\n      let allErrMessagesString = allErrMessages.join(\n        \"-----------------------\\n\"\n      )\n      throw new Error(\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n          allErrMessagesString\n      )\n    }\n\n    let lexResult = this.tokenizeInternal(text, initialMode)\n\n    return lexResult\n  }\n\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\n    let i,\n      j,\n      matchAltImage,\n      longerAltIdx,\n      matchedImage,\n      payload,\n      altPayload,\n      imageLength,\n      group,\n      tokType,\n      newToken,\n      errLength,\n      droppedChar,\n      msg,\n      match\n    let orgText = text\n    let orgLength = orgText.length\n    let offset = 0\n    let matchedTokensIndex = 0\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    let guessedNumberOfTokens = this.hasCustom\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n      : Math.floor(text.length / 10)\n    let matchedTokens = new Array(guessedNumberOfTokens)\n    let errors: ILexingError[] = []\n    let line = this.trackStartLines ? 1 : undefined\n    let column = this.trackStartLines ? 1 : undefined\n    let groups: any = cloneEmptyGroups(this.emptyGroups)\n    let trackLines = this.trackStartLines\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern\n\n    let currModePatternsLength = 0\n    let patternIdxToConfig = []\n    let currCharCodeToPatternIdxToConfig = []\n\n    let modeStack = []\n\n    const emptyArray = []\n    Object.freeze(emptyArray)\n    let getPossiblePatterns = undefined\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig\n    }\n\n    function getPossiblePatternsOptimized(charCode) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n      const possiblePatterns =\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n      if (possiblePatterns === undefined) {\n        return emptyArray\n      } else {\n        return possiblePatterns\n      }\n    }\n\n    let pop_mode = (popToken) => {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (\n        modeStack.length === 1 &&\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n        // So no error should occur.\n        popToken.tokenType.PUSH_MODE === undefined\n      ) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        let msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\n          popToken\n        )\n\n        errors.push({\n          offset: popToken.startOffset,\n          line:\n            popToken.startLine !== undefined ? popToken.startLine : undefined,\n          column:\n            popToken.startColumn !== undefined\n              ? popToken.startColumn\n              : undefined,\n          length: popToken.image.length,\n          message: msg\n        })\n      } else {\n        modeStack.pop()\n        let newMode = last(modeStack)\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[\n          newMode\n        ]\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized =\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n    }\n\n    function push_mode(newMode) {\n      modeStack.push(newMode)\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[\n        newMode\n      ]\n\n      patternIdxToConfig = this.patternIdxToConfig[newMode]\n      currModePatternsLength = patternIdxToConfig.length\n\n      currModePatternsLength = patternIdxToConfig.length\n      const modeCanBeOptimized =\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow\n      }\n    }\n\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode)\n\n    let currConfig\n\n    while (offset < orgLength) {\n      matchedImage = null\n\n      let nextCharCode = orgText.charCodeAt(offset)\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n      let chosenPatternsLength = chosenPatternIdxToConfig.length\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i]\n        let currPattern = currConfig.pattern\n        payload = null\n\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        let singleCharCode = currConfig.short\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups)\n          if (match !== null) {\n            matchedImage = match[0]\n            if (match.payload !== undefined) {\n              payload = match.payload\n            }\n          } else {\n            matchedImage = null\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset)\n          matchedImage = this.match(currPattern, text, offset)\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAltIdx = currConfig.longerAlt\n          if (longerAltIdx !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            let longerAltConfig = patternIdxToConfig[longerAltIdx]\n            let longerAltPattern = longerAltConfig.pattern\n            altPayload = null\n\n            // single Char can never be a longer alt so no need to test it.\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            if (longerAltConfig.isCustom === true) {\n              match = longerAltPattern.exec(\n                orgText,\n                offset,\n                matchedTokens,\n                groups\n              )\n              if (match !== null) {\n                matchAltImage = match[0]\n                if (match.payload !== undefined) {\n                  altPayload = match.payload\n                }\n              } else {\n                matchAltImage = null\n              }\n            } else {\n              this.updateLastIndex(longerAltPattern, offset)\n              matchAltImage = this.match(longerAltPattern, text, offset)\n            }\n\n            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n              matchedImage = matchAltImage\n              payload = altPayload\n              currConfig = longerAltConfig\n            }\n          }\n          break\n        }\n      }\n\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length\n        group = currConfig.group\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(\n            matchedImage,\n            offset,\n            tokType,\n            currConfig.tokenType,\n            line,\n            column,\n            imageLength\n          )\n\n          this.handlePayload(newToken, payload)\n\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(\n              matchedTokens,\n              matchedTokensIndex,\n              newToken\n            )\n          } else {\n            groups[group].push(newToken)\n          }\n        }\n        text = this.chopInput(text, imageLength)\n        offset = offset + imageLength\n\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column, imageLength)\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0\n          let foundTerminator\n          let lastLTEndOffset\n          lineTerminatorPattern.lastIndex = 0\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage)\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n              numOfLTsInMatch++\n            }\n          } while (foundTerminator === true)\n\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch\n            column = imageLength - lastLTEndOffset\n            this.updateTokenEndLineColumnLocation(\n              newToken,\n              group,\n              lastLTEndOffset,\n              numOfLTsInMatch,\n              line,\n              column,\n              imageLength\n            )\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken)\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        let errorStartOffset = offset\n        let errorLine = line\n        let errorColumn = column\n        let foundResyncPoint = false\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset)\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1)\n          offset++\n          for (j = 0; j < currModePatternsLength; j++) {\n            let currConfig = patternIdxToConfig[j]\n            let currPattern = currConfig.pattern\n\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            let singleCharCode = currConfig.short\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true\n              }\n            } else if (currConfig.isCustom === true) {\n              foundResyncPoint =\n                currPattern.exec(orgText, offset, matchedTokens, groups) !==\n                null\n            } else {\n              this.updateLastIndex(currPattern, offset)\n              foundResyncPoint = currPattern.exec(text) !== null\n            }\n\n            if (foundResyncPoint === true) {\n              break\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n          orgText,\n          errorStartOffset,\n          errLength,\n          errorLine,\n          errorColumn\n        )\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        })\n      }\n    }\n\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    }\n  }\n\n  private handleModes(config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      let pushMode = config.push\n      pop_mode(newToken)\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode)\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push)\n    }\n  }\n\n  private chopInput(text, length): string {\n    return text.substring(length)\n  }\n\n  private updateLastIndex(regExp, newLastIndex): void {\n    regExp.lastIndex = newLastIndex\n  }\n\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  private updateTokenEndLineColumnLocation(\n    newToken,\n    group,\n    lastLTIdx,\n    numOfLTsInMatch,\n    line,\n    column,\n    imageLength\n  ): void {\n    let lastCharIsLT, fixForEndingInLT\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1\n      fixForEndingInLT = lastCharIsLT ? -1 : 0\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  }\n\n  private computeNewColumn(oldColumn, imageLength) {\n    return oldColumn + imageLength\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private createTokenInstance(...args: any[]): IToken {\n    return null\n  }\n\n  private createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createStartOnlyToken(\n    image,\n    startOffset,\n    tokenTypeIdx,\n    tokenType,\n    startLine,\n    startColumn\n  ) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createFullToken(\n    image,\n    startOffset,\n    tokenTypeIdx,\n    tokenType,\n    startLine,\n    startColumn,\n    imageLength\n  ) {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private addToken(tokenVector, index, tokenToAdd): number {\n    return 666\n  }\n\n  private addTokenUsingPush(tokenVector, index, tokenToAdd): number {\n    tokenVector.push(tokenToAdd)\n    return index\n  }\n\n  private addTokenUsingMemberAccess(tokenVector, index, tokenToAdd): number {\n    tokenVector[index] = tokenToAdd\n    index++\n    return index\n  }\n\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  /* istanbul ignore next - place holder */\n  private handlePayload(token: IToken, payload: any): void {}\n\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\n\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\n    if (payload !== null) {\n      token.payload = payload\n    }\n  }\n\n  /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n  private match(pattern: RegExp, text: string, offset?: number): string {\n    return null\n  }\n\n  private matchWithTest(pattern: RegExp, text: string, offset: number): string {\n    let found = pattern.test(text)\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex)\n    }\n    return null\n  }\n\n  private matchWithExec(pattern, text): string {\n    let regExpArray = pattern.exec(text)\n    return regExpArray !== null ? regExpArray[0] : regExpArray\n  }\n\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  TRACE_INIT<T>(phaseDesc: string, phaseImpl: () => T): T {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n", "import { has, isString, isUndefined } from \"../utils/utils\"\nimport { Lexer } from \"./lexer_public\"\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens\"\nimport { IToken, ITokenConfig, TokenType } from \"../../api\"\n\nexport function tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL\n  } else {\n    return tokType.name\n  }\n}\n\nexport function tokenName(tokType: TokenType): string {\n  return tokType.name\n}\n\nexport function hasTokenLabel(obj: TokenType): boolean {\n  return isString((<any>obj).LABEL) && (<any>obj).LABEL !== \"\"\n}\n\nconst PARENT = \"parent\"\nconst CATEGORIES = \"categories\"\nconst LABEL = \"label\"\nconst GROUP = \"group\"\nconst PUSH_MODE = \"push_mode\"\nconst POP_MODE = \"pop_mode\"\nconst LONGER_ALT = \"longer_alt\"\nconst LINE_BREAKS = \"line_breaks\"\nconst START_CHARS_HINT = \"start_chars_hint\"\n\nexport function createToken(config: ITokenConfig): TokenType {\n  return createTokenInternal(config)\n}\n\nfunction createTokenInternal(config: ITokenConfig): TokenType {\n  let pattern = config.pattern\n\n  let tokenType: TokenType = <any>{}\n  tokenType.name = config.name\n\n  if (!isUndefined(pattern)) {\n    tokenType.PATTERN = pattern\n  }\n\n  if (has(config, PARENT)) {\n    throw (\n      \"The parent property is no longer supported.\\n\" +\n      \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\"\n    )\n  }\n\n  if (has(config, CATEGORIES)) {\n    // casting to ANY as this will be fixed inside `augmentTokenTypes``\n    tokenType.CATEGORIES = <any>config[CATEGORIES]\n  }\n\n  augmentTokenTypes([tokenType])\n\n  if (has(config, LABEL)) {\n    tokenType.LABEL = config[LABEL]\n  }\n\n  if (has(config, GROUP)) {\n    tokenType.GROUP = config[GROUP]\n  }\n\n  if (has(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE]\n  }\n\n  if (has(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE]\n  }\n\n  if (has(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT]\n  }\n\n  if (has(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS]\n  }\n\n  if (has(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT]\n  }\n\n  return tokenType\n}\n\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA })\naugmentTokenTypes([EOF])\n\nexport function createTokenInstance(\n  tokType: TokenType,\n  image: string,\n  startOffset: number,\n  endOffset: number,\n  startLine: number,\n  endLine: number,\n  startColumn: number,\n  endColumn: number\n): IToken {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: (<any>tokType).tokenTypeIdx,\n    tokenType: tokType\n  }\n}\n\nexport function tokenMatcher(token: IToken, tokType: TokenType): boolean {\n  return tokenStructuredMatcher(token, tokType)\n}\n", "import { assign, forEach, isRegExp, map, pick } from \"../../../utils/utils\"\nimport { tokenLabel } from \"../../../scan/tokens_public\"\nimport {\n  IGASTVisitor,\n  IProduction,\n  IProductionWithOccurrence,\n  ISerializedGast,\n  TokenType\n} from \"../../../../api\"\n\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\n  implements IProduction {\n  public get definition(): T[] {\n    return this._definition\n  }\n  public set definition(value: T[]) {\n    this._definition = value\n  }\n\n  constructor(protected _definition: T[]) {}\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor)\n    })\n  }\n}\n\nexport class NonTerminal\n  extends AbstractProduction\n  implements IProductionWithOccurrence {\n  public nonTerminalName: string\n  public referencedRule: Rule\n  public idx: number = 1\n\n  constructor(options: {\n    nonTerminalName: string\n    referencedRule?: Rule\n    idx?: number\n  }) {\n    super([])\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n\n  set definition(definition: IProduction[]) {\n    // immutable\n  }\n\n  get definition(): IProduction[] {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition\n    }\n    return []\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n}\n\nexport class Rule extends AbstractProduction {\n  public name: string\n  public orgText: string = \"\"\n\n  constructor(options: {\n    name: string\n    definition: IProduction[]\n    orgText?: string\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternative extends AbstractProduction {\n  public ignoreAmbiguities: boolean = false\n\n  constructor(options: {\n    definition: IProduction[]\n    ignoreAmbiguities?: boolean\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Option\n  extends AbstractProduction\n  implements IProductionWithOccurrence {\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatory\n  extends AbstractProduction\n  implements IProductionWithOccurrence {\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatoryWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence {\n  public separator: TokenType\n  public idx: number = 1\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Repetition\n  extends AbstractProduction\n  implements IProductionWithOccurrence {\n  public separator: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence {\n  public separator: TokenType\n  public idx: number = 1\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternation\n  extends AbstractProduction<Alternative>\n  implements IProductionWithOccurrence {\n  public idx: number = 1\n  public ignoreAmbiguities: boolean = false\n  public hasPredicates: boolean = false\n  public maxLookahead?: number\n\n  public get definition(): Alternative[] {\n    return this._definition\n  }\n  public set definition(value: Alternative[]) {\n    this._definition = value\n  }\n\n  constructor(options: {\n    definition: Alternative[]\n    idx?: number\n    ignoreAmbiguities?: boolean\n    hasPredicates?: boolean\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Terminal implements IProductionWithOccurrence {\n  public terminalType: TokenType\n  public idx: number = 1\n\n  constructor(options: { terminalType: TokenType; idx?: number }) {\n    assign(\n      this,\n      pick(options, (v) => v !== undefined)\n    )\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n  }\n}\n\nexport interface ISerializedBasic extends ISerializedGast {\n  type:\n    | \"Alternative\"\n    | \"Option\"\n    | \"RepetitionMandatory\"\n    | \"Repetition\"\n    | \"Alternation\"\n  idx?: number\n}\n\nexport interface ISerializedGastRule extends ISerializedGast {\n  type: \"Rule\"\n  name: string\n  orgText: string\n}\n\nexport interface ISerializedNonTerminal extends ISerializedGast {\n  type: \"NonTerminal\"\n  name: string\n  idx: number\n}\n\nexport interface ISerializedTerminal extends ISerializedGast {\n  type: \"Terminal\"\n  name: string\n  label?: string\n  pattern?: string\n  idx: number\n}\n\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\"\n  idx: number\n  separator: ISerializedTerminal\n}\n\nexport type ISerializedGastAny =\n  | ISerializedBasic\n  | ISerializedGastRule\n  | ISerializedNonTerminal\n  | ISerializedTerminal\n  | ISerializedTerminalWithSeparator\n\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\n  return map(topRules, serializeProduction)\n}\n\nexport function serializeProduction(node: IProduction): ISerializedGast {\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\n    return map(definition, serializeProduction)\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    return <ISerializedNonTerminal>{\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    }\n  } else if (node instanceof Alternative) {\n    return <ISerializedBasic>{\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Option) {\n    return <ISerializedBasic>{\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatory) {\n    return <ISerializedBasic>{\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Repetition) {\n    return <ISerializedBasic>{\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Alternation) {\n    return <ISerializedBasic>{\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Terminal) {\n    let serializedTerminal = <ISerializedTerminal>{\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    }\n\n    let pattern = node.terminalType.PATTERN\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern)\n        ? (<any>pattern).source\n        : pattern\n    }\n\n    return serializedTerminal\n  } else if (node instanceof Rule) {\n    return <ISerializedGastRule>{\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    }\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n", "import { drop, forEach } from \"../../utils/utils\"\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"./gast/gast_public\"\nimport { IProduction } from \"../../../api\"\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport abstract class RestWalker {\n  walk(prod: AbstractProduction, prevRest: any[] = []): void {\n    forEach(prod.definition, (subProd: IProduction, index) => {\n      let currRest = drop(prod.definition, index + 1)\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest)\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest)\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest)\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest)\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkFlat(\n    flatProd: Alternative,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABCDEF => after the D the rest is EF\n    let fullOrRest = currRest.concat(prevRest)\n    this.walk(flatProd, <any>fullOrRest)\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    let fullOrRest = currRest.concat(prevRest)\n    this.walk(optionProd, <any>fullOrRest)\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    let fullAtLeastOneRest: IProduction[] = [\n      new Option({ definition: atLeastOneProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(atLeastOneProd, fullAtLeastOneRest)\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    let fullAtLeastOneSepRest = restForRepetitionWithSeparator(\n      atLeastOneSepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    let fullManyRest: IProduction[] = [\n      new Option({ definition: manyProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(manyProd, fullManyRest)\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    let fullManySepRest = restForRepetitionWithSeparator(\n      manySepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(manySepProd, fullManySepRest)\n  }\n\n  walkOr(\n    orProd: Alternation,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    let fullOrRest = currRest.concat(prevRest)\n    // walk all different alternatives\n    forEach(orProd.definition, (alt) => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      let prodWrapper = new Alternative({ definition: [alt] })\n      this.walk(prodWrapper, <any>fullOrRest)\n    })\n  }\n}\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  let repSepRest = [\n    new Option({\n      definition: [new Terminal({ terminalType: repSepProd.separator })].concat(\n        repSepProd.definition\n      )\n    })\n  ]\n  let fullRepSepRest: IProduction[] = repSepRest.concat(\n    <any>currRest,\n    <any>prevRest\n  )\n  return fullRepSepRest\n}\n", "import {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./gast_public\"\nimport { IProduction } from \"../../../../api\"\n\nexport abstract class GAstVisitor {\n  public visit(node: IProduction): any {\n    const nodeAny: any = node\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny)\n      case Alternative:\n        return this.visitAlternative(nodeAny)\n      case Option:\n        return this.visitOption(nodeAny)\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny)\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny)\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny)\n      case Repetition:\n        return this.visitRepetition(nodeAny)\n      case Alternation:\n        return this.visitAlternation(nodeAny)\n      case Terminal:\n        return this.visitTerminal(nodeAny)\n      case Rule:\n        return this.visitRule(nodeAny)\n      /* istanbul ignore next */\n      default:\n        throw Error(\"non exhaustive match\")\n    }\n  }\n\n  public visitNonTerminal(node: NonTerminal): any {}\n\n  public visitAlternative(node: Alternative): any {}\n\n  public visitOption(node: Option): any {}\n\n  public visitRepetition(node: Repetition): any {}\n\n  public visitRepetitionMandatory(node: RepetitionMandatory): any {}\n\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ): any {}\n\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): any {}\n\n  public visitAlternation(node: Alternation): any {}\n\n  public visitTerminal(node: Terminal): any {}\n\n  public visitRule(node: Rule): any {}\n}\n", "import { contains, every, has, some } from \"../../../utils/utils\"\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./gast_public\"\nimport { GAstVisitor } from \"./gast_visitor_public\"\nimport { IProduction, IProductionWithOccurrence } from \"../../../../api\"\n\nexport function isSequenceProd(prod: IProduction): boolean {\n  return (\n    prod instanceof Alternative ||\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionMandatory ||\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod instanceof RepetitionWithSeparator ||\n    prod instanceof Terminal ||\n    prod instanceof Rule\n  )\n}\n\nexport function isOptionalProd(\n  prod: IProduction,\n  alreadyVisited: NonTerminal[] = []\n): boolean {\n  let isDirectlyOptional =\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionWithSeparator\n  if (isDirectlyOptional) {\n    return true\n  }\n\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n  // empty optional top rule\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\n  if (prod instanceof Alternation) {\n    // for OR its enough for just one of the alternatives to be optional\n    return some((<Alternation>prod).definition, (subProd: IProduction) => {\n      return isOptionalProd(subProd, alreadyVisited)\n    })\n  } else if (prod instanceof NonTerminal && contains(alreadyVisited, prod)) {\n    // avoiding stack overflow due to infinite recursion\n    return false\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod)\n    }\n    return every(\n      (<AbstractProduction>prod).definition,\n      (subProd: IProduction) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      }\n    )\n  } else {\n    return false\n  }\n}\n\nexport function isBranchingProd(prod: IProduction): boolean {\n  return prod instanceof Alternation\n}\n\nexport function getProductionDslName(prod: IProductionWithOccurrence): string {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\"\n  } else if (prod instanceof Option) {\n    return \"OPTION\"\n  } else if (prod instanceof Alternation) {\n    return \"OR\"\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\"\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\"\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\"\n  } else if (prod instanceof Repetition) {\n    return \"MANY\"\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\"\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport class DslMethodsCollectorVisitor extends GAstVisitor {\n  // A minus is never valid in an identifier name\n  public separator = \"-\"\n  public dslMethods = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: []\n  }\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    }\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    const key = terminal.terminalType.name + this.separator + \"Terminal\"\n    if (!has(this.dslMethods, key)) {\n      this.dslMethods[key] = []\n    }\n    this.dslMethods[key].push(terminal)\n  }\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    const key = subrule.nonTerminalName + this.separator + \"Terminal\"\n    if (!has(this.dslMethods, key)) {\n      this.dslMethods[key] = []\n    }\n    this.dslMethods[key].push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or)\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor()\nexport function collectMethods(\n  rule: Rule\n): {\n  option: Option[]\n  alternation: Alternation[]\n  repetition: Repetition[]\n  repetitionWithSeparator: RepetitionWithSeparator[]\n  repetitionMandatory: RepetitionMandatory[]\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator\n} {\n  collectorVisitor.reset()\n  rule.accept(collectorVisitor)\n  const dslMethods = collectorVisitor.dslMethods\n  // avoid uncleaned references\n  collectorVisitor.reset()\n  return <any>dslMethods\n}\n", "import { uniq, map, flatten } from \"../../utils/utils\"\nimport { AbstractProduction, NonTerminal, Terminal } from \"./gast/gast_public\"\nimport { isBranchingProd, isOptionalProd, isSequenceProd } from \"./gast/gast\"\nimport { IProduction, TokenType } from \"../../../api\"\n\nexport function first(prod: IProduction): TokenType[] {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first((<NonTerminal>prod).referencedRule)\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(<Terminal>prod)\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(<AbstractProduction>prod)\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(<AbstractProduction>prod)\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function firstForSequence(prod: AbstractProduction): TokenType[] {\n  let firstSet: TokenType[] = []\n  let seq = prod.definition\n  let nextSubProdIdx = 0\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  let currSubProd\n  // so we enter the loop at least once (if the definition is not empty\n  let isLastInnerProdOptional = true\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx]\n    isLastInnerProdOptional = isOptionalProd(currSubProd)\n    firstSet = firstSet.concat(first(currSubProd))\n    nextSubProdIdx = nextSubProdIdx + 1\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  }\n\n  return uniq(firstSet)\n}\n\nexport function firstForBranching(prod: AbstractProduction): TokenType[] {\n  let allAlternativesFirsts: TokenType[][] = map(\n    prod.definition,\n    (innerProd) => {\n      return first(innerProd)\n    }\n  )\n  return uniq(flatten<TokenType>(allAlternativesFirsts))\n}\n\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\n  return [terminal.terminalType]\n}\n", "// TODO: can this be removed? where is it used?\nexport let IN = \"_~IN~_\"\n", "import { RestWalker } from \"./rest\"\nimport { first } from \"./first\"\nimport { assign, forEach } from \"../../utils/utils\"\nimport { IN } from \"../constants\"\nimport { Alternative, NonTerminal, Rule, Terminal } from \"./gast/gast_public\"\nimport { IProduction, TokenType } from \"../../../api\"\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n  public follows = {}\n\n  constructor(private topProd: Rule) {\n    super()\n  }\n\n  startWalking(): Record<string, TokenType[]> {\n    this.walk(this.topProd)\n    return this.follows\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // do nothing! just like in the public sector after 13:00\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    let followName =\n      buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n      this.topProd.name\n    let fullRest: IProduction[] = currRest.concat(prevRest)\n    let restProd = new Alternative({ definition: fullRest })\n    let t_in_topProd_follows = first(restProd)\n    this.follows[followName] = t_in_topProd_follows\n  }\n}\n\nexport function computeAllProdsFollows(\n  topProductions: Rule[]\n): Record<string, TokenType[]> {\n  let reSyncFollows = {}\n\n  forEach(topProductions, (topProd) => {\n    let currRefsFollow = new ResyncFollowsWalker(topProd).startWalking()\n    assign(reSyncFollows, currRefsFollow)\n  })\n  return reSyncFollows\n}\n\nexport function buildBetweenProdsFollowPrefix(\n  inner: Rule,\n  occurenceInParent: number\n): string {\n  return inner.name + occurenceInParent + IN\n}\n\nexport function buildInProdFollowPrefix(terminal: Terminal): string {\n  let terminalName = terminal.terminalType.name\n  return terminalName + terminal.idx + IN\n}\n", "import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\"\nimport * as utils from \"../utils/utils\"\nimport { first, map, reduce } from \"../utils/utils\"\nimport {\n  Alternation,\n  NonTerminal,\n  Rule,\n  Terminal\n} from \"./grammar/gast/gast_public\"\nimport { getProductionDslName } from \"./grammar/gast/gast\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType\n} from \"../../api\"\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    let hasLabel = hasTokenLabel(expected)\n    let expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`\n\n    let msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n\n    return msg\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName\n  }): string {\n    let errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    let actualText = first(actual).image\n    let errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      let allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        []\n      )\n      let nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \"\n          )}]`\n      )\n      let nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`\n      )\n      let calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\"\n      )}`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName\n  }): string {\n    let errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    let actualText = first(actual).image\n    let errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      let nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\"\n          )}]`\n      )\n      let calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  }\n}\n\nObject.freeze(defaultParserErrorProvider)\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider = {\n  buildRuleNotFoundError(\n    topLevelRule: Rule,\n    undefinedRule: NonTerminal\n  ): string {\n    const msg =\n      \"Invalid grammar, reference to a rule which is not defined: ->\" +\n      undefinedRule.nonTerminalName +\n      \"<-\\n\" +\n      \"inside top level rule: ->\" +\n      topLevelRule.name +\n      \"<-\"\n    return msg\n  }\n}\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider = {\n  buildDuplicateFoundError(\n    topLevelRule: Rule,\n    duplicateProds: IProductionWithOccurrence[]\n  ): string {\n    function getExtraProductionArgument(\n      prod: IProductionWithOccurrence\n    ): string {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName\n      } else {\n        return \"\"\n      }\n    }\n\n    const topLevelName = topLevelRule.name\n    const duplicateProd = first(duplicateProds)\n    const index = duplicateProd.idx\n    const dslName = getProductionDslName(duplicateProd)\n    let extraArgument = getExtraProductionArgument(duplicateProd)\n\n    const hasExplicitIndex = index > 0\n    let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n      extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n    }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n\n    // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n    msg = msg.replace(/[ \\t]+/g, \" \")\n    msg = msg.replace(/\\s\\s+/g, \"\\n\")\n\n    return msg\n  },\n\n  buildNamespaceConflictError(rule: Rule): string {\n    const errMsg =\n      `Namespace conflict found in grammar.\\n` +\n      `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n      `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n      `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n      `and Non-Terminal names start with a lower case letter.`\n\n    return errMsg\n  },\n\n  buildAlternationPrefixAmbiguityError(options: {\n    topLevelRule: Rule\n    prefixPath: TokenType[]\n    ambiguityIndices: number[]\n    alternation: Alternation\n  }): string {\n    const pathMsg = map(options.prefixPath, (currTok) =>\n      tokenLabel(currTok)\n    ).join(\", \")\n    const occurrence =\n      options.alternation.idx === 0 ? \"\" : options.alternation.idx\n    const errMsg =\n      `Ambiguous alternatives: <${options.ambiguityIndices.join(\n        \" ,\"\n      )}> due to common lookahead prefix\\n` +\n      `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n      `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n      `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n      `For Further details.`\n\n    return errMsg\n  },\n\n  buildAlternationAmbiguityError(options: {\n    topLevelRule: Rule\n    prefixPath: TokenType[]\n    ambiguityIndices: number[]\n    alternation: Alternation\n  }): string {\n    let pathMsg = map(options.prefixPath, (currtok) =>\n      tokenLabel(currtok)\n    ).join(\", \")\n    let occurrence =\n      options.alternation.idx === 0 ? \"\" : options.alternation.idx\n    let currMessage =\n      `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n        \" ,\"\n      )}> in <OR${occurrence}>` +\n      ` inside <${options.topLevelRule.name}> Rule,\\n` +\n      `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n\n    currMessage =\n      currMessage +\n      `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n      `For Further details.`\n    return currMessage\n  },\n\n  buildEmptyRepetitionError(options: {\n    topLevelRule: Rule\n    repetition: IProductionWithOccurrence\n  }): string {\n    let dslName = getProductionDslName(options.repetition)\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx\n    }\n\n    const errMsg =\n      `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n      `This could lead to an infinite loop.`\n\n    return errMsg\n  },\n\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError(options: {\n    tokenType: TokenType\n    expectedPattern: RegExp\n  }): string {\n    /* istanbul ignore next */\n    return \"deprecated\"\n  },\n\n  buildEmptyAlternationError(options: {\n    topLevelRule: Rule\n    alternation: Alternation\n    emptyChoiceIdx: number\n  }): string {\n    const errMsg =\n      `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n      ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n      `Only the last alternative may be an empty alternative.`\n\n    return errMsg\n  },\n\n  buildTooManyAlternativesError(options: {\n    topLevelRule: Rule\n    alternation: Alternation\n  }): string {\n    const errMsg =\n      `An Alternation cannot have more than 256 alternatives:\\n` +\n      `<OR${options.alternation.idx}> inside <${\n        options.topLevelRule.name\n      }> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`\n\n    return errMsg\n  },\n\n  buildLeftRecursionError(options: {\n    topLevelRule: Rule\n    leftRecursionPath: Rule[]\n  }): string {\n    const ruleName = options.topLevelRule.name\n    let pathNames = utils.map(\n      options.leftRecursionPath,\n      (currRule) => currRule.name\n    )\n    let leftRecursivePath = `${ruleName} --> ${pathNames\n      .concat([ruleName])\n      .join(\" --> \")}`\n    let errMsg =\n      `Left Recursion found in grammar.\\n` +\n      `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n      `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n      ` To fix this refactor your grammar to remove the left recursion.\\n` +\n      `see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.`\n\n    return errMsg\n  },\n\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError(options: {\n    topLevelRule: Rule\n    expectedPattern: RegExp\n  }): string {\n    /* istanbul ignore next */\n    return \"deprecated\"\n  },\n\n  buildDuplicateRuleNameError(options: {\n    topLevelRule: Rule | string\n    grammarName: string\n  }): string {\n    let ruleName\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name\n    } else {\n      ruleName = options.topLevelRule\n    }\n\n    const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n\n    return errMsg\n  }\n}\n", "import {\n  IParserUnresolvedRefDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { forEach, values } from \"../../utils/utils\"\nimport { NonTerminal, Rule } from \"./gast/gast_public\"\nimport { GAstVisitor } from \"./gast/gast_visitor_public\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IParserDefinitionError\n} from \"../../../api\"\n\nexport function resolveGrammar(\n  topLevels: Record<string, Rule>,\n  errMsgProvider: IGrammarResolverErrorMessageProvider\n): IParserDefinitionError[] {\n  let refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider)\n  refResolver.resolveRefs()\n  return refResolver.errors\n}\n\nexport class GastRefResolverVisitor extends GAstVisitor {\n  public errors: IParserUnresolvedRefDefinitionError[] = []\n  private currTopLevel: Rule\n\n  constructor(\n    private nameToTopRule: Record<string, Rule>,\n    private errMsgProvider: IGrammarResolverErrorMessageProvider\n  ) {\n    super()\n  }\n\n  public resolveRefs(): void {\n    forEach(values(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod\n      prod.accept(this)\n    })\n  }\n\n  public visitNonTerminal(node: NonTerminal): void {\n    let ref = this.nameToTopRule[node.nonTerminalName]\n\n    if (!ref) {\n      let msg = this.errMsgProvider.buildRuleNotFoundError(\n        this.currTopLevel,\n        node\n      )\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName\n      })\n    } else {\n      node.referencedRule = ref\n    }\n  }\n}\n", "import { RestWalker } from \"./rest\"\nimport {\n  cloneArr,\n  drop,\n  dropRight,\n  first as _first,\n  forEach,\n  isEmpty,\n  last\n} from \"../../utils/utils\"\nimport { first } from \"./first\"\nimport { TokenMatcher } from \"../parser/parser\"\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./gast/gast_public\"\nimport {\n  IGrammarPath,\n  IProduction,\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"../../../api\"\n\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\n  protected possibleTokTypes: TokenType[] = []\n  protected ruleStack: string[]\n  protected occurrenceStack: number[]\n\n  protected nextProductionName = \"\"\n  protected nextProductionOccurrence = 0\n  protected found = false\n  protected isAtEndOfPath = false\n\n  constructor(protected topProd: Rule, protected path: IGrammarPath) {\n    super()\n  }\n\n  startWalking(): TokenType[] {\n    this.found = false\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\")\n    }\n\n    // immutable for the win\n    this.ruleStack = cloneArr(this.path.ruleStack).reverse() // intelij bug requires assertion\n    this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse() // intelij bug requires assertion\n\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop()\n    this.occurrenceStack.pop()\n\n    this.updateExpectedNext()\n    this.walk(this.topProd)\n\n    return this.possibleTokTypes\n  }\n\n  walk(prod: AbstractProduction, prevRest: IProduction[] = []): void {\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest)\n    }\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // found the next production, need to keep walking in it\n    if (\n      refProd.referencedRule.name === this.nextProductionName &&\n      refProd.idx === this.nextProductionOccurrence\n    ) {\n      let fullRest = currRest.concat(prevRest)\n      this.updateExpectedNext()\n      this.walk(refProd.referencedRule, <any>fullRest)\n    }\n  }\n\n  updateExpectedNext(): void {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\"\n      this.nextProductionOccurrence = 0\n      this.isAtEndOfPath = true\n    } else {\n      this.nextProductionName = this.ruleStack.pop()\n      this.nextProductionOccurrence = this.occurrenceStack.pop()\n    }\n  }\n}\n\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  private nextTerminalName = \"\"\n  private nextTerminalOccurrence = 0\n\n  constructor(topProd: Rule, protected path: ITokenGrammarPath) {\n    super(topProd, path)\n    this.nextTerminalName = this.path.lastTok.name\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      this.isAtEndOfPath &&\n      terminal.terminalType.name === this.nextTerminalName &&\n      terminal.idx === this.nextTerminalOccurrence &&\n      !this.found\n    ) {\n      let fullRest = currRest.concat(prevRest)\n      let restProd = new Alternative({ definition: fullRest })\n      this.possibleTokTypes = first(restProd)\n      this.found = true\n    }\n  }\n}\n\nexport type AlternativesFirstTokens = TokenType[][]\n\nexport interface IFirstAfterRepetition {\n  token: TokenType\n  occurrence: number\n  isEndOfRule: boolean\n}\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  protected result = {\n    token: undefined,\n    occurrence: undefined,\n    isEndOfRule: undefined\n  }\n\n  constructor(protected topRule: Rule, protected occurrence: number) {\n    super()\n  }\n\n  startWalking(): IFirstAfterRepetition {\n    this.walk(this.topRule)\n    return this.result\n  }\n}\n\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manyProd.idx === this.occurrence) {\n      let firstAfterMany = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterMany === undefined\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType\n        this.result.occurrence = firstAfterMany.idx\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manySepProd.idx === this.occurrence) {\n      let firstAfterManySep = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterManySep === undefined\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType\n        this.result.occurrence = firstAfterManySep.idx\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atLeastOneProd.idx === this.occurrence) {\n      let firstAfterAtLeastOne = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType\n        this.result.occurrence = firstAfterAtLeastOne.idx\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\n    }\n  }\n}\n\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      let firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport interface PartialPathAndSuffixes {\n  partialPath: TokenType[]\n  suffixDef: IProduction[]\n}\n\nexport function possiblePathsFrom(\n  targetDef: IProduction[],\n  maxLength: number,\n  currPath = []\n): PartialPathAndSuffixes[] {\n  // avoid side effects\n  currPath = cloneArr(currPath)\n  let result = []\n  let i = 0\n\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef: IProduction[]) {\n    return nextDef.concat(drop(targetDef, i + 1))\n  }\n\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition: IProduction[]) {\n    let alternatives = possiblePathsFrom(\n      remainingPathWith(definition),\n      maxLength,\n      currPath\n    )\n    return result.concat(alternatives)\n  }\n\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    let prod = targetDef[i]\n\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition)\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ]\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition)\n        }\n      })\n      return result\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType)\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n\n    i++\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  })\n\n  return result\n}\n\ninterface IPathToExamine {\n  idx: number\n  def: IProduction[]\n  ruleStack: string[]\n  occurrenceStack: number[]\n}\n\nexport function nextPossibleTokensAfter(\n  initialDef: IProduction[],\n  tokenVector: IToken[],\n  tokMatcher: TokenMatcher,\n  maxLookAhead: number\n): ISyntacticContentAssistPath[] {\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\"\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\"\n  let foundCompletePath = false\n\n  const tokenVectorLength = tokenVector.length\n  let minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\n\n  let result: ISyntacticContentAssistPath[] = []\n\n  let possiblePaths: IPathToExamine[] = []\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  })\n\n  while (!isEmpty(possiblePaths)) {\n    let currPath = possiblePaths.pop()\n\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (\n        foundCompletePath &&\n        last(possiblePaths).idx <= minimalAlternativesIndex\n      ) {\n        // remove irrelevant alternative\n        possiblePaths.pop()\n      }\n      continue\n    }\n\n    let currDef = currPath.def\n    let currIdx = currPath.idx\n    let currRuleStack = currPath.ruleStack\n    let currOccurrenceStack = currPath.occurrenceStack\n\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue\n    }\n\n    let prod = currDef[0]\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      let nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        let nextIdx = currIdx + 1\n        let actualToken = tokenVector[nextIdx]\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          let nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          }\n          possiblePaths.push(nextPath)\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        })\n        foundCompletePath = true\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    } else if (prod instanceof NonTerminal) {\n      let newRuleStack = cloneArr(currRuleStack)\n      newRuleStack.push(prod.nonTerminalName)\n\n      let newOccurrenceStack = cloneArr(currOccurrenceStack)\n      newOccurrenceStack.push(prod.idx)\n\n      let nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      let nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      let nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      let secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      let nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      let nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      let separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      let secondIteration = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      let nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      let nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      let nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      let separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      let nthRepetition = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      let nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      let nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      let nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      let nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      let nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      let nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        let currAlt: any = prod.definition[i]\n        let currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        }\n        possiblePaths.push(currAltPath)\n        possiblePaths.push(EXIT_ALTERNATIVE)\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      })\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack)\n      )\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n  return result\n}\n\nfunction expandTopLevelRule(\n  topRule: Rule,\n  currIdx: number,\n  currRuleStack: string[],\n  currOccurrenceStack: number[]\n): IPathToExamine {\n  let newRuleStack = cloneArr(currRuleStack)\n  newRuleStack.push(topRule.name)\n\n  let newCurrOccurrenceStack = cloneArr(currOccurrenceStack)\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1)\n\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  }\n}\n", "import {\n  map,\n  reduce,\n  every,\n  isEmpty,\n  flatten,\n  forEach,\n  has\n} from \"../../utils/utils\"\nimport { possiblePathsFrom } from \"./interpreter\"\nimport { RestWalker } from \"./rest\"\nimport { Predicate, TokenMatcher, lookAheadSequence } from \"../parser/parser\"\nimport {\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../scan/tokens\"\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative as AlternativeGAST,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule\n} from \"./gast/gast_public\"\nimport { GAstVisitor } from \"./gast/gast_visitor_public\"\nimport {\n  IOrAlt,\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType\n} from \"../../../api\"\n\nexport enum PROD_TYPE {\n  OPTION,\n  REPETITION,\n  REPETITION_MANDATORY,\n  REPETITION_MANDATORY_WITH_SEPARATOR,\n  REPETITION_WITH_SEPARATOR,\n  ALTERNATION\n}\n\nexport function getProdType(prod: IProduction): PROD_TYPE {\n  /* istanbul ignore else */\n  if (prod instanceof Option) {\n    return PROD_TYPE.OPTION\n  } else if (prod instanceof Repetition) {\n    return PROD_TYPE.REPETITION\n  } else if (prod instanceof RepetitionMandatory) {\n    return PROD_TYPE.REPETITION_MANDATORY\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR\n  } else if (prod instanceof Alternation) {\n    return PROD_TYPE.ALTERNATION\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function buildLookaheadFuncForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  maxLookahead: number,\n  hasPredicates: boolean,\n  dynamicTokensEnabled: boolean,\n  laFuncBuilder: Function\n): (orAlts?: IOrAlt<any>[]) => number {\n  let lookAheadPaths = getLookaheadPathsForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return laFuncBuilder(\n    lookAheadPaths,\n    hasPredicates,\n    tokenMatcher,\n    dynamicTokensEnabled\n  )\n}\n\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  dynamicTokensEnabled: boolean,\n  prodType: PROD_TYPE,\n  lookaheadBuilder: (lookAheadSequence, TokenMatcher, boolean) => () => boolean\n): () => boolean {\n  let lookAheadPaths = getLookaheadPathsForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    prodType,\n    k\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\n}\n\nexport type Alternative = TokenType[][]\n\nexport function buildAlternativesLookAheadFunc(\n  alts: lookAheadSequence[],\n  hasPredicates: boolean,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): (orAlts?: IOrAlt<any>[]) => number {\n  let numOfAlts = alts.length\n  let areAllOneTokenLookahead = every(alts, (currAlt) => {\n    return every(currAlt, (currPath) => {\n      return currPath.length === 1\n    })\n  })\n\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (orAlts: IOrAlt<any>[]): number {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      let predicates: Predicate[] = map(orAlts, (currAlt) => currAlt.GATE)\n\n      for (let t = 0; t < numOfAlts; t++) {\n        let currAlt = alts[t]\n        let currNumOfPaths = currAlt.length\n\n        let currPredicate = predicates[t]\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          let currPath = currAlt[j]\n          let currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            let nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    let singleTokenAlts = map(alts, (currAlt) => {\n      return flatten(currAlt)\n    })\n\n    let choiceToAlt = reduce(\n      singleTokenAlts,\n      (result, currAlt, idx) => {\n        forEach(currAlt, (currTokType) => {\n          if (!has(result, currTokType.tokenTypeIdx)) {\n            result[currTokType.tokenTypeIdx] = idx\n          }\n          forEach(currTokType.categoryMatches, (currExtendingType) => {\n            if (!has(result, currExtendingType)) {\n              result[currExtendingType] = idx\n            }\n          })\n        })\n        return result\n      },\n      []\n    )\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (): number {\n      let nextToken = this.LA(1)\n      return choiceToAlt[nextToken.tokenTypeIdx]\n    }\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (): number {\n      for (let t = 0; t < numOfAlts; t++) {\n        let currAlt = alts[t]\n        let currNumOfPaths = currAlt.length\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          let currPath = currAlt[j]\n          let currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            let nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  }\n}\n\nexport function buildSingleAlternativeLookaheadFunction(\n  alt: lookAheadSequence,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): () => boolean {\n  let areAllOneTokenLookahead = every(alt, (currPath) => {\n    return currPath.length === 1\n  })\n\n  let numOfPaths = alt.length\n\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    let singleTokensTypes = flatten(alt)\n\n    if (\n      singleTokensTypes.length === 1 &&\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\n    ) {\n      let expectedTokenType = singleTokensTypes[0]\n      let expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx\n\n      return function (): boolean {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\n      }\n    } else {\n      let choiceToAlt = reduce(\n        singleTokensTypes,\n        (result, currTokType, idx) => {\n          result[currTokType.tokenTypeIdx] = true\n          forEach(currTokType.categoryMatches, (currExtendingType) => {\n            result[currExtendingType] = true\n          })\n          return result\n        },\n        []\n      )\n\n      return function (): boolean {\n        let nextToken = this.LA(1)\n        return choiceToAlt[nextToken.tokenTypeIdx] === true\n      }\n    }\n  } else {\n    return function (): boolean {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        let currPath = alt[j]\n        let currPathLength = currPath.length\n        for (let i = 0; i < currPathLength; i++) {\n          let nextToken = this.LA(i + 1)\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath\n          }\n        }\n        // found a full path that matches.\n        return true\n      }\n\n      // none of the paths matched\n      return false\n    }\n  }\n}\n\nclass RestDefinitionFinderWalker extends RestWalker {\n  private restDef: IProduction[]\n\n  constructor(\n    private topProd: Rule,\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE\n  ) {\n    super()\n  }\n\n  startWalking(): IProduction[] {\n    this.walk(this.topProd)\n    return this.restDef\n  }\n\n  private checkIsTarget(\n    node: AbstractProduction & IProductionWithOccurrence,\n    expectedProdType: PROD_TYPE,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): boolean {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdType\n    ) {\n      this.restDef = currRest.concat(prevRest)\n      return true\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneProd,\n        PROD_TYPE.REPETITION_MANDATORY,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneSepProd,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest)\n    }\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\n    ) {\n      super.walkOption(manyProd, currRest, prevRest)\n    }\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        manySepProd,\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n  public result: IProduction[] = []\n\n  constructor(\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n    private targetRef?: any\n  ) {\n    super()\n  }\n\n  private checkIsTarget(\n    node: AbstractProduction & IProductionWithOccurrence,\n    expectedProdName: PROD_TYPE\n  ): void {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdName &&\n      (this.targetRef === undefined || node === this.targetRef)\n    ) {\n      this.result = node.definition\n    }\n  }\n\n  public visitOption(node: Option): void {\n    this.checkIsTarget(node, PROD_TYPE.OPTION)\n  }\n\n  public visitRepetition(node: Repetition): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION)\n  }\n\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\n  }\n\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\n  }\n\n  public visitAlternation(node: Alternation): void {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\n  }\n}\n\nfunction initializeArrayOfArrays(size): any[][] {\n  let result = new Array(size)\n  for (let i = 0; i < size; i++) {\n    result[i] = []\n  }\n  return result\n}\n\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path: TokenType[]): string[] {\n  let keys = [\"\"]\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i]\n    let longerKeys = []\n    for (let j = 0; j < keys.length; j++) {\n      const currShorterKey = keys[j]\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx)\n      for (let t = 0; t < tokType.categoryMatches.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t]\n        longerKeys.push(currShorterKey + categoriesKeySuffix)\n      }\n    }\n    keys = longerKeys\n  }\n  return keys\n}\n\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(\n  altKnownPathsKeys: Record<string, boolean>[],\n  searchPathKeys: string[],\n  idx: number\n): boolean {\n  for (\n    let currAltIdx = 0;\n    currAltIdx < altKnownPathsKeys.length;\n    currAltIdx++\n  ) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx]\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true\n}\n\nexport function lookAheadSequenceFromAlternatives(\n  altsDefs: IProduction[],\n  k: number\n): lookAheadSequence[] {\n  let partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1))\n  let finalResult = initializeArrayOfArrays(partialAlts.length)\n  const altsHashes = map(partialAlts, (currAltPaths) => {\n    const dict = {}\n    forEach(currAltPaths, (item) => {\n      const keys = pathToHashKeys(item.partialPath)\n      forEach(keys, (currKey) => {\n        dict[currKey] = true\n      })\n    })\n    return dict\n  })\n  let newData = partialAlts\n\n  // maxLookahead loop\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    let currDataset = newData\n    newData = initializeArrayOfArrays(currDataset.length)\n\n    // alternatives loop\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      let currAltPathsAndSuffixes = currDataset[altIdx]\n      // paths in current alternative loop\n      for (\n        let currPathIdx = 0;\n        currPathIdx < currAltPathsAndSuffixes.length;\n        currPathIdx++\n      ) {\n        let currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\n        let suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\n        const prefixKeys = pathToHashKeys(currPathPrefix)\n        let isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          let currAltResult = finalResult[altIdx]\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix)\n            // Update all new  keys for the current path.\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j]\n              altsHashes[altIdx][currKey] = true\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          let newPartialPathsAndSuffixes = possiblePathsFrom(\n            suffixDef,\n            pathLength + 1,\n            currPathPrefix\n          )\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\n\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys = pathToHashKeys(item.partialPath)\n            forEach(prefixKeys, (key) => {\n              altsHashes[altIdx][key] = true\n            })\n          })\n        }\n      }\n    }\n  }\n\n  return finalResult\n}\n\nexport function getLookaheadPathsForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  orProd?: Alternation\n): lookAheadSequence[] {\n  const visitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    PROD_TYPE.ALTERNATION,\n    orProd\n  )\n  ruleGrammar.accept(visitor)\n  return lookAheadSequenceFromAlternatives(visitor.result, k)\n}\n\nexport function getLookaheadPathsForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  prodType: PROD_TYPE,\n  k: number\n): lookAheadSequence[] {\n  let insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType)\n  ruleGrammar.accept(insideDefVisitor)\n  let insideDef = insideDefVisitor.result\n\n  let afterDefWalker = new RestDefinitionFinderWalker(\n    ruleGrammar,\n    occurrence,\n    prodType\n  )\n  let afterDef = afterDefWalker.startWalking()\n\n  let insideFlat = new AlternativeGAST({ definition: insideDef })\n  let afterFlat = new AlternativeGAST({ definition: afterDef })\n\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\n}\n\nexport function containsPath(\n  alternative: Alternative,\n  searchPath: TokenType[]\n): boolean {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i]\n    if (otherPath.length !== searchPath.length) {\n      continue\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j]\n      const otherTok = otherPath[j]\n\n      const matchingTokens =\n        searchTok === otherTok ||\n        otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined\n      if (matchingTokens === false) {\n        continue compareOtherPath\n      }\n    }\n    return true\n  }\n\n  return false\n}\n\nexport function isStrictPrefixOfPath(\n  prefix: TokenType[],\n  other: TokenType[]\n): boolean {\n  return (\n    prefix.length < other.length &&\n    every(prefix, (tokType, idx) => {\n      const otherTokType = other[idx]\n      return (\n        tokType === otherTokType ||\n        otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]\n      )\n    })\n  )\n}\n\nexport function areTokenCategoriesNotUsed(\n  lookAheadPaths: lookAheadSequence[]\n): boolean {\n  return every(lookAheadPaths, (singleAltPaths) =>\n    every(singleAltPaths, (singlePath) =>\n      every(singlePath, (token) => isEmpty(token.categoryMatches))\n    )\n  )\n}\n", "import * as utils from \"../../utils/utils\"\nimport {\n  contains,\n  every,\n  findAll,\n  flatten,\n  forEach,\n  isEmpty,\n  map,\n  reduce,\n  reject\n} from \"../../utils/utils\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./gast/gast_public\"\nimport { GAstVisitor } from \"./gast/gast_visitor_public\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError,\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType\n} from \"../../../api\"\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  globalMaxLookahead: number,\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  let duplicateErrors: any = utils.map(topLevels, (currTopLevel) =>\n    validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n  let leftRecursionErrors: any = utils.map(topLevels, (currTopRule) =>\n    validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider)\n  )\n\n  let emptyAltErrors = []\n  let ambiguousAltsErrors = []\n  let emptyRepetitionErrors = []\n\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, (currTopRule) =>\n      validateEmptyOrAlternative(currTopRule, errMsgProvider)\n    )\n    ambiguousAltsErrors = map(topLevels, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        globalMaxLookahead,\n        errMsgProvider\n      )\n    )\n\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(\n      topLevels,\n      globalMaxLookahead,\n      errMsgProvider\n    )\n  }\n\n  let termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = map(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = map(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return <any>(\n    utils.flatten(\n      duplicateErrors.concat(\n        emptyRepetitionErrors,\n        leftRecursionErrors,\n        emptyAltErrors,\n        ambiguousAltsErrors,\n        termsNamespaceConflictErrors,\n        tooManyAltsErrors,\n        duplicateRulesError\n      )\n    )\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  let collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  let allRuleProductions = collectorVisitor.allProductions\n\n  let productionGroups = utils.groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  let duplicates: any = utils.pick(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  let errors = utils.map(utils.values(duplicates), (currDuplicates: any) => {\n    let firstProd: any = utils.first(currDuplicates)\n    let msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    let dslName = getProductionDslName(firstProd)\n    let defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    let param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProduction[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  let errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className\n): IParserDefinitionError[] {\n  let errors = []\n  let errMsg\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  let errors = []\n  let nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (utils.isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    let ruleName = topRule.name\n    let foundLeftRecursion = utils.contains(<any>nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    let validNextSteps = utils.difference(\n      nextNonTerminals,\n      path.concat([topRule])\n    )\n    let errorsFromNextSteps = utils.map(validNextSteps, (currRefRule) => {\n      let newPath = utils.cloneArr(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(utils.flatten(errorsFromNextSteps))\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result = []\n  if (utils.isEmpty(definition)) {\n    return result\n  }\n  let firstProd = utils.first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(\n      utils.map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  let isFirstOptional = isOptionalProd(firstProd)\n  let hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    let rest = utils.drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  let orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  let errors = utils.reduce(\n    ors,\n    (errors, currOr) => {\n      let exceptLast = utils.dropRight(currOr.definition)\n      let currErrors = utils.map(\n        exceptLast,\n        (currAlternative: IProduction, currAltIdx) => {\n          const possibleFirstInAlt = nextPossibleTokensAfter(\n            [currAlternative],\n            [],\n            null,\n            1\n          )\n          if (utils.isEmpty(possibleFirstInAlt)) {\n            return {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          } else {\n            return null\n          }\n        }\n      )\n      return errors.concat(utils.compact(currErrors))\n    },\n    []\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  let orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  let errors = utils.reduce(\n    ors,\n    (result, currOr: Alternation) => {\n      let currOccurrence = currOr.idx\n      const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n      let alternatives = getLookaheadPathsForOr(\n        currOccurrence,\n        topLevelRule,\n        actualMaxLookahead,\n        currOr\n      )\n      let altsAmbiguityErrors = checkAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider\n      )\n      let altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider\n      )\n\n      return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors)\n    },\n    []\n  )\n\n  return errors\n}\n\nexport class RepetionCollector extends GAstVisitor {\n  public allProductions: IProduction[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  let orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  let errors = utils.reduce(\n    ors,\n    (errors, currOr) => {\n      if (currOr.definition.length > 255) {\n        errors.push({\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        })\n      }\n      return errors\n    },\n    []\n  )\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  let errors = []\n  forEach(topLevelRules, (currTopRule) => {\n    let collectorVisitor = new RepetionCollector()\n    currTopRule.accept(collectorVisitor)\n    let allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      let prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      let currOccurrence = currProd.idx\n      let paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      let pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  let foundAmbiguousPaths = []\n  let identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        let altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    []\n  )\n\n  let currErrors = utils.map(identicalAmbiguities, (currAmbDescriptor) => {\n    let ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IAmbiguityDescriptor[] {\n  let errors = []\n\n  // flatten\n  let pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      let currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    []\n  )\n\n  forEach(pathsAndIndices, (currPathAndIdx) => {\n    const alternativeGast = alternation.definition[currPathAndIdx.idx]\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return\n    }\n    let targetIdx = currPathAndIdx.idx\n    let targetPath = currPathAndIdx.path\n\n    let prefixAmbiguitiesPathsAndIndices = findAll(\n      pathsAndIndices,\n      (searchPathAndIdx) => {\n        // prefix ambiguity can only be created from lower idx (higher priority) path\n        return (\n          // ignore (skip) ambiguities with this \"other\" alternative\n          alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n            true &&\n          searchPathAndIdx.idx < targetIdx &&\n          // checking for strict prefix because identical lookaheads\n          // will be be detected using a different validation.\n          isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n        )\n      }\n    )\n\n    let currPathPrefixErrors = map(\n      prefixAmbiguitiesPathsAndIndices,\n      (currAmbPathAndIdx) => {\n        let ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n        const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n        const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n          topLevelRule: rule,\n          alternation: alternation,\n          ambiguityIndices: ambgIndices,\n          prefixPath: currAmbPathAndIdx.path\n        })\n        return {\n          message: message,\n          type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n          ruleName: rule.name,\n          occurrence: occurrence,\n          alternatives: ambgIndices\n        }\n      }\n    )\n    errors = errors.concat(currPathPrefixErrors)\n  })\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  let errors = []\n\n  let tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (contains(tokenNames, currRuleName)) {\n      let errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n", "import { Rule } from \"./gast_public\"\n\nimport { defaults, forEach } from \"../../../utils/utils\"\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver\"\nimport { validateGrammar as orgValidateGrammar } from \"../checks\"\nimport {\n  defaultGrammarResolverErrorProvider,\n  defaultGrammarValidatorErrorProvider\n} from \"../../errors_public\"\nimport { DslMethodsCollectorVisitor } from \"./gast\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError,\n  IProductionWithOccurrence,\n  TokenType\n} from \"../../../../api\"\n\nexport function resolveGrammar(options: {\n  rules: Rule[]\n  errMsgProvider?: IGrammarResolverErrorMessageProvider\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider\n  })\n\n  const topRulesTable = {}\n  forEach(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule\n  })\n  return orgResolveGrammar(topRulesTable, options.errMsgProvider)\n}\n\nexport function validateGrammar(options: {\n  rules: Rule[]\n  maxLookahead: number\n  tokenTypes: TokenType[]\n  grammarName: string\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider\n  })\n\n  return orgValidateGrammar(\n    options.rules,\n    options.maxLookahead,\n    options.tokenTypes,\n    options.errMsgProvider,\n    options.grammarName\n  )\n}\n\nexport function assignOccurrenceIndices(options: { rules: Rule[] }): void {\n  forEach(options.rules, (currRule) => {\n    const methodsCollector = new DslMethodsCollectorVisitor()\n    currRule.accept(methodsCollector)\n    forEach(methodsCollector.dslMethods, (methods) => {\n      forEach(methods, (currMethod: IProductionWithOccurrence, arrIdx) => {\n        currMethod.idx = arrIdx + 1\n      })\n    })\n  })\n}\n", "import { contains } from \"../utils/utils\"\nimport { IToken, IRecognitionException, IRecognizerContext } from \"../../api\"\n\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\"\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\"\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\"\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\"\n\nconst RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION\n]\n\nObject.freeze(RECOGNITION_EXCEPTION_NAMES)\n\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error: Error) {\n  // can't do instanceof on hacked custom js exceptions\n  return contains(RECOGNITION_EXCEPTION_NAMES, error.name)\n}\n\nabstract class RecognitionException\n  extends Error\n  implements IRecognitionException {\n  context: IRecognizerContext\n  resyncedTokens = []\n\n  protected constructor(message: string, public token: IToken) {\n    super(message)\n\n    // fix prototype chain when typescript target is ES5\n    Object.setPrototypeOf(this, new.target.prototype)\n\n    /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n  }\n}\n\nexport class MismatchedTokenException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = MISMATCHED_TOKEN_EXCEPTION\n  }\n}\n\nexport class NoViableAltException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = NO_VIABLE_ALT_EXCEPTION\n  }\n}\n\nexport class NotAllInputParsedException extends RecognitionException {\n  constructor(message: string, token: IToken) {\n    super(message, token)\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION\n  }\n}\n\nexport class EarlyExitException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = EARLY_EXIT_EXCEPTION\n  }\n}\n", "import { createTokenInstance, EOF } from \"../../../scan/tokens_public\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  IFirstAfterRepetition\n} from \"../../grammar/interpreter\"\nimport {\n  cloneArr,\n  contains,\n  dropRight,\n  find,\n  flatten,\n  has,\n  isEmpty,\n  map\n} from \"../../../utils/utils\"\nimport {\n  IParserConfig,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"../../../../api\"\nimport { MismatchedTokenException } from \"../../exceptions_public\"\nimport { IN } from \"../../constants\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\nexport const EOF_FOLLOW_KEY: any = {}\n\nexport interface IFollowKey {\n  ruleName: string\n  idxInCallingRule: number\n  inRule: string\n}\n\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\"\n\nexport function InRuleRecoveryException(message: string) {\n  this.name = IN_RULE_RECOVERY_EXCEPTION\n  this.message = message\n}\n\nInRuleRecoveryException.prototype = Error.prototype\n\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n  recoveryEnabled: boolean\n  firstAfterRepMap: Record<string, IFirstAfterRepetition>\n  resyncFollows: Record<string, TokenType[]>\n\n  initRecoverable(config: IParserConfig) {\n    this.firstAfterRepMap = {}\n    this.resyncFollows = {}\n\n    this.recoveryEnabled = has(config, \"recoveryEnabled\")\n      ? config.recoveryEnabled\n      : DEFAULT_PARSER_CONFIG.recoveryEnabled\n\n    // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery\n    }\n  }\n\n  public getTokenToInsert(tokType: TokenType): IToken {\n    let tokToInsert = createTokenInstance(\n      tokType,\n      \"\",\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN\n    )\n    tokToInsert.isInsertedInRecovery = true\n    return tokToInsert\n  }\n\n  public canTokenTypeBeInsertedInRecovery(tokType: TokenType) {\n    return true\n  }\n\n  tryInRepetitionRecovery(\n    this: MixedInParser,\n    grammarRule: Function,\n    grammarRuleArgs: any[],\n    lookAheadFunc: () => boolean,\n    expectedTokType: TokenType\n  ): void {\n    // TODO: can the resyncTokenType be cached?\n    let reSyncTokType = this.findReSyncTokenType()\n    let savedLexerState = this.exportLexerState()\n    let resyncedTokens = []\n    let passedResyncPoint = false\n\n    let nextTokenWithoutResync = this.LA(1)\n    let currToken = this.LA(1)\n\n    let generateErrorMessage = () => {\n      let previousToken = this.LA(0)\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n      let msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n      let error = new MismatchedTokenException(\n        msg,\n        nextTokenWithoutResync,\n        this.LA(0)\n      )\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n      error.resyncedTokens = dropRight(resyncedTokens)\n      this.SAVE_ERROR(error)\n    }\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage()\n        return // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage()\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n        grammarRule.apply(this, grammarRuleArgs)\n        return // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true\n      } else {\n        currToken = this.SKIP_TOKEN()\n        this.addToResyncTokens(currToken, resyncedTokens)\n      }\n    }\n\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n    this.importLexerState(savedLexerState)\n  }\n\n  shouldInRepetitionRecoveryBeTried(\n    this: MixedInParser,\n    expectTokAfterLastMatch: TokenType,\n    nextTokIdx: number,\n    notStuck: boolean | undefined\n  ): boolean {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false\n    }\n\n    // arguments to try and perform resync into the next iteration of the many are missing\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return false\n    }\n\n    // no need to recover, next token is what we expect...\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false\n    }\n\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n    if (this.isBackTracking()) {\n      return false\n    }\n\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n    if (\n      this.canPerformInRuleRecovery(\n        expectTokAfterLastMatch,\n        this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx)\n      )\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number\n  ): TokenType[] {\n    let grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule)\n    let follows = this.getNextPossibleTokenTypes(grammarPath)\n    return follows\n  }\n\n  tryInRuleRecovery(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[]\n  ): IToken {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      let tokToInsert = this.getTokenToInsert(expectedTokType)\n      return tokToInsert\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      let nextTok = this.SKIP_TOKEN()\n      this.consumeToken()\n      return nextTok\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\")\n  }\n\n  canPerformInRuleRecovery(\n    this: MixedInParser,\n    expectedToken: TokenType,\n    follows: TokenType[]\n  ): boolean {\n    return (\n      this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n      this.canRecoverWithSingleTokenDeletion(expectedToken)\n    )\n  }\n\n  canRecoverWithSingleTokenInsertion(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[]\n  ): boolean {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false\n    }\n\n    // must know the possible following tokens to perform single token insertion\n    if (isEmpty(follows)) {\n      return false\n    }\n\n    let mismatchedTok = this.LA(1)\n    let isMisMatchedTokInFollows =\n      find(follows, (possibleFollowsTokType: TokenType) => {\n        return this.tokenMatcher(mismatchedTok, possibleFollowsTokType)\n      }) !== undefined\n\n    return isMisMatchedTokInFollows\n  }\n\n  canRecoverWithSingleTokenDeletion(\n    this: MixedInParser,\n    expectedTokType: TokenType\n  ): boolean {\n    let isNextTokenWhatIsExpected = this.tokenMatcher(\n      this.LA(2),\n      expectedTokType\n    )\n    return isNextTokenWhatIsExpected\n  }\n\n  isInCurrentRuleReSyncSet(\n    this: MixedInParser,\n    tokenTypeIdx: TokenType\n  ): boolean {\n    let followKey = this.getCurrFollowKey()\n    let currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey)\n    return contains(currentRuleReSyncSet, tokenTypeIdx)\n  }\n\n  findReSyncTokenType(this: MixedInParser): TokenType {\n    let allPossibleReSyncTokTypes = this.flattenFollowSet()\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    let nextToken = this.LA(1)\n    let k = 2\n    while (true) {\n      let nextTokenType: any = nextToken.tokenType\n      if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n        return nextTokenType\n      }\n      nextToken = this.LA(k)\n      k++\n    }\n  }\n\n  getCurrFollowKey(this: MixedInParser): IFollowKey {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY\n    }\n    let currRuleShortName = this.getLastExplicitRuleShortName()\n    let currRuleIdx = this.getLastExplicitRuleOccurrenceIndex()\n    let prevRuleShortName = this.getPreviousExplicitRuleShortName()\n\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    }\n  }\n\n  buildFullFollowKeyStack(this: MixedInParser): IFollowKey[] {\n    let explicitRuleStack = this.RULE_STACK\n    let explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK\n\n    return map(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      }\n    })\n  }\n\n  flattenFollowSet(this: MixedInParser): TokenType[] {\n    let followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey)\n    })\n    return <any>flatten(followStack)\n  }\n\n  getFollowSetFromFollowKey(\n    this: MixedInParser,\n    followKey: IFollowKey\n  ): TokenType[] {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF]\n    }\n\n    let followName =\n      followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule\n\n    return this.resyncFollows[followName]\n  }\n\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(\n    this: MixedInParser,\n    token: IToken,\n    resyncTokens: IToken[]\n  ): IToken[] {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token)\n    }\n    return resyncTokens\n  }\n\n  reSyncTo(this: MixedInParser, tokType: TokenType): IToken[] {\n    let resyncedTokens = []\n    let nextTok = this.LA(1)\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN()\n      this.addToResyncTokens(nextTok, resyncedTokens)\n    }\n    // the last token is not part of the error.\n    return dropRight(resyncedTokens)\n  }\n\n  attemptInRepetitionRecovery(\n    this: MixedInParser,\n    prodFunc: Function,\n    args: any[],\n    lookaheadFunc: () => boolean,\n    dslMethodIdx: number,\n    prodOccurrence: number,\n    nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n    notStuck?: boolean\n  ): void {\n    // by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  }\n\n  getCurrentGrammarPath(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number\n  ): ITokenGrammarPath {\n    let pathRuleStack: string[] = this.getHumanReadableRuleStack()\n    let pathOccurrenceStack: number[] = cloneArr(this.RULE_OCCURRENCE_STACK)\n    let grammarPath: any = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    }\n\n    return grammarPath\n  }\n  getHumanReadableRuleStack(this: MixedInParser): string[] {\n    return map(this.RULE_STACK, (currShortName) =>\n      this.shortRuleNameToFullName(currShortName)\n    )\n  }\n}\n\nexport function attemptInRepetitionRecovery(\n  this: MixedInParser,\n  prodFunc: Function,\n  args: any[],\n  lookaheadFunc: () => boolean,\n  dslMethodIdx: number,\n  prodOccurrence: number,\n  nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n  notStuck?: boolean\n) {\n  let key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence)\n  let firstAfterRepInfo = this.firstAfterRepMap[key]\n  if (firstAfterRepInfo === undefined) {\n    let currRuleName = this.getCurrRuleFullName()\n    let ruleGrammar = this.getGAstProductions()[currRuleName]\n    let walker: AbstractNextTerminalAfterProductionWalker = new nextToksWalker(\n      ruleGrammar,\n      prodOccurrence\n    )\n    firstAfterRepInfo = walker.startWalking()\n    this.firstAfterRepMap[key] = firstAfterRepInfo\n  }\n\n  let expectTokAfterLastMatch = firstAfterRepInfo.token\n  let nextTokIdx = firstAfterRepInfo.occurrence\n  let isEndOfRule = firstAfterRepInfo.isEndOfRule\n\n  // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n  if (\n    this.RULE_STACK.length === 1 &&\n    isEndOfRule &&\n    expectTokAfterLastMatch === undefined\n  ) {\n    expectTokAfterLastMatch = EOF\n    nextTokIdx = 1\n  }\n\n  if (\n    this.shouldInRepetitionRecoveryBeTried(\n      expectTokAfterLastMatch,\n      nextTokIdx,\n      notStuck\n    )\n  ) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(\n      prodFunc,\n      args,\n      lookaheadFunc,\n      expectTokAfterLastMatch\n    )\n  }\n}\n", "// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\n\nexport const BITS_FOR_METHOD_TYPE = 4\nexport const BITS_FOR_OCCURRENCE_IDX = 8\nexport const BITS_FOR_RULE_IDX = 12\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8\n\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n/* tslint:disable */\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX\n/* tslint:enable */\n\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(\n  ruleIdx: number,\n  dslMethodIdx: number,\n  occurrence: number\n): number {\n  /* tslint:disable */\n  return occurrence | dslMethodIdx | ruleIdx\n  /* tslint:enable */\n}\n\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX\n", "import {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { forEach, has, isES2015MapSupported } from \"../../../utils/utils\"\nimport {\n  DEFAULT_PARSER_CONFIG,\n  lookAheadSequence,\n  TokenMatcher\n} from \"../parser\"\nimport { IOrAlt, IParserConfig } from \"../../../../api\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { Rule } from \"../../grammar/gast/gast_public\"\nimport { collectMethods, getProductionDslName } from \"../../grammar/gast/gast\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? config.dynamicTokensEnabled\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? config.maxLookahead\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    this.lookAheadFuncsCache = isES2015MapSupported() ? new Map() : []\n\n    // Performance optimization on newer engines that support ES6 Map\n    // For larger Maps this is slightly faster than using a plain object (array in our case).\n    /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n    if (isES2015MapSupported()) {\n      this.getLaFuncFromCache = this.getLaFuncFromMap\n      this.setLaFuncCache = this.setLaFuncCacheUsingMap\n    } else {\n      this.getLaFuncFromCache = this.getLaFuncFromObj\n      this.setLaFuncCache = this.setLaFuncUsingObj\n    }\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = buildLookaheadFuncForOr(\n              currProd.idx,\n              currRule,\n              currProd.maxLookahead || this.maxLookahead,\n              currProd.hasPredicates,\n              this.dynamicTokensEnabled,\n              this.lookAheadBuilderForAlternatives\n            )\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            PROD_TYPE.REPETITION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            PROD_TYPE.OPTION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            PROD_TYPE.REPETITION_MANDATORY,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            PROD_TYPE.REPETITION_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: PROD_TYPE,\n    prodMaxLookahead: number,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = buildLookaheadFuncForOptionalProd(\n          prodOccurrence,\n          rule,\n          prodMaxLookahead || this.maxLookahead,\n          this.dynamicTokensEnabled,\n          prodType,\n          this.lookAheadBuilderForOptional\n        )\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  lookAheadBuilderForOptional(\n    this: MixedInParser,\n    alt: lookAheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): () => boolean {\n    return buildSingleAlternativeLookaheadFunction(\n      alt,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  lookAheadBuilderForAlternatives(\n    this: MixedInParser,\n    alts: lookAheadSequence[],\n    hasPredicates: boolean,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): (orAlts?: IOrAlt<any>[]) => number | undefined {\n    return buildAlternativesLookAheadFunc(\n      alts,\n      hasPredicates,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    let currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  /* istanbul ignore next */\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return undefined\n  }\n\n  getLaFuncFromMap(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  getLaFuncFromObj(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache[key]\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {}\n\n  setLaFuncCacheUsingMap(\n    this: MixedInParser,\n    key: number,\n    value: Function\n  ): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  setLaFuncUsingObj(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache[key] = value\n  }\n}\n", "import { CstNode, CstNodeLocation, IToken } from \"../../../api\"\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: IToken\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n}\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: CstNodeLocation\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.startColumn = newLocationInfo.startColumn\n    currNodeLocation.startLine = newLocationInfo.startLine\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n}\n\nexport function addTerminalToCst(\n  node: CstNode,\n  token: IToken,\n  tokenTypeName: string\n): void {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token]\n  } else {\n    node.children[tokenTypeName].push(token)\n  }\n}\n\nexport function addNoneTerminalToCst(\n  node: CstNode,\n  ruleName: string,\n  ruleResult: any\n): void {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult]\n  } else {\n    node.children[ruleName].push(ruleResult)\n  }\n}\n", "import { TokenType } from \"../../api\"\nimport { isUndefined } from \"../utils/utils\"\n\nexport function classNameFromInstance(instance: any): string {\n  return functionName(instance.constructor)\n}\n\nconst NAME = \"name\"\n\n/**\n * Utility to obtain Function names.\n * Note that there should not be an assumptions on the result of this function.\n * E.g: When running from minified source code the result may be auto generated.\n */\nexport function functionName(func: TokenType): string {\n  // Engines that support Function.prototype.name OR the nth (n>1) time after\n  // the name has been computed in the following else block.\n  let existingNameProp = (<any>func).name\n  /* istanbul ignore else - too many hacks for IE/old versions of node.js here*/\n  if (existingNameProp) {\n    return existingNameProp\n  } else {\n    return \"anonymous\"\n  }\n}\n\n/**\n * @returns {boolean} - has the property been successfully defined\n */\nexport function defineNameProp(obj, nameValue): boolean {\n  let namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME)\n  /* istanbul ignore else -> will only run in old versions of node.js */\n  if (isUndefined(namePropDescriptor) || namePropDescriptor.configurable) {\n    Object.defineProperty(obj, NAME, {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: nameValue\n    })\n\n    return true\n  }\n  /* istanbul ignore next -> will only run in old versions of node.js */\n  return false\n}\n", "import {\n  compact,\n  contains,\n  forEach,\n  isArray,\n  isEmpty,\n  isFunction,\n  isUndefined,\n  keys,\n  map\n} from \"../../utils/utils\"\nimport { defineNameProp, functionName } from \"../../lang/lang_extensions\"\nimport { ICstVisitor } from \"../../../api\"\n\nexport function defaultVisit<IN, OUT>(ctx: any, param: IN): OUT {\n  let childrenNames = keys(ctx)\n  let childrenNamesLength = childrenNames.length\n  for (let i = 0; i < childrenNamesLength; i++) {\n    let currChildName = childrenNames[i]\n    let currChildArray = ctx[currChildName]\n    let currChildArrayLength = currChildArray.length\n    for (let j = 0; j < currChildArrayLength; j++) {\n      let currChild: any = currChildArray[j]\n      // distinction between Tokens Children and CstNode children\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param)\n      }\n    }\n  }\n  // defaultVisit does not support generic out param\n  return undefined\n}\n\nexport function createBaseSemanticVisitorConstructor(\n  grammarName: string,\n  ruleNames: string[]\n): {\n  new (...args: any[]): ICstVisitor<any, any>\n} {\n  let derivedConstructor: any = function () {}\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\")\n\n  let semanticProto = {\n    visit: function (cstNode, param) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0]\n      }\n\n      // enables passing optional CstNodes concisely.\n      if (isUndefined(cstNode)) {\n        return undefined\n      }\n\n      return this[cstNode.name](cstNode.children, param)\n    },\n\n    validateVisitor: function () {\n      let semanticDefinitionErrors = validateVisitor(this, ruleNames)\n      if (!isEmpty(semanticDefinitionErrors)) {\n        let errorMessages = map(\n          semanticDefinitionErrors,\n          (currDefError) => currDefError.msg\n        )\n        throw Error(\n          `Errors Detected in CST Visitor <${functionName(\n            this.constructor\n          )}>:\\n\\t` + `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`\n        )\n      }\n    }\n  }\n\n  derivedConstructor.prototype = semanticProto\n  derivedConstructor.prototype.constructor = derivedConstructor\n\n  derivedConstructor._RULE_NAMES = ruleNames\n\n  return derivedConstructor\n}\n\nexport function createBaseVisitorConstructorWithDefaults(\n  grammarName: string,\n  ruleNames: string[],\n  baseConstructor: Function\n): {\n  new (...args: any[]): ICstVisitor<any, any>\n} {\n  let derivedConstructor: any = function () {}\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\")\n\n  let withDefaultsProto = Object.create(baseConstructor.prototype)\n  forEach(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit\n  })\n\n  derivedConstructor.prototype = withDefaultsProto\n  derivedConstructor.prototype.constructor = derivedConstructor\n\n  return derivedConstructor\n}\n\nexport enum CstVisitorDefinitionError {\n  REDUNDANT_METHOD,\n  MISSING_METHOD\n}\n\nexport interface IVisitorDefinitionError {\n  msg: string\n  type: CstVisitorDefinitionError\n  methodName: string\n}\n\nexport function validateVisitor(\n  visitorInstance: Function,\n  ruleNames: string[]\n): IVisitorDefinitionError[] {\n  let missingErrors = validateMissingCstMethods(visitorInstance, ruleNames)\n  let redundantErrors = validateRedundantMethods(visitorInstance, ruleNames)\n\n  return missingErrors.concat(redundantErrors)\n}\n\nexport function validateMissingCstMethods(\n  visitorInstance: Function,\n  ruleNames: string[]\n): IVisitorDefinitionError[] {\n  let errors: IVisitorDefinitionError[] = map(ruleNames, (currRuleName) => {\n    if (!isFunction(visitorInstance[currRuleName])) {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${functionName(\n          <any>visitorInstance.constructor\n        )} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName\n      }\n    }\n  })\n\n  return compact<IVisitorDefinitionError>(errors)\n}\n\nconst VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"]\nexport function validateRedundantMethods(\n  visitorInstance: Function,\n  ruleNames: string[]\n): IVisitorDefinitionError[] {\n  let errors = []\n\n  for (let prop in visitorInstance) {\n    if (\n      isFunction(visitorInstance[prop]) &&\n      !contains(VALID_PROP_NAMES, prop) &&\n      !contains(ruleNames, prop)\n    ) {\n      errors.push({\n        msg:\n          `Redundant visitor method: <${prop}> on ${functionName(\n            <any>visitorInstance.constructor\n          )} CST Visitor\\n` +\n          `There is no Grammar Rule corresponding to this method's name.\\n`,\n        type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n        methodName: prop\n      })\n    }\n  }\n  return errors\n}\n", "import {\n  addNoneTerminalToCst,\n  addTerminalToCst,\n  setNodeLocationFull,\n  setNodeLocationOnlyOffset\n} from \"../../cst/cst\"\nimport { has, isUndefined, keys, NOOP } from \"../../../utils/utils\"\nimport {\n  createBaseSemanticVisitorConstructor,\n  createBaseVisitorConstructorWithDefaults\n} from \"../../cst/cst_visitor\"\nimport {\n  CstNode,\n  CstNodeLocation,\n  ICstVisitor,\n  IParserConfig,\n  IToken,\n  nodeLocationTrackingOptions\n} from \"../../../../api\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n  outputCst: boolean\n  CST_STACK: CstNode[]\n  baseCstVisitorConstructor: Function\n  baseCstVisitorWithDefaultsConstructor: Function\n\n  // dynamically assigned Methods\n  setNodeLocationFromNode: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  setNodeLocationFromToken: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void\n\n  setInitialNodeLocation: (cstNode: CstNode) => void\n  nodeLocationTracking: nodeLocationTrackingOptions\n\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\n    this.CST_STACK = []\n\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = (config as any).outputCst\n\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n      ? config.nodeLocationTracking\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP\n      this.cstFinallyStateUpdate = NOOP\n      this.cstPostTerminal = NOOP\n      this.cstPostNonTerminal = NOOP\n      this.cstPostRule = NOOP\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull\n          this.setNodeLocationFromNode = setNodeLocationFull\n          this.cstPostRule = NOOP\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n        } else {\n          this.setNodeLocationFromToken = NOOP\n          this.setNodeLocationFromNode = NOOP\n          this.cstPostRule = this.cstPostRuleFull\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset\n          this.cstPostRule = NOOP\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery\n        } else {\n          this.setNodeLocationFromToken = NOOP\n          this.setNodeLocationFromNode = NOOP\n          this.cstPostRule = this.cstPostRuleOnlyOffset\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP\n        this.setNodeLocationFromNode = NOOP\n        this.cstPostRule = NOOP\n        this.setInitialNodeLocation = NOOP\n      } else {\n        throw Error(\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`\n        )\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\n    const nextToken = this.LA(1)\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  cstInvocationStateUpdate(\n    this: MixedInParser,\n    fullRuleName: string,\n    shortName: string | number\n  ): void {\n    const cstNode: CstNode = {\n      name: fullRuleName,\n      children: {}\n    }\n\n    this.setInitialNodeLocation(cstNode)\n    this.CST_STACK.push(cstNode)\n  }\n\n  cstFinallyStateUpdate(this: MixedInParser): void {\n    this.CST_STACK.pop()\n  }\n\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    const loc = ruleCstNode.location\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n      loc.endLine = prevToken.endLine\n      loc.endColumn = prevToken.endColumn\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n      loc.startLine = NaN\n      loc.startColumn = NaN\n    }\n  }\n\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    const loc = ruleCstNode.location\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n    }\n  }\n\n  cstPostTerminal(\n    this: MixedInParser,\n    key: string,\n    consumedToken: IToken\n  ): void {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n    addTerminalToCst(rootCst, consumedToken, key)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, <any>consumedToken)\n  }\n\n  cstPostNonTerminal(\n    this: MixedInParser,\n    ruleCstResult: CstNode,\n    ruleName: string\n  ): void {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location)\n  }\n\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n        this.className,\n        keys(this.gastProductionsCache)\n      )\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n      return newBaseCstVisitorConstructor\n    }\n\n    return <any>this.baseCstVisitorConstructor\n  }\n\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\n        this.className,\n        keys(this.gastProductionsCache),\n        this.getBaseCstVisitorConstructor()\n      )\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor\n      return newConstructor\n    }\n\n    return <any>this.baseCstVisitorWithDefaultsConstructor\n  }\n\n  getLastExplicitRuleShortName(this: MixedInParser): string {\n    let ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 1]\n  }\n\n  getPreviousExplicitRuleShortName(this: MixedInParser): string {\n    let ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 2]\n  }\n\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\n    let occurrenceStack = this.RULE_OCCURRENCE_STACK\n    return occurrenceStack[occurrenceStack.length - 1]\n  }\n}\n", "import { END_OF_FILE } from \"../parser\"\nimport { IToken } from \"../../../../api\"\nimport { MixedInParser } from \"./parser_traits\"\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n  tokVector: IToken[]\n  tokVectorLength\n  currIdx: number\n\n  initLexerAdapter() {\n    this.tokVector = []\n    this.tokVectorLength = 0\n    this.currIdx = -1\n  }\n\n  set input(newInput: IToken[]) {\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    if (this.selfAnalysisDone !== true) {\n      throw Error(\n        `Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`\n      )\n    }\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    this.reset()\n    this.tokVector = newInput\n    this.tokVectorLength = newInput.length\n  }\n\n  get input(): IToken[] {\n    return this.tokVector\n  }\n\n  // skips a token and returns the next token\n  SKIP_TOKEN(this: MixedInParser): IToken {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken()\n      return this.LA(1)\n    } else {\n      return END_OF_FILE\n    }\n  }\n\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(this: MixedInParser, howMuch: number): IToken {\n    const soughtIdx = this.currIdx + howMuch\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE\n    } else {\n      return this.tokVector[soughtIdx]\n    }\n  }\n\n  consumeToken(this: MixedInParser) {\n    this.currIdx++\n  }\n\n  exportLexerState(this: MixedInParser): number {\n    return this.currIdx\n  }\n\n  importLexerState(this: MixedInParser, newState: number) {\n    this.currIdx = newState\n  }\n\n  resetLexerState(this: MixedInParser): void {\n    this.currIdx = -1\n  }\n\n  moveToTerminatedState(this: MixedInParser): void {\n    this.currIdx = this.tokVector.length - 1\n  }\n\n  getLexerPosition(this: MixedInParser): number {\n    return this.exportLexerState()\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IRuleConfig,\n  ISerializedGast,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"../../../../api\"\nimport { contains, values } from \"../../../utils/utils\"\nimport { isRecognitionException } from \"../../exceptions_public\"\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser\"\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public\"\nimport { validateRuleIsOverridden } from \"../../grammar/checks\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { Rule, serializeGrammar } from \"../../grammar/gast/gast_public\"\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n  ACTION<T>(this: MixedInParser, impl: () => T): T {\n    return impl.call(this)\n  }\n\n  consume(\n    this: MixedInParser,\n    idx: number,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, idx, options)\n  }\n\n  subrule<T>(\n    this: MixedInParser,\n    idx: number,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, idx, options)\n  }\n\n  option<OUT>(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, idx)\n  }\n\n  or(\n    this: MixedInParser,\n    idx: number,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>\n  ): any {\n    return this.orInternal(altsOrOpts, idx)\n  }\n\n  many(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>\n  ): void {\n    return this.manyInternal(idx, actionORMethodDef)\n  }\n\n  atLeastOne(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>\n  ): void {\n    return this.atLeastOneInternal(idx, actionORMethodDef)\n  }\n\n  CONSUME(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 0, options)\n  }\n\n  CONSUME1(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 1, options)\n  }\n\n  CONSUME2(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 2, options)\n  }\n\n  CONSUME3(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 3, options)\n  }\n\n  CONSUME4(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 4, options)\n  }\n\n  CONSUME5(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 5, options)\n  }\n\n  CONSUME6(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 6, options)\n  }\n\n  CONSUME7(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 7, options)\n  }\n\n  CONSUME8(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 8, options)\n  }\n\n  CONSUME9(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 9, options)\n  }\n\n  SUBRULE<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 0, options)\n  }\n\n  SUBRULE1<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 1, options)\n  }\n\n  SUBRULE2<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 2, options)\n  }\n\n  SUBRULE3<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 3, options)\n  }\n\n  SUBRULE4<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 4, options)\n  }\n\n  SUBRULE5<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 5, options)\n  }\n\n  SUBRULE6<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 6, options)\n  }\n\n  SUBRULE7<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 7, options)\n  }\n\n  SUBRULE8<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 8, options)\n  }\n\n  SUBRULE9<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    options?: SubruleMethodOpts\n  ): T {\n    return this.subruleInternal(ruleToCall, 9, options)\n  }\n\n  OPTION<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 0)\n  }\n\n  OPTION1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 1)\n  }\n\n  OPTION2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 2)\n  }\n\n  OPTION3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 3)\n  }\n\n  OPTION4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 4)\n  }\n\n  OPTION5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 5)\n  }\n\n  OPTION6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 6)\n  }\n\n  OPTION7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 7)\n  }\n\n  OPTION8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 8)\n  }\n\n  OPTION9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT {\n    return this.optionInternal(actionORMethodDef, 9)\n  }\n\n  OR<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 0)\n  }\n\n  OR1<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 1)\n  }\n\n  OR2<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 2)\n  }\n\n  OR3<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 3)\n  }\n\n  OR4<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 4)\n  }\n\n  OR5<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 5)\n  }\n\n  OR6<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 6)\n  }\n\n  OR7<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 7)\n  }\n\n  OR8<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 8)\n  }\n\n  OR9<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 9)\n  }\n\n  MANY<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(0, actionORMethodDef)\n  }\n\n  MANY1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(1, actionORMethodDef)\n  }\n\n  MANY2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(2, actionORMethodDef)\n  }\n\n  MANY3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(3, actionORMethodDef)\n  }\n\n  MANY4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(4, actionORMethodDef)\n  }\n\n  MANY5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(5, actionORMethodDef)\n  }\n\n  MANY6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(6, actionORMethodDef)\n  }\n\n  MANY7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(7, actionORMethodDef)\n  }\n\n  MANY8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(8, actionORMethodDef)\n  }\n\n  MANY9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(9, actionORMethodDef)\n  }\n\n  MANY_SEP<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(0, options)\n  }\n\n  MANY_SEP1<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(1, options)\n  }\n\n  MANY_SEP2<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(2, options)\n  }\n\n  MANY_SEP3<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(3, options)\n  }\n\n  MANY_SEP4<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(4, options)\n  }\n\n  MANY_SEP5<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(5, options)\n  }\n\n  MANY_SEP6<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(6, options)\n  }\n\n  MANY_SEP7<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(7, options)\n  }\n\n  MANY_SEP8<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(8, options)\n  }\n\n  MANY_SEP9<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(9, options)\n  }\n\n  AT_LEAST_ONE<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(0, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    return this.atLeastOneInternal(1, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(2, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(3, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(4, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(5, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(6, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(7, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(8, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(9, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE_SEP<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(0, options)\n  }\n\n  AT_LEAST_ONE_SEP1<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(1, options)\n  }\n\n  AT_LEAST_ONE_SEP2<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(2, options)\n  }\n\n  AT_LEAST_ONE_SEP3<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(3, options)\n  }\n\n  AT_LEAST_ONE_SEP4<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(4, options)\n  }\n\n  AT_LEAST_ONE_SEP5<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(5, options)\n  }\n\n  AT_LEAST_ONE_SEP6<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(6, options)\n  }\n\n  AT_LEAST_ONE_SEP7<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(7, options)\n  }\n\n  AT_LEAST_ONE_SEP8<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(8, options)\n  }\n\n  AT_LEAST_ONE_SEP9<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(9, options)\n  }\n\n  RULE<T>(\n    this: MixedInParser,\n    name: string,\n    implementation: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG\n  ): (idxInCallingRule?: number, ...args: any[]) => T | any {\n    if (contains(this.definedRulesNames, name)) {\n      const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError(\n        {\n          topLevelRule: name,\n          grammarName: this.className\n        }\n      )\n\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name\n      }\n      this.definitionErrors.push(error)\n    }\n\n    this.definedRulesNames.push(name)\n\n    let ruleImplementation = this.defineRule(name, implementation, config)\n    this[name] = ruleImplementation\n    return ruleImplementation\n  }\n\n  OVERRIDE_RULE<T>(\n    this: MixedInParser,\n    name: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    let ruleErrors = []\n    ruleErrors = ruleErrors.concat(\n      validateRuleIsOverridden(name, this.definedRulesNames, this.className)\n    )\n    this.definitionErrors.push.apply(this.definitionErrors, ruleErrors) // mutability for the win\n\n    let ruleImplementation = this.defineRule(name, impl, config)\n    this[name] = ruleImplementation\n    return ruleImplementation\n  }\n\n  BACKTRACK<T>(\n    this: MixedInParser,\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return function () {\n      // save org state\n      this.isBackTrackingStack.push(1)\n      const orgState = this.saveRecogState()\n      try {\n        grammarRule.apply(this, args)\n        // if no exception was thrown we have succeed parsing the rule.\n        return true\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false\n        } else {\n          throw e\n        }\n      } finally {\n        this.reloadRecogState(orgState)\n        this.isBackTrackingStack.pop()\n      }\n    }\n  }\n\n  // GAST export APIs\n  public getGAstProductions(this: MixedInParser): Record<string, Rule> {\n    return this.gastProductionsCache\n  }\n\n  public getSerializedGastProductions(this: MixedInParser): ISerializedGast[] {\n    return serializeGrammar(values(this.gastProductionsCache))\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IRuleConfig,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType,\n  TokenVocabulary\n} from \"../../../../api\"\nimport {\n  cloneArr,\n  cloneObj,\n  every,\n  flatten,\n  has,\n  isArray,\n  isEmpty,\n  isObject,\n  reduce,\n  uniq,\n  values\n} from \"../../../utils/utils\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  BITS_FOR_METHOD_TYPE,\n  BITS_FOR_OCCURRENCE_IDX,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport {\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException\n} from \"../../exceptions_public\"\nimport { PROD_TYPE } from \"../../grammar/lookahead\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  NextTerminalAfterAtLeastOneSepWalker,\n  NextTerminalAfterAtLeastOneWalker,\n  NextTerminalAfterManySepWalker,\n  NextTerminalAfterManyWalker\n} from \"../../grammar/interpreter\"\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser\"\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\"\nimport { EOF } from \"../../../scan/tokens_public\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  augmentTokenTypes,\n  isTokenType,\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../../scan/tokens\"\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\"\nimport { Rule } from \"../../grammar/gast/gast_public\"\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n  isBackTrackingStack\n  className: string\n  RULE_STACK: string[]\n  RULE_OCCURRENCE_STACK: number[]\n  definedRulesNames: string[]\n  tokensMap: { [fqn: string]: TokenType }\n  gastProductionsCache: Record<string, Rule>\n  shortRuleNameToFull: Record<string, string>\n  fullRuleNameToShort: Record<string, number>\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\n  ruleShortNameIdx: number\n  tokenMatcher: TokenMatcher\n\n  initRecognizerEngine(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig\n  ) {\n    this.className = classNameFromInstance(this)\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {}\n    this.fullRuleNameToShort = {}\n    this.ruleShortNameIdx = 256\n    this.tokenMatcher = tokenStructuredMatcherNoCategories\n\n    this.definedRulesNames = []\n    this.tokensMap = {}\n    this.isBackTrackingStack = []\n    this.RULE_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n    this.gastProductionsCache = {}\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n          \"\\tFor Further details.\"\n      )\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary as any[])) {\n        throw Error(\n          \"A Token Vocabulary cannot be empty.\\n\" +\n            \"\\tNote that the first argument for the parser constructor\\n\" +\n            \"\\tis no longer a Token vector (since v4.0).\"\n        )\n      }\n\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\n        throw Error(\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n            \"\\tFor Further details.\"\n        )\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = <any>reduce(\n        <any>tokenVocabulary,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {}\n      )\n    } else if (\n      has(tokenVocabulary, \"modes\") &&\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\n    ) {\n      let allTokenTypes = flatten(values((<any>tokenVocabulary).modes))\n      let uniqueTokens = uniq(allTokenTypes)\n      this.tokensMap = <any>reduce(\n        uniqueTokens,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {}\n      )\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = cloneObj(tokenVocabulary)\n    } else {\n      throw new Error(\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\"\n      )\n    }\n\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    /* tslint:disable */\n    this.tokensMap[\"EOF\"] = EOF\n\n    // TODO: This check may not be accurate for multi mode lexers\n    const noTokenCategoriesUsed = every(\n      values(tokenVocabulary),\n      (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches)\n    )\n\n    this.tokenMatcher = noTokenCategoriesUsed\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap))\n  }\n\n  defineRule<T>(\n    this: MixedInParser,\n    ruleName: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T>\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    if (this.selfAnalysisDone) {\n      throw Error(\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`\n      )\n    }\n    let resyncEnabled = has(config, \"resyncEnabled\")\n      ? config.resyncEnabled\n      : DEFAULT_RULE_CONFIG.resyncEnabled\n    let recoveryValueFunc = has(config, \"recoveryValueFunc\")\n      ? config.recoveryValueFunc\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc\n\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    /* tslint:disable */\n    let shortName =\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n    /* tslint:enable */\n\n    this.ruleShortNameIdx++\n    this.shortRuleNameToFull[shortName] = ruleName\n    this.fullRuleNameToShort[ruleName] = shortName\n\n    function invokeRuleWithTry(args: any[]) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args)\n          const cst = this.CST_STACK[this.CST_STACK.length - 1]\n          this.cstPostRule(cst)\n          return cst\n        } else {\n          return impl.apply(this, args)\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n      } finally {\n        this.ruleFinallyStateUpdate()\n      }\n    }\n\n    let wrappedGrammarRule\n\n    wrappedGrammarRule = function (idxInCallingRule: number = 0, args: any[]) {\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule)\n      return invokeRuleWithTry.call(this, args)\n    }\n\n    let ruleNamePropName = \"ruleName\"\n    wrappedGrammarRule[ruleNamePropName] = ruleName\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl\n    return wrappedGrammarRule\n  }\n\n  invokeRuleCatch(\n    this: MixedInParser,\n    e: Error,\n    resyncEnabledConfig: boolean,\n    recoveryValueFunc: Function\n  ): void {\n    let isFirstInvokedRule = this.RULE_STACK.length === 1\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    let reSyncEnabled =\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n\n    if (isRecognitionException(e)) {\n      const recogError: any = e\n      if (reSyncEnabled) {\n        let reSyncTokType = this.findReSyncTokenType()\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n          if (this.outputCst) {\n            let partialCstResult: any = this.CST_STACK[\n              this.CST_STACK.length - 1\n            ]\n            partialCstResult.recoveredNode = true\n            return partialCstResult\n          } else {\n            return recoveryValueFunc()\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult: any = this.CST_STACK[\n              this.CST_STACK.length - 1\n            ]\n            partialCstResult.recoveredNode = true\n            recogError.partialCstResult = partialCstResult\n          }\n          // to be handled Further up the call stack\n          throw recogError\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState()\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc()\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternal<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    let key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n  }\n\n  optionInternalLogic<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n    key: number\n  ): OUT {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n    let action\n    let predicate\n    if ((<DSLMethodOpts<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOpts<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOpts<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        let orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this)\n    }\n    return undefined\n  }\n\n  atLeastOneInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    let laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_IDX,\n      prodOccurrence\n    )\n    return this.atLeastOneInternalLogic(\n      prodOccurrence,\n      actionORMethodDef,\n      laKey\n    )\n  }\n\n  atLeastOneInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n    key: number\n  ): void {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n\n    let action\n    let predicate\n    if ((<DSLMethodOptsWithErr<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        let orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if ((<Function>lookAheadFunc).call(this) === true) {\n      let notStuck = this.doSingleRepetition(action)\n      while (\n        (<Function>lookAheadFunc).call(this) === true &&\n        notStuck === true\n      ) {\n        notStuck = this.doSingleRepetition(action)\n      }\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY,\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG\n      )\n    }\n\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.atLeastOneInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookAheadFunc,\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n      NextTerminalAfterAtLeastOneWalker\n    )\n  }\n\n  atLeastOneSepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    let laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence\n    )\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  atLeastOneSepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n    key: number\n  ): void {\n    let action = options.DEF\n    let separator = options.SEP\n\n    let firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;(<GrammarAction<OUT>>action).call(this)\n\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      let separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        ;(<GrammarAction<OUT>>action).call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterAtLeastOneSepWalker\n        ],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneSepWalker\n      )\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        options.ERR_MSG\n      )\n    }\n  }\n\n  manyInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    let laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n  }\n\n  manyInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    key: number\n  ) {\n    let lookaheadFunction = this.getLaFuncFromCache(key)\n\n    let action\n    let predicate\n    if ((<DSLMethodOpts<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOpts<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOpts<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        let orgLookaheadFunction = lookaheadFunction\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    let notStuck = true\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action)\n    }\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    )\n  }\n\n  manySepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    let laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  manySepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n    key: number\n  ): void {\n    let action = options.DEF\n    let separator = options.SEP\n    let firstIterationLaFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this)\n\n      let separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterManySepWalker\n        ],\n        separatorLookAheadFunc,\n        MANY_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterManySepWalker\n      )\n    }\n  }\n\n  repetitionSepSecondInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    separator: TokenType,\n    separatorLookAheadFunc: () => boolean,\n    action: GrammarAction<OUT>,\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker\n  ): void {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator)\n      action.call(this)\n    }\n\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(\n      this.repetitionSepSecondInternal,\n      [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        nextTerminalAfterWalker\n      ],\n      separatorLookAheadFunc,\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n      nextTerminalAfterWalker\n    )\n  }\n\n  doSingleRepetition(this: MixedInParser, action: Function): any {\n    const beforeIteration = this.getLexerPosition()\n    action.call(this)\n    const afterIteration = this.getLexerPosition()\n\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration\n  }\n\n  orInternal<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    let laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n    let alts = isArray(altsOrOpts)\n      ? (altsOrOpts as IOrAlt<any>[])\n      : (altsOrOpts as OrMethodOpts<unknown>).DEF\n\n    const laFunc = this.getLaFuncFromCache(laKey)\n    let altIdxToTake = laFunc.call(this, alts)\n    if (altIdxToTake !== undefined) {\n      let chosenAlternative: any = alts[altIdxToTake]\n      return chosenAlternative.ALT.call(this)\n    }\n    this.raiseNoAltException(\n      occurrence,\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG\n    )\n  }\n\n  ruleFinallyStateUpdate(this: MixedInParser): void {\n    this.RULE_STACK.pop()\n    this.RULE_OCCURRENCE_STACK.pop()\n\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate()\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      let firstRedundantTok = this.LA(1)\n      let errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      })\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n    }\n  }\n\n  subruleInternal<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    idx: number,\n    options?: SubruleMethodOpts\n  ) {\n    let ruleResult\n    try {\n      const args = options !== undefined ? options.ARGS : undefined\n      ruleResult = ruleToCall.call(this, idx, args)\n      this.cstPostNonTerminal(\n        ruleResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : (<any>ruleToCall).ruleName\n      )\n      return ruleResult\n    } catch (e) {\n      this.subruleInternalError(e, options, (<any>ruleToCall).ruleName)\n    }\n  }\n\n  subruleInternalError(\n    this: MixedInParser,\n    e: any,\n    options: SubruleMethodOpts,\n    ruleName: string\n  ): void {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(\n        e.partialCstResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleName\n      )\n\n      delete e.partialCstResult\n    }\n    throw e\n  }\n\n  consumeInternal(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    options: ConsumeMethodOpts\n  ): IToken {\n    let consumedToken\n    try {\n      let nextToken = this.LA(1)\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken()\n        consumedToken = nextToken\n      } else {\n        this.consumeInternalError(tokType, nextToken, options)\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(\n        tokType,\n        idx,\n        eFromConsumption\n      )\n    }\n\n    this.cstPostTerminal(\n      options !== undefined && options.LABEL !== undefined\n        ? options.LABEL\n        : tokType.name,\n      consumedToken\n    )\n    return consumedToken\n  }\n\n  consumeInternalError(\n    this: MixedInParser,\n    tokType: TokenType,\n    nextToken: IToken,\n    options: ConsumeMethodOpts\n  ): void {\n    let msg\n    let previousToken = this.LA(0)\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n    }\n    throw this.SAVE_ERROR(\n      new MismatchedTokenException(msg, nextToken, previousToken)\n    )\n  }\n\n  consumeInternalRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    eFromConsumption: Error\n  ): IToken {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (\n      this.recoveryEnabled &&\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n      eFromConsumption.name === \"MismatchedTokenException\" &&\n      !this.isBackTracking()\n    ) {\n      let follows = this.getFollowsForInRuleRecovery(<any>tokType, idx)\n      try {\n        return this.tryInRuleRecovery(<any>tokType, follows)\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption\n        } else {\n          throw eFromInRuleRecovery\n        }\n      }\n    } else {\n      throw eFromConsumption\n    }\n  }\n\n  saveRecogState(this: MixedInParser): IParserState {\n    // errors is a getter which will clone the errors array\n    let savedErrors = this.errors\n    let savedRuleStack = cloneArr(this.RULE_STACK)\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    }\n  }\n\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\n    this.errors = newState.errors\n    this.importLexerState(newState.lexerState)\n    this.RULE_STACK = newState.RULE_STACK\n  }\n\n  ruleInvocationStateUpdate(\n    this: MixedInParser,\n    shortName: string,\n    fullName: string,\n    idxInCallingRule: number\n  ): void {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n    this.RULE_STACK.push(shortName)\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName, shortName)\n  }\n\n  isBackTracking(this: MixedInParser): boolean {\n    return this.isBackTrackingStack.length !== 0\n  }\n\n  getCurrRuleFullName(this: MixedInParser): string {\n    let shortName = this.getLastExplicitRuleShortName()\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  shortRuleNameToFullName(this: MixedInParser, shortName: string) {\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  public isAtEndOfInput(this: MixedInParser): boolean {\n    return this.tokenMatcher(this.LA(1), EOF)\n  }\n\n  public reset(this: MixedInParser): void {\n    this.resetLexerState()\n\n    this.isBackTrackingStack = []\n    this.errors = []\n    this.RULE_STACK = []\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n  }\n}\n", "import {\n  IParserConfig,\n  IParserErrorMessageProvider,\n  IRecognitionException\n} from \"../../../../api\"\nimport {\n  EarlyExitException,\n  isRecognitionException,\n  NoViableAltException\n} from \"../../exceptions_public\"\nimport { cloneArr, has } from \"../../../utils/utils\"\nimport {\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n  _errors: IRecognitionException[]\n  errorMessageProvider: IParserErrorMessageProvider\n\n  initErrorHandler(config: IParserConfig) {\n    this._errors = []\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\n      ? config.errorMessageProvider\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider\n  }\n\n  SAVE_ERROR(\n    this: MixedInParser,\n    error: IRecognitionException\n  ): IRecognitionException {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n      }\n      this._errors.push(error)\n      return error\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\")\n    }\n  }\n\n  get errors(): IRecognitionException[] {\n    return cloneArr(this._errors)\n  }\n\n  set errors(newErrors: IRecognitionException[]) {\n    this._errors = newErrors\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(\n    this: MixedInParser,\n    occurrence: number,\n    prodType: PROD_TYPE,\n    userDefinedErrMsg: string\n  ): void {\n    let ruleName = this.getCurrRuleFullName()\n    let ruleGrammar = this.getGAstProductions()[ruleName]\n    let lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n      occurrence,\n      ruleGrammar,\n      prodType,\n      this.maxLookahead\n    )\n    let insideProdPaths = lookAheadPathsPerAlternative[0]\n    let actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    let msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    })\n\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(\n    this: MixedInParser,\n    occurrence: number,\n    errMsgTypes: string\n  ): void {\n    let ruleName = this.getCurrRuleFullName()\n    let ruleGrammar = this.getGAstProductions()[ruleName]\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    let lookAheadPathsPerAlternative = getLookaheadPathsForOr(\n      occurrence,\n      ruleGrammar,\n      this.maxLookahead\n    )\n\n    let actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    let previousToken = this.LA(0)\n\n    let errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    })\n\n    throw this.SAVE_ERROR(\n      new NoViableAltException(errMsg, this.LA(1), previousToken)\n    )\n  }\n}\n", "import {\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"../../../../api\"\nimport {\n  NextAfterTokenWalker,\n  nextPossibleTokensAfter\n} from \"../../grammar/interpreter\"\nimport { first, isUndefined } from \"../../../utils/utils\"\nimport { MixedInParser } from \"./parser_traits\"\n\nexport class ContentAssist {\n  initContentAssist() {}\n\n  public computeContentAssist(\n    this: MixedInParser,\n    startRuleName: string,\n    precedingInput: IToken[]\n  ): ISyntacticContentAssistPath[] {\n    let startRuleGast = this.gastProductionsCache[startRuleName]\n\n    if (isUndefined(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`)\n    }\n\n    return nextPossibleTokensAfter(\n      [startRuleGast],\n      precedingInput,\n      this.tokenMatcher,\n      this.maxLookahead\n    )\n  }\n\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  public getNextPossibleTokenTypes(\n    this: MixedInParser,\n    grammarPath: ITokenGrammarPath\n  ): TokenType[] {\n    let topRuleName = first(grammarPath.ruleStack)\n    let gastProductions = this.getGAstProductions()\n    let topProduction = gastProductions[topRuleName]\n    let nextPossibleTokenTypes = new NextAfterTokenWalker(\n      topProduction,\n      grammarPath\n    ).startWalking()\n    return nextPossibleTokenTypes\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  CstNode,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IProduction,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"../../../../api\"\nimport {\n  forEach,\n  has,\n  isArray,\n  isFunction,\n  peek,\n  some\n} from \"../../../utils/utils\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"../../grammar/gast/gast_public\"\nimport { Lexer } from \"../../../scan/lexer_public\"\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\"\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\"\nimport { END_OF_FILE } from \"../parser\"\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\"\n\ntype ProdWithDef = IProduction & { definition?: IProduction[] }\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n}\nObject.freeze(RECORDING_NULL_OBJECT)\n\nconst HANDLE_SEPARATOR = true\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA })\naugmentTokenTypes([RFT])\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n)\nObject.freeze(RECORDING_PHASE_TOKEN)\n\nconst RECORDING_PHASE_CSTNODE: CstNode = {\n  name:\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n}\n\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n  recordingProdStack: ProdWithDef[]\n  RECORDING_PHASE: boolean\n\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\n    this.recordingProdStack = []\n    this.RECORDING_PHASE = false\n  }\n\n  enableRecording(this: MixedInParser): void {\n    this.RECORDING_PHASE = true\n\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        this[`CONSUME${idx}`] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2)\n        }\n        this[`SUBRULE${idx}`] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2)\n        }\n        this[`OPTION${idx}`] = function (arg1) {\n          return this.optionInternalRecord(arg1, i)\n        }\n        this[`OR${idx}`] = function (arg1) {\n          return this.orInternalRecord(arg1, i)\n        }\n        this[`MANY${idx}`] = function (arg1) {\n          this.manyInternalRecord(i, arg1)\n        }\n        this[`MANY_SEP${idx}`] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1)\n        }\n      }\n\n      // DSL methods with the idx(suffix) as an argument\n      this[`consume`] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2)\n      }\n      this[`subrule`] = <any>function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2)\n      }\n      this[`option`] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx)\n      }\n      this[`or`] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx)\n      }\n      this[`many`] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1)\n      }\n      this[`atLeastOne`] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1)\n      }\n\n      this.ACTION = this.ACTION_RECORD\n      this.BACKTRACK = this.BACKTRACK_RECORD\n      this.LA = this.LA_RECORD\n    })\n  }\n\n  disableRecording(this: MixedInParser) {\n    this.RECORDING_PHASE = false\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        delete this[`CONSUME${idx}`]\n        delete this[`SUBRULE${idx}`]\n        delete this[`OPTION${idx}`]\n        delete this[`OR${idx}`]\n        delete this[`MANY${idx}`]\n        delete this[`MANY_SEP${idx}`]\n        delete this[`AT_LEAST_ONE${idx}`]\n        delete this[`AT_LEAST_ONE_SEP${idx}`]\n      }\n\n      delete this[`consume`]\n      delete this[`subrule`]\n      delete this[`option`]\n      delete this[`or`]\n      delete this[`many`]\n      delete this[`atLeastOne`]\n\n      delete this.ACTION\n      delete this.BACKTRACK\n      delete this.LA\n    })\n  }\n\n  // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\n    // NO-OP during recording\n    return\n  }\n\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD<T>(\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return () => true\n  }\n\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch: number): IToken {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE\n  }\n\n  topLevelRuleRecord(name: string, def: Function): Rule {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name: name })\n      newTopLevelRule.name = name\n      this.recordingProdStack.push(newTopLevelRule)\n      def.call(this)\n      this.recordingProdStack.pop()\n      return newTopLevelRule\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message =\n            originalError.message +\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\"\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError\n        }\n      }\n      throw originalError\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternalRecord<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneSepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionMandatoryWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  manyInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n  }\n\n  manySepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  orInternalRecord<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    return recordOrProd.call(this, altsOrOpts, occurrence)\n  }\n\n  subruleInternalRecord<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    occurrence: number,\n    options?: SubruleMethodOpts\n  ): T | CstNode {\n    assertMethodIdxIsValid(occurrence)\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error: any = new Error(\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a Parser method reference but got: <${JSON.stringify(\n            ruleToCall\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n\n    const prevProd: any = peek(this.recordingProdStack)\n    const ruleName = ruleToCall[\"ruleName\"]\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : <any>RECORDING_NULL_OBJECT\n  }\n\n  consumeInternalRecord(\n    this: MixedInParser,\n    tokType: TokenType,\n    occurrence: number,\n    options: ConsumeMethodOpts\n  ): IToken {\n    assertMethodIdxIsValid(occurrence)\n    if (!hasShortKeyProperty(tokType)) {\n      const error: any = new Error(\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a TokenType reference but got: <${JSON.stringify(\n            tokType\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n    const prevProd: any = peek(this.recordingProdStack)\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return RECORDING_PHASE_TOKEN\n  }\n}\n\nfunction recordProd(\n  prodConstructor: any,\n  mainProdArg: any,\n  occurrence: number,\n  handleSep: boolean = false\n): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n\n  const newProd = new prodConstructor({ definition: [], idx: occurrence })\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  this.recordingProdStack.push(newProd)\n  grammarAction.call(this)\n  prevProd.definition.push(newProd)\n  this.recordingProdStack.pop()\n\n  return RECORDING_NULL_OBJECT\n}\n\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  // Only an array of alternatives\n  const hasOptions = isArray(mainProdArg) === false\n  const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF\n\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  })\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE))\n  newOrProd.hasPredicates = hasPredicates\n\n  prevProd.definition.push(newOrProd)\n\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] })\n    newOrProd.definition.push(currAltFlat)\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true\n    }\n    this.recordingProdStack.push(currAltFlat)\n    currAlt.ALT.call(this)\n    this.recordingProdStack.pop()\n  })\n  return RECORDING_NULL_OBJECT\n}\n\nfunction getIdxSuffix(idx: number): string {\n  return idx === 0 ? \"\" : `${idx}`\n}\n\nfunction assertMethodIdxIsValid(idx): void {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error: any = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n        `Idx value must be a none negative value smaller than ${\n          MAX_METHOD_IDX + 1\n        }`\n    )\n    error.KNOWN_RECORDER_ERROR = true\n    throw error\n  }\n}\n", "import { IParserConfig } from \"../../../../api\"\nimport { has, timer } from \"../../../utils/utils\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n  traceInitPerf: boolean | number\n  traceInitMaxIdent: number\n  traceInitIndent: number\n\n  initPerformanceTracer(config: IParserConfig) {\n    if (has(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf\n      const traceIsNumber = typeof userTraceInitPerf === \"number\"\n      this.traceInitMaxIdent = traceIsNumber\n        ? <number>userTraceInitPerf\n        : Infinity\n      this.traceInitPerf = traceIsNumber\n        ? userTraceInitPerf > 0\n        : userTraceInitPerf\n    } else {\n      this.traceInitMaxIdent = 0\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf\n    }\n\n    this.traceInitIndent = -1\n  }\n\n  TRACE_INIT<T>(this: MixedInParser, phaseDesc: string, phaseImpl: () => T): T {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n", "import {\n  applyMixins,\n  cloneObj,\n  forEach,\n  has,\n  isEmpty,\n  map,\n  toFastProperties,\n  values\n} from \"../../utils/utils\"\nimport { computeAllProdsFollows } from \"../grammar/follow\"\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public\"\nimport {\n  defaultGrammarValidatorErrorProvider,\n  defaultParserErrorProvider\n} from \"../errors_public\"\nimport {\n  resolveGrammar,\n  validateGrammar\n} from \"../grammar/gast/gast_resolver_public\"\nimport {\n  CstNode,\n  IParserConfig,\n  IParserDefinitionError,\n  IRecognitionException,\n  IRuleConfig,\n  IToken,\n  TokenType,\n  TokenVocabulary\n} from \"../../../api\"\nimport { Recoverable } from \"./traits/recoverable\"\nimport { LooksAhead } from \"./traits/looksahead\"\nimport { TreeBuilder } from \"./traits/tree_builder\"\nimport { LexerAdapter } from \"./traits/lexer_adapter\"\nimport { RecognizerApi } from \"./traits/recognizer_api\"\nimport { RecognizerEngine } from \"./traits/recognizer_engine\"\n\nimport { ErrorHandler } from \"./traits/error_handler\"\nimport { MixedInParser } from \"./traits/parser_traits\"\nimport { ContentAssist } from \"./traits/context_assist\"\nimport { GastRecorder } from \"./traits/gast_recorder\"\nimport { PerformanceTracer } from \"./traits/perf_tracer\"\n\nexport const END_OF_FILE = createTokenInstance(\n  EOF,\n  \"\",\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN\n)\nObject.freeze(END_OF_FILE)\n\nexport type TokenMatcher = (token: IToken, tokType: TokenType) => boolean\n\nexport type lookAheadSequence = TokenType[][]\n\nexport const DEFAULT_PARSER_CONFIG: IParserConfig = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n})\n\nexport const DEFAULT_RULE_CONFIG: IRuleConfig<any> = Object.freeze({\n  recoveryValueFunc: () => undefined,\n  resyncEnabled: true\n})\n\nexport enum ParserDefinitionErrorType {\n  INVALID_RULE_NAME = 0,\n  DUPLICATE_RULE_NAME = 1,\n  INVALID_RULE_OVERRIDE = 2,\n  DUPLICATE_PRODUCTIONS = 3,\n  UNRESOLVED_SUBRULE_REF = 4,\n  LEFT_RECURSION = 5,\n  NONE_LAST_EMPTY_ALT = 6,\n  AMBIGUOUS_ALTS = 7,\n  CONFLICT_TOKENS_RULES_NAMESPACE = 8,\n  INVALID_TOKEN_NAME = 9,\n  NO_NON_EMPTY_LOOKAHEAD = 10,\n  AMBIGUOUS_PREFIX_ALTS = 11,\n  TOO_MANY_ALTS = 12\n}\n\nexport interface IParserDuplicatesDefinitionError\n  extends IParserDefinitionError {\n  dslName: string\n  occurrence: number\n  parameter?: string\n}\n\nexport interface IParserEmptyAlternativeDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number\n  alternative: number\n}\n\nexport interface IParserAmbiguousAlternativesDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number\n  alternatives: number[]\n}\n\nexport interface IParserUnresolvedRefDefinitionError\n  extends IParserDefinitionError {\n  unresolvedRefName: string\n}\n\nexport interface IParserState {\n  errors: IRecognitionException[]\n  lexerState: any\n  RULE_STACK: string[]\n  CST_STACK: CstNode[]\n}\n\nexport type Predicate = () => boolean\n\nexport function EMPTY_ALT<T>(value: T = undefined): () => T {\n  return function () {\n    return value\n  }\n}\n\nexport class Parser {\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  static DEFER_DEFINITION_ERRORS_HANDLING: boolean = false\n\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance: Parser): void {\n    throw Error(\n      \"The **static** `performSelfAnalysis` method has been deprecated.\" +\n        \"\\t\\nUse the **instance** method with the same name instead.\"\n    )\n  }\n\n  public performSelfAnalysis(this: MixedInParser): void {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs\n\n      this.selfAnalysisDone = true\n      let className = this.className\n\n      this.TRACE_INIT(\"toFastProps\", () => {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        toFastProperties(this)\n      })\n\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording()\n          // Building the GAST\n          forEach(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = this[currRuleName]\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"]\n            let recordedRuleGast = undefined\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(\n                currRuleName,\n                originalGrammarAction\n              )\n            })\n            this.gastProductionsCache[currRuleName] = recordedRuleGast\n          })\n        } finally {\n          this.disableRecording()\n        }\n      })\n\n      let resolverErrors = []\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar({\n          rules: values(this.gastProductionsCache)\n        })\n        this.definitionErrors.push.apply(this.definitionErrors, resolverErrors) // mutability for the win?\n      })\n\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\n          let validationErrors = validateGrammar({\n            rules: values(this.gastProductionsCache),\n            maxLookahead: this.maxLookahead,\n            tokenTypes: values(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          })\n\n          this.definitionErrors.push.apply(\n            this.definitionErrors,\n            validationErrors\n          ) // mutability for the win?\n        }\n      })\n\n      // this analysis may fail if the grammar is not perfectly valid\n      if (isEmpty(this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            let allFollows = computeAllProdsFollows(\n              values(this.gastProductionsCache)\n            )\n            this.resyncFollows = allFollows\n          })\n        }\n\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache))\n        })\n      }\n\n      if (\n        !Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n        !isEmpty(this.definitionErrors)\n      ) {\n        defErrorsMsgs = map(\n          this.definitionErrors,\n          (defError) => defError.message\n        )\n        throw new Error(\n          `Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\n            \"\\n-------------------------------\\n\"\n          )}`\n        )\n      }\n    })\n  }\n\n  definitionErrors: IParserDefinitionError[] = []\n  selfAnalysisDone = false\n  protected skipValidations: boolean\n\n  constructor(tokenVocabulary: TokenVocabulary, config: IParserConfig) {\n    const that: MixedInParser = this as any\n    that.initErrorHandler(config)\n    that.initLexerAdapter()\n    that.initLooksAhead(config)\n    that.initRecognizerEngine(tokenVocabulary, config)\n    that.initRecoverable(config)\n    that.initTreeBuilder(config)\n    that.initContentAssist()\n    that.initGastRecorder(config)\n    that.initPerformanceTracer(config)\n\n    if (has(config, \"ignoredIssues\")) {\n      throw new Error(\n        \"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n          \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n          \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n          \"For further details.\"\n      )\n    }\n\n    this.skipValidations = has(config, \"skipValidations\")\n      ? config.skipValidations\n      : DEFAULT_PARSER_CONFIG.skipValidations\n  }\n}\n\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer\n])\n\nexport class CstParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = cloneObj(config)\n    configClone.outputCst = true\n    super(tokenVocabulary, configClone)\n  }\n}\n\nexport class EmbeddedActionsParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = cloneObj(config)\n    configClone.outputCst = false\n    super(tokenVocabulary, configClone)\n  }\n}\n", "import { VERSION } from \"../version\"\nimport { ISerializedGast } from \"../../api\"\n\nexport function createSyntaxDiagramsCode(\n  grammar: ISerializedGast[],\n  {\n    resourceBase = `https://unpkg.com/chevrotain@${VERSION}/diagrams/`,\n    css = `https://unpkg.com/chevrotain@${VERSION}/diagrams/diagrams.css`\n  }: {\n    resourceBase?: string\n    css?: string\n  } = {}\n) {\n  const header = `\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n`\n  const cssHtml = `\n<link rel='stylesheet' href='${css}'>\n`\n\n  const scripts = `\n<script src='${resourceBase}vendor/railroad-diagrams.js'></script>\n<script src='${resourceBase}src/diagrams_builder.js'></script>\n<script src='${resourceBase}src/diagrams_behavior.js'></script>\n<script src='${resourceBase}src/main.js'></script>\n`\n  const diagramsDiv = `\n<div id=\"diagrams\" align=\"center\"></div>    \n`\n  const serializedGrammar = `\n<script>\n    window.serializedGrammar = ${JSON.stringify(grammar, null, \"  \")};\n</script>\n`\n\n  const initLogic = `\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n`\n  return (\n    header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic\n  )\n}\n", "import { forEach, map } from \"../utils/utils\"\nimport {\n  RepetitionMandatory,\n  Option,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal,\n  NonTerminal,\n  Alternation,\n  Alternative,\n  Repetition\n} from \"../parse/grammar/gast/gast_public\"\nimport { IProduction, TokenType, Rule } from \"../../api\"\n\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\n\nconst NL = \"\\n\"\n\nexport function genUmdModule(options: { name: string; rules: Rule[] }): string {\n  return `\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n${genClass(options)}\n    \nreturn {\n    ${options.name}: ${options.name} \n}\n}));\n`\n}\n\nexport function genWrapperFunction(options: {\n  name: string\n  rules: Rule[]\n}): string {\n  return `    \n${genClass(options)}\nreturn new ${options.name}(tokenVocabulary, config)    \n`\n}\n\nexport function genClass(options: { name: string; rules: Rule[] }): string {\n  // TODO: how to pass the token vocabulary? Constructor? other?\n  let result = `\nfunction ${options.name}(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    ${genAllRules(options.rules)}\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n${options.name}.prototype = Object.create(chevrotain.CstParser.prototype)\n${options.name}.prototype.constructor = ${options.name}    \n    `\n\n  return result\n}\n\nexport function genAllRules(rules: Rule[]): string {\n  let rulesText = map(rules, (currRule) => {\n    return genRule(currRule, 1)\n  })\n\n  return rulesText.join(\"\\n\")\n}\n\nexport function genRule(prod: Rule, n: number): string {\n  let result = indent(n, `$.RULE(\"${prod.name}\", function() {`) + NL\n  result += genDefinition(prod.definition, n + 1)\n  result += indent(n + 1, `})`) + NL\n  return result\n}\n\nexport function genTerminal(prod: Terminal, n: number): string {\n  const name = prod.terminalType.name\n  // TODO: potential performance optimization, avoid tokenMap Dictionary access\n  return indent(n, `$.CONSUME${prod.idx}(this.tokensMap.${name})` + NL)\n}\n\nexport function genNonTerminal(prod: NonTerminal, n: number): string {\n  return indent(n, `$.SUBRULE${prod.idx}($.${prod.nonTerminalName})` + NL)\n}\n\nexport function genAlternation(prod: Alternation, n: number): string {\n  let result = indent(n, `$.OR${prod.idx}([`) + NL\n  const alts = map(prod.definition, (altDef) => genSingleAlt(altDef, n + 1))\n  result += alts.join(\",\" + NL)\n  result += NL + indent(n, `])` + NL)\n  return result\n}\n\nexport function genSingleAlt(prod: Alternative, n: number): string {\n  let result = indent(n, `{`) + NL\n\n  result += indent(n + 1, \"ALT: function() {\") + NL\n  result += genDefinition(prod.definition, n + 1)\n  result += indent(n + 1, `}`) + NL\n  result += indent(n, `}`)\n\n  return result\n}\n\nfunction genProd(prod: IProduction, n: number): string {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return genNonTerminal(prod, n)\n  } else if (prod instanceof Option) {\n    return genDSLRule(\"OPTION\", prod, n)\n  } else if (prod instanceof RepetitionMandatory) {\n    return genDSLRule(\"AT_LEAST_ONE\", prod, n)\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n)\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return genDSLRule(\"MANY_SEP\", prod, n)\n  } else if (prod instanceof Repetition) {\n    return genDSLRule(\"MANY\", prod, n)\n  } else if (prod instanceof Alternation) {\n    return genAlternation(prod, n)\n  } else if (prod instanceof Terminal) {\n    return genTerminal(prod, n)\n  } else if (prod instanceof Alternative) {\n    return genDefinition(prod.definition, n)\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction genDSLRule(\n  dslName,\n  prod: {\n    definition: IProduction[]\n    idx: number\n    separator?: TokenType\n  },\n  n: number\n): string {\n  let result = indent(n, `$.${dslName + prod.idx}(`)\n\n  if (prod.separator) {\n    result += \"{\" + NL\n    result +=\n      indent(n + 1, `SEP: this.tokensMap.${prod.separator.name}`) + \",\" + NL\n    result += `DEF: ${genDefFunction(prod.definition, n + 2)}` + NL\n    result += indent(n, \"}\") + NL\n  } else {\n    result += genDefFunction(prod.definition, n + 1)\n  }\n\n  result += indent(n, `)`) + NL\n  return result\n}\n\nfunction genDefFunction(definition: IProduction[], n: number): string {\n  let def = \"function() {\" + NL\n  def += genDefinition(definition, n)\n  def += indent(n, `}`) + NL\n  return def\n}\n\nfunction genDefinition(def: IProduction[], n: number): string {\n  let result = \"\"\n  forEach(def, (prod) => {\n    result += genProd(prod, n + 1)\n  })\n  return result\n}\n\nfunction indent(howMuch: number, text: string): string {\n  const spaces = Array(howMuch * 4 + 1).join(\" \")\n  return spaces + text\n}\n", "import { Rule, IParserConfig, TokenVocabulary, BaseParser } from \"../../api\"\nimport { genUmdModule, genWrapperFunction } from \"./generate\"\n\nexport function generateParserFactory<T extends BaseParser>(options: {\n  name: string\n  rules: Rule[]\n  tokenVocabulary: TokenVocabulary\n}): (config?: IParserConfig) => T {\n  const wrapperText = genWrapperFunction({\n    name: options.name,\n    rules: options.rules\n  })\n\n  const constructorWrapper = new Function(\n    \"tokenVocabulary\",\n    \"config\",\n    \"chevrotain\",\n    wrapperText\n  )\n\n  return function (config) {\n    return constructorWrapper(\n      options.tokenVocabulary,\n      config,\n      // TODO: check how the require is transpiled/webpacked\n      require(\"../api\")\n    )\n  }\n}\n\nexport function generateParserModule(options: {\n  name: string\n  rules: Rule[]\n}): string {\n  return genUmdModule({ name: options.name, rules: options.rules })\n}\n", "/* istanbul ignore file - tricky to import some things from this module during testing */\n\n// semantic version\nexport { VERSION } from \"./version\"\n\nexport {\n  CstParser,\n  EmbeddedActionsParser,\n  ParserDefinitionErrorType,\n  EMPTY_ALT\n} from \"./parse/parser/parser\"\n\nexport { Lexer, LexerDefinitionErrorType } from \"./scan/lexer_public\"\n\n// Tokens utilities\n\nexport {\n  createToken,\n  createTokenInstance,\n  EOF,\n  tokenLabel,\n  tokenMatcher,\n  tokenName\n} from \"./scan/tokens_public\"\n\n// Other Utilities\n\nexport {\n  defaultGrammarResolverErrorProvider,\n  defaultGrammarValidatorErrorProvider,\n  defaultParserErrorProvider\n} from \"./parse/errors_public\"\n\nexport {\n  EarlyExitException,\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException,\n  NoViableAltException\n} from \"./parse/exceptions_public\"\n\nexport { defaultLexerErrorProvider } from \"./scan/lexer_errors_public\"\n\n// grammar reflection API\n\nexport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./parse/grammar/gast/gast_public\"\n\n// GAST Utilities\n\nexport {\n  serializeGrammar,\n  serializeProduction\n} from \"./parse/grammar/gast/gast_public\"\n\nexport { GAstVisitor } from \"./parse/grammar/gast/gast_visitor_public\"\n\nexport {\n  assignOccurrenceIndices,\n  resolveGrammar,\n  validateGrammar\n} from \"./parse/grammar/gast/gast_resolver_public\"\n\n/* istanbul ignore next */\nexport function clearCache() {\n  console.warn(\n    \"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n      \"\\n\\t It performs no action other than printing this message.\" +\n      \"\\n\\t Please avoid using it as it will be completely removed in the future\"\n  )\n}\n\nexport { createSyntaxDiagramsCode } from \"./diagrams/render_public\"\n\nexport {\n  generateParserFactory,\n  generateParserModule\n} from \"./generate/generate_public\"\n\nexport class Parser {\n  constructor() {\n    throw new Error(\n      \"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n\" +\n        \"See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0\"\n    )\n  }\n}\n", "const {createToken, Lexer} = require('chevrotain');\r\nconst FormulaError = require('../formulas/error')\r\n\r\n// the vocabulary will be exported and used in the Parser definition.\r\nconst tokenVocabulary = {};\r\n\r\nconst WhiteSpace = createToken({\r\n    name: 'WhiteSpace',\r\n    pattern: /\\s+/,\r\n    group: Lexer.SKIPPED,\r\n});\r\n\r\nconst String = createToken({\r\n    name: 'String',\r\n    pattern: /\"(\"\"|[^\"])*\"/\r\n});\r\n\r\nconst SingleQuotedString = createToken({\r\n    name: 'SingleQuotedString',\r\n    pattern: /'(''|[^'])*'/\r\n});\r\n\r\nconst SheetQuoted = createToken({\r\n    name: 'SheetQuoted',\r\n    pattern: /'((?![\\\\\\/\\[\\]*?:]).)+?'!/\r\n});\r\n\r\nconst Function = createToken({\r\n    name: 'Function',\r\n    pattern: /[A-Za-z_]+[A-Za-z_0-9.]*\\(/\r\n});\r\n\r\nconst FormulaErrorT = createToken({\r\n    name: 'FormulaErrorT',\r\n    pattern: /#NULL!|#DIV\\/0!|#VALUE!|#NAME\\?|#NUM!|#N\\/A/\r\n});\r\n\r\nconst RefError = createToken({\r\n    name: 'RefError',\r\n    pattern: /#REF!/\r\n});\r\n\r\nconst Name = createToken({\r\n    name: 'Name',\r\n    pattern: /[a-zA-Z_][a-zA-Z0-9_.?]*/,\r\n    // longer_alt: RangeColumn // e.g. A:AA\r\n});\r\n\r\nconst Sheet = createToken({\r\n    name: 'Sheet',\r\n    pattern: /[A-Za-z_.\\d\\u007F-\\uFFFF]+!/\r\n});\r\n\r\nconst Cell = createToken({\r\n    name: 'Cell',\r\n    pattern: /[$]?[A-Za-z]{1,3}[$]?[1-9][0-9]*/,\r\n    longer_alt: Name\r\n});\r\n\r\nconst Number = createToken({\r\n    name: 'Number',\r\n    pattern: /[0-9]+[.]?[0-9]*([eE][+\\-][0-9]+)?/\r\n});\r\n\r\nconst Boolean = createToken({\r\n    name: 'Boolean',\r\n    pattern: /TRUE|FALSE/i\r\n});\r\n\r\nconst Column = createToken({\r\n    name: 'Column',\r\n    pattern: /[$]?[A-Za-z]{1,3}/,\r\n    longer_alt: Name\r\n});\r\n\r\n\r\n/**\r\n * Symbols and operators\r\n */\r\nconst At = createToken({\r\n    name: 'At',\r\n    pattern: /@/\r\n});\r\n\r\nconst Comma = createToken({\r\n    name: 'Comma',\r\n    pattern: /,/\r\n});\r\n\r\nconst Colon = createToken({\r\n    name: 'Colon',\r\n    pattern: /:/\r\n});\r\n\r\nconst Semicolon = createToken({\r\n    name: 'Semicolon',\r\n    pattern: /;/\r\n});\r\n\r\nconst OpenParen = createToken({\r\n    name: 'OpenParen',\r\n    pattern: /\\(/\r\n});\r\n\r\nconst CloseParen = createToken({\r\n    name: 'CloseParen',\r\n    pattern: /\\)/\r\n});\r\n\r\nconst OpenSquareParen = createToken({\r\n    name: 'OpenSquareParen',\r\n    pattern: /\\[/\r\n});\r\n\r\nconst CloseSquareParen = createToken({\r\n    name: 'CloseSquareParen',\r\n    pattern: /]/\r\n});\r\n\r\nconst ExclamationMark = createToken({\r\n    name: 'exclamationMark',\r\n    pattern: /!/\r\n});\r\n\r\nconst OpenCurlyParen = createToken({\r\n    name: 'OpenCurlyParen',\r\n    pattern: /{/\r\n});\r\n\r\nconst CloseCurlyParen = createToken({\r\n    name: 'CloseCurlyParen',\r\n    pattern: /}/\r\n});\r\n\r\nconst QuoteS = createToken({\r\n    name: 'QuoteS',\r\n    pattern: /'/\r\n});\r\n\r\n\r\nconst MulOp = createToken({\r\n    name: 'MulOp',\r\n    pattern: /\\*/\r\n});\r\n\r\nconst PlusOp = createToken({\r\n    name: 'PlusOp',\r\n    pattern: /\\+/\r\n});\r\n\r\nconst DivOp = createToken({\r\n    name: 'DivOp',\r\n    pattern: /\\//\r\n});\r\n\r\nconst MinOp = createToken({\r\n    name: 'MinOp',\r\n    pattern: /-/\r\n});\r\n\r\nconst ConcatOp = createToken({\r\n    name: 'ConcatOp',\r\n    pattern: /&/\r\n});\r\n\r\nconst ExOp = createToken({\r\n    name: 'ExOp',\r\n    pattern: /\\^/\r\n});\r\n\r\nconst PercentOp = createToken({\r\n    name: 'PercentOp',\r\n    pattern: /%/\r\n});\r\n\r\nconst GtOp = createToken({\r\n    name: 'GtOp',\r\n    pattern: />/\r\n});\r\n\r\nconst EqOp = createToken({\r\n    name: 'EqOp',\r\n    pattern: /=/\r\n});\r\n\r\nconst LtOp = createToken({\r\n    name: 'LtOp',\r\n    pattern: /</\r\n});\r\n\r\nconst NeqOp = createToken({\r\n    name: 'NeqOp',\r\n    pattern: /<>/\r\n});\r\n\r\nconst GteOp = createToken({\r\n    name: 'GteOp',\r\n    pattern: />=/\r\n});\r\n\r\nconst LteOp = createToken({\r\n    name: 'LteOp',\r\n    pattern: /<=/\r\n});\r\n\r\n// The order of tokens is important\r\nconst allTokens = [\r\n\r\n    WhiteSpace,\r\n    String,\r\n    SheetQuoted,\r\n    SingleQuotedString,\r\n    Function,\r\n    FormulaErrorT,\r\n    RefError,\r\n    Sheet,\r\n    Cell,\r\n    Boolean,\r\n    Column,\r\n    Name,\r\n    Number,\r\n\r\n    At,\r\n    Comma,\r\n    Colon,\r\n    Semicolon,\r\n    OpenParen,\r\n    CloseParen,\r\n    OpenSquareParen,\r\n    CloseSquareParen,\r\n    // ExclamationMark,\r\n    OpenCurlyParen,\r\n    CloseCurlyParen,\r\n    QuoteS,\r\n    MulOp,\r\n    PlusOp,\r\n    DivOp,\r\n    MinOp,\r\n    ConcatOp,\r\n    ExOp,\r\n    MulOp,\r\n    PercentOp,\r\n    NeqOp,\r\n    GteOp,\r\n    LteOp,\r\n    GtOp,\r\n    EqOp,\r\n    LtOp,\r\n];\r\n\r\nconst SelectLexer = new Lexer(allTokens, {ensureOptimizations: true});\r\n\r\nallTokens.forEach(tokenType => {\r\n    tokenVocabulary[tokenType.name] = tokenType\r\n});\r\n\r\nmodule.exports = {\r\n    tokenVocabulary: tokenVocabulary,\r\n\r\n    lex: function (inputText) {\r\n        const lexingResult = SelectLexer.tokenize(inputText)\r\n\r\n        if (lexingResult.errors.length > 0) {\r\n            const error = lexingResult.errors[0];\r\n            const line = error.line, column = error.column;\r\n            let msg = '\\n' + inputText.split('\\n')[line - 1] + '\\n';\r\n            msg += Array(column - 1).fill(' ').join('') + '^\\n';\r\n            error.message = msg + `Error at position ${line}:${column}\\n` + error.message;\r\n            error.errorLocation = {line, column};\r\n            throw FormulaError.ERROR(error.message, error);\r\n        }\r\n\r\n        return lexingResult\r\n    }\r\n};\r\n", "const lexer = require('./lexing');\r\nconst {EmbeddedActionsParser} = require(\"chevrotain\");\r\nconst tokenVocabulary = lexer.tokenVocabulary;\r\nconst {\r\n    String,\r\n    SheetQuoted,\r\n    ExcelRefFunction,\r\n    ExcelConditionalRefFunction,\r\n    Function,\r\n    FormulaErrorT,\r\n    RefError,\r\n    Cell,\r\n    Sheet,\r\n    Name,\r\n    Number,\r\n    Boolean,\r\n    Column,\r\n\r\n    // At,\r\n    Comma,\r\n    Colon,\r\n    Semicolon,\r\n    OpenParen,\r\n    CloseParen,\r\n    // OpenSquareParen,\r\n    // CloseSquareParen,\r\n    // ExclamationMark,\r\n    OpenCurlyParen,\r\n    CloseCurlyParen,\r\n    MulOp,\r\n    PlusOp,\r\n    DivOp,\r\n    MinOp,\r\n    ConcatOp,\r\n    ExOp,\r\n    PercentOp,\r\n    NeqOp,\r\n    GteOp,\r\n    LteOp,\r\n    GtOp,\r\n    EqOp,\r\n    LtOp\r\n} = lexer.tokenVocabulary;\r\n\r\nclass Parsing extends EmbeddedActionsParser {\r\n    /**\r\n     *\r\n     * @param {FormulaParser|DepParser} context\r\n     * @param {Utils} utils\r\n     */\r\n    constructor(context, utils) {\r\n        super(tokenVocabulary, {\r\n            outputCst: false,\r\n            maxLookahead: 1,\r\n            skipValidations: true,\r\n            // traceInitPerf: true,\r\n        });\r\n        this.utils = utils;\r\n        this.binaryOperatorsPrecedence = [\r\n            ['^'],\r\n            ['*', '/'],\r\n            ['+', '-'],\r\n            ['&'],\r\n            ['<', '>', '=', '<>', '<=', '>='],\r\n        ];\r\n        const $ = this;\r\n\r\n        // Adopted from https://github.com/spreadsheetlab/XLParser/blob/master/src/XLParser/ExcelFormulaGrammar.cs\r\n\r\n        $.RULE('formulaWithBinaryOp', () => {\r\n            const infixes = [];\r\n            const values = [$.SUBRULE($.formulaWithPercentOp)];\r\n            $.MANY(() => {\r\n                // Caching Arrays of Alternatives\r\n                // https://sap.github.io/chevrotain/docs/guide/performance.html#caching-arrays-of-alternatives\r\n                infixes.push($.OR($.c1 ||\r\n                    (\r\n                        $.c1 = [\r\n                            {ALT: () => $.CONSUME(GtOp).image},\r\n                            {ALT: () => $.CONSUME(EqOp).image},\r\n                            {ALT: () => $.CONSUME(LtOp).image},\r\n                            {ALT: () => $.CONSUME(NeqOp).image},\r\n                            {ALT: () => $.CONSUME(GteOp).image},\r\n                            {ALT: () => $.CONSUME(LteOp).image},\r\n                            {ALT: () => $.CONSUME(ConcatOp).image},\r\n                            {ALT: () => $.CONSUME(PlusOp).image},\r\n                            {ALT: () => $.CONSUME(MinOp).image},\r\n                            {ALT: () => $.CONSUME(MulOp).image},\r\n                            {ALT: () => $.CONSUME(DivOp).image},\r\n                            {ALT: () => $.CONSUME(ExOp).image}\r\n                        ]\r\n                    )));\r\n                values.push($.SUBRULE2($.formulaWithPercentOp));\r\n            });\r\n            $.ACTION(() => {\r\n                // evaluate\r\n                for (const ops of this.binaryOperatorsPrecedence) {\r\n                    for (let index = 0, length = infixes.length; index < length; index++) {\r\n                        const infix = infixes[index];\r\n                        if (!ops.includes(infix)) continue;\r\n                        infixes.splice(index, 1);\r\n                        values.splice(index, 2, this.utils.applyInfix(values[index], infix, values[index + 1]));\r\n                        index--;\r\n                        length--;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return values[0];\r\n        });\r\n\r\n        $.RULE('plusMinusOp', () => $.OR([\r\n            {ALT: () => $.CONSUME(PlusOp).image},\r\n            {ALT: () => $.CONSUME(MinOp).image}\r\n        ]));\r\n\r\n        $.RULE('formulaWithPercentOp', () => {\r\n            let value = $.SUBRULE($.formulaWithUnaryOp);\r\n            $.OPTION(() => {\r\n                const postfix = $.CONSUME(PercentOp).image;\r\n                value = $.ACTION(() => this.utils.applyPostfix(value, postfix));\r\n            });\r\n            return value;\r\n        });\r\n\r\n        $.RULE('formulaWithUnaryOp', () => {\r\n            // support ++---3 => -3\r\n            const prefixes = [];\r\n            $.MANY(() => {\r\n                const op = $.OR([\r\n                    {ALT: () => $.CONSUME(PlusOp).image},\r\n                    {ALT: () => $.CONSUME(MinOp).image}\r\n                ]);\r\n                prefixes.push(op);\r\n            });\r\n            const formula = $.SUBRULE($.formulaWithIntersect);\r\n            if (prefixes.length > 0) return $.ACTION(() => this.utils.applyPrefix(prefixes, formula));\r\n            return formula;\r\n        });\r\n\r\n\r\n        $.RULE('formulaWithIntersect', () => {\r\n            // e.g.  'A1 A2 A3'\r\n            let ref1 = $.SUBRULE($.formulaWithRange);\r\n            const refs = [ref1];\r\n            // console.log('check intersect')\r\n            $.MANY({\r\n                GATE: () => {\r\n                    // see https://github.com/SAP/chevrotain/blob/master/examples/grammars/css/css.js#L436-L441\r\n                    const prevToken = $.LA(0);\r\n                    const nextToken = $.LA(1);\r\n                    //  This is the only place where the grammar is whitespace sensitive.\r\n                    return nextToken.startOffset > prevToken.endOffset + 1;\r\n                },\r\n                DEF: () => {\r\n                    refs.push($.SUBRULE3($.formulaWithRange));\r\n                }\r\n            });\r\n            if (refs.length > 1) {\r\n                return $.ACTION(() => $.ACTION(() => this.utils.applyIntersect(refs)))\r\n            }\r\n            return ref1;\r\n        });\r\n\r\n        $.RULE('formulaWithRange', () => {\r\n            // e.g. 'A1:C3' or 'A1:A3:C4', can be any number of references, at lease 2\r\n            const ref1 = $.SUBRULE($.formula);\r\n            const refs = [ref1];\r\n            $.MANY(() => {\r\n                $.CONSUME(Colon);\r\n                refs.push($.SUBRULE2($.formula));\r\n            });\r\n            if (refs.length > 1)\r\n                return $.ACTION(() => $.ACTION(() => this.utils.applyRange(refs)));\r\n            return ref1;\r\n        });\r\n\r\n        $.RULE('formula', () => $.OR9([\r\n            {ALT: () => $.SUBRULE($.referenceWithoutInfix)},\r\n            {ALT: () => $.SUBRULE($.paren)},\r\n            {ALT: () => $.SUBRULE($.constant)},\r\n            {ALT: () => $.SUBRULE($.functionCall)},\r\n            {ALT: () => $.SUBRULE($.constantArray)},\r\n        ]));\r\n\r\n        $.RULE('paren', () => {\r\n            // formula paren or union paren\r\n            $.CONSUME(OpenParen);\r\n            let result;\r\n            const refs = [];\r\n            refs.push($.SUBRULE($.formulaWithBinaryOp));\r\n            $.MANY(() => {\r\n                $.CONSUME(Comma);\r\n                refs.push($.SUBRULE2($.formulaWithBinaryOp));\r\n            });\r\n            if (refs.length > 1)\r\n                result = $.ACTION(() => this.utils.applyUnion(refs));\r\n            else\r\n                result = refs[0];\r\n\r\n            $.CONSUME(CloseParen);\r\n            return result;\r\n        });\r\n\r\n        $.RULE('constantArray', () => {\r\n            // console.log('constantArray');\r\n            const arr = [[]];\r\n            let currentRow = 0;\r\n            $.CONSUME(OpenCurlyParen);\r\n\r\n            // array must contain at least one item\r\n            arr[currentRow].push($.SUBRULE($.constantForArray));\r\n            $.MANY(() => {\r\n                const sep = $.OR([\r\n                    {ALT: () => $.CONSUME(Comma).image},\r\n                    {ALT: () => $.CONSUME(Semicolon).image}\r\n                ]);\r\n                const constant = $.SUBRULE2($.constantForArray);\r\n                if (sep === ',') {\r\n                    arr[currentRow].push(constant)\r\n                } else {\r\n                    currentRow++;\r\n                    arr[currentRow] = [];\r\n                    arr[currentRow].push(constant)\r\n                }\r\n            });\r\n\r\n            $.CONSUME(CloseCurlyParen);\r\n\r\n            return $.ACTION(() => this.utils.toArray(arr));\r\n        });\r\n\r\n        /**\r\n         * Used in array\r\n         */\r\n        $.RULE('constantForArray', () => $.OR([\r\n            {\r\n                ALT: () => {\r\n                    const prefix = $.OPTION(() => $.SUBRULE($.plusMinusOp));\r\n                    const image = $.CONSUME(Number).image;\r\n                    const number = $.ACTION(() => this.utils.toNumber(image));\r\n                    if (prefix)\r\n                        return $.ACTION(() => this.utils.applyPrefix([prefix], number));\r\n                    return number;\r\n                }\r\n            }, {\r\n                ALT: () => {\r\n                    const str = $.CONSUME(String).image;\r\n                    return $.ACTION(() => this.utils.toString(str));\r\n                }\r\n            }, {\r\n                ALT: () => {\r\n                    const bool = $.CONSUME(Boolean).image;\r\n                    return $.ACTION(() => this.utils.toBoolean(bool));\r\n                }\r\n            }, {\r\n                ALT: () => {\r\n                    const err = $.CONSUME(FormulaErrorT).image;\r\n                    return $.ACTION(() => this.utils.toError(err));\r\n                }\r\n            }, {\r\n                ALT: () => {\r\n                    const err = $.CONSUME(RefError).image;\r\n                    return $.ACTION(() => this.utils.toError(err));\r\n                }\r\n            },\r\n        ]));\r\n\r\n        $.RULE('constant', () => $.OR([\r\n            {\r\n                ALT: () => {\r\n                    const number = $.CONSUME(Number).image;\r\n                    return $.ACTION(() => this.utils.toNumber(number));\r\n                }\r\n            }, {\r\n                ALT: () => {\r\n                    const str = $.CONSUME(String).image;\r\n                    return $.ACTION(() => this.utils.toString(str));\r\n                }\r\n            }, {\r\n                ALT: () => {\r\n                    const bool = $.CONSUME(Boolean).image;\r\n                    return $.ACTION(() => this.utils.toBoolean(bool));\r\n                }\r\n            }, {\r\n                ALT: () => {\r\n                    const err = $.CONSUME(FormulaErrorT).image;\r\n                    return $.ACTION(() => this.utils.toError(err));\r\n                }\r\n            },\r\n        ]));\r\n\r\n        $.RULE('functionCall', () => {\r\n            const functionName = $.CONSUME(Function).image.slice(0, -1);\r\n            // console.log('functionName', functionName);\r\n            const args = $.SUBRULE($.arguments);\r\n            $.CONSUME(CloseParen);\r\n            // dependency parser won't call function.\r\n            return $.ACTION(() => context.callFunction(functionName, args));\r\n\r\n        });\r\n\r\n        $.RULE('arguments', () => {\r\n            // console.log('try arguments')\r\n\r\n            // allows ',' in the front\r\n            $.MANY2(() => {\r\n                $.CONSUME2(Comma);\r\n            });\r\n            const args = [];\r\n            // allows empty arguments\r\n            $.OPTION(() => {\r\n                args.push($.SUBRULE($.formulaWithBinaryOp));\r\n                $.MANY(() => {\r\n                    $.CONSUME1(Comma);\r\n                    args.push(null); // e.g. ROUND(1.5,)\r\n                    $.OPTION3(() => {\r\n                        args.pop();\r\n                        args.push($.SUBRULE2($.formulaWithBinaryOp))\r\n                    });\r\n                });\r\n            });\r\n            return args;\r\n        });\r\n\r\n        $.RULE('referenceWithoutInfix', () => $.OR([\r\n\r\n            {ALT: () => $.SUBRULE($.referenceItem)},\r\n\r\n            {\r\n                // sheet name prefix\r\n                ALT: () => {\r\n                    // console.log('try sheetName');\r\n                    const sheetName = $.SUBRULE($.prefixName);\r\n                    // console.log('sheetName', sheetName);\r\n                    const referenceItem = $.SUBRULE2($.formulaWithRange);\r\n\r\n                    $.ACTION(() => {\r\n                        if (this.utils.isFormulaError(referenceItem))\r\n                            return referenceItem;\r\n                        referenceItem.ref.sheet = sheetName\r\n                    });\r\n                    return referenceItem;\r\n                }\r\n            },\r\n\r\n            // {ALT: () => $.SUBRULE('dynamicDataExchange')},\r\n        ]));\r\n\r\n        $.RULE('referenceItem', () => $.OR([\r\n            {\r\n                ALT: () => {\r\n                    const address = $.CONSUME(Cell).image;\r\n                    return $.ACTION(() => this.utils.parseCellAddress(address));\r\n                }\r\n            },\r\n            {\r\n                ALT: () => {\r\n                    const name = $.CONSUME(Name).image;\r\n                    return $.ACTION(() => context.getVariable(name))\r\n                }\r\n            },\r\n            {\r\n                ALT: () => {\r\n                    const column = $.CONSUME(Column).image;\r\n                    return $.ACTION(() => this.utils.parseCol(column))\r\n                }\r\n            },\r\n            // A row check should be here, but the token is same with Number,\r\n            // In other to resolve ambiguities, I leave this empty, and\r\n            // parse the number to row number when needed.\r\n            {\r\n                ALT: () => {\r\n                    const err = $.CONSUME(RefError).image;\r\n                    return $.ACTION(() => this.utils.toError(err))\r\n                }\r\n            },\r\n            // {ALT: () => $.SUBRULE($.udfFunctionCall)},\r\n            // {ALT: () => $.SUBRULE($.structuredReference)},\r\n        ]));\r\n\r\n        $.RULE('prefixName', () => $.OR([\r\n            {ALT: () => $.CONSUME(Sheet).image.slice(0, -1)},\r\n            {ALT: () => $.CONSUME(SheetQuoted).image.slice(1, -2).replace(/''/g, \"'\")},\r\n        ]));\r\n\r\n        this.performSelfAnalysis();\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    Parser: Parsing,\r\n};\r\n", "const FormulaError = require('../formulas/error');\r\nconst {Address} = require('../formulas/helpers');\r\nconst {Prefix, Postfix, Infix, Operators} = require('../formulas/operators');\r\nconst Collection = require('./type/collection');\r\nconst MAX_ROW = 1048576, MAX_COLUMN = 16384;\r\nconst {NotAllInputParsedException} = require('chevrotain');\r\n\r\nclass Utils {\r\n\r\n    constructor(context) {\r\n        this.context = context;\r\n    }\r\n\r\n    columnNameToNumber(columnName) {\r\n        return Address.columnNameToNumber(columnName);\r\n    }\r\n\r\n    /**\r\n     * Parse the cell address only.\r\n     * @param {string} cellAddress\r\n     * @return {{ref: {col: number, address: string, row: number}}}\r\n     */\r\n    parseCellAddress(cellAddress) {\r\n        const res = cellAddress.match(/([$]?)([A-Za-z]{1,3})([$]?)([1-9][0-9]*)/);\r\n        // console.log('parseCellAddress', cellAddress);\r\n        return {\r\n            ref: {\r\n                address: res[0],\r\n                col: this.columnNameToNumber(res[2]),\r\n                row: +res[4]\r\n            },\r\n        };\r\n    }\r\n\r\n    parseRow(row) {\r\n        const rowNum = +row;\r\n        if (!Number.isInteger(rowNum))\r\n            throw Error('Row number must be integer.');\r\n        return {\r\n            ref: {\r\n                col: undefined,\r\n                row: +row\r\n            },\r\n        };\r\n    }\r\n\r\n    parseCol(col) {\r\n        return {\r\n            ref: {\r\n                col: this.columnNameToNumber(col),\r\n                row: undefined,\r\n            },\r\n        };\r\n    }\r\n\r\n    parseColRange(col1, col2) {\r\n        // const res = colRange.match(/([$]?)([A-Za-z]{1,3}):([$]?)([A-Za-z]{1,4})/);\r\n        col1 = this.columnNameToNumber(col1);\r\n        col2 = this.columnNameToNumber(col2);\r\n        return {\r\n            ref: {\r\n                from: {\r\n                    col: Math.min(col1, col2),\r\n                    row: null\r\n                },\r\n                to: {\r\n                    col: Math.max(col1, col2),\r\n                    row: null\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    parseRowRange(row1, row2) {\r\n        // const res = rowRange.match(/([$]?)([1-9][0-9]*):([$]?)([1-9][0-9]*)/);\r\n        return {\r\n            ref: {\r\n                from: {\r\n                    col: null,\r\n                    row: Math.min(row1, row2),\r\n                },\r\n                to: {\r\n                    col: null,\r\n                    row: Math.max(row1, row2),\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    _applyPrefix(prefixes, val, isArray) {\r\n        if (this.isFormulaError(val))\r\n            return val;\r\n        return Prefix.unaryOp(prefixes, val, isArray);\r\n    }\r\n\r\n    async applyPrefixAsync(prefixes, value) {\r\n        const {val, isArray} = this.extractRefValue(await value);\r\n        return this._applyPrefix(prefixes, val, isArray);\r\n    }\r\n\r\n    /**\r\n     * Apply + or - unary prefix.\r\n     * @param {Array.<string>} prefixes\r\n     * @param {*} value\r\n     * @return {*}\r\n     */\r\n    applyPrefix(prefixes, value) {\r\n        // console.log('applyPrefix', prefixes, value);\r\n        if (this.context.async) {\r\n            return this.applyPrefixAsync(prefixes, value);\r\n        } else {\r\n            const {val, isArray} = this.extractRefValue(value);\r\n            return this._applyPrefix(prefixes, val, isArray);\r\n        }\r\n    }\r\n\r\n    _applyPostfix(val, isArray, postfix) {\r\n        if (this.isFormulaError(val))\r\n            return val;\r\n        return Postfix.percentOp(val, postfix, isArray);\r\n    }\r\n\r\n    async applyPostfixAsync(value, postfix) {\r\n        const {val, isArray} = this.extractRefValue(await value);\r\n        return this._applyPostfix(val, isArray, postfix);\r\n    }\r\n\r\n    applyPostfix(value, postfix) {\r\n        // console.log('applyPostfix', value, postfix);\r\n        if (this.context.async) {\r\n            return this.applyPostfixAsync(value, postfix);\r\n        } else {\r\n            const {val, isArray} = this.extractRefValue(value);\r\n            return this._applyPostfix(val, isArray, postfix)\r\n        }\r\n    }\r\n\r\n    _applyInfix(res1, infix, res2) {\r\n        const val1 = res1.val, isArray1 = res1.isArray;\r\n        const val2 = res2.val, isArray2 = res2.isArray;\r\n        if (this.isFormulaError(val1))\r\n            return val1;\r\n        if (this.isFormulaError(val2))\r\n            return val2;\r\n        if (Operators.compareOp.includes(infix))\r\n            return Infix.compareOp(val1, infix, val2, isArray1, isArray2);\r\n        else if (Operators.concatOp.includes(infix))\r\n            return Infix.concatOp(val1, infix, val2, isArray1, isArray2);\r\n        else if (Operators.mathOp.includes(infix))\r\n            return Infix.mathOp(val1, infix, val2, isArray1, isArray2);\r\n        else\r\n            throw new Error(`Unrecognized infix: ${infix}`);\r\n    }\r\n\r\n    async applyInfixAsync(value1, infix, value2) {\r\n        const res1 = this.extractRefValue(await value1);\r\n        const res2 = this.extractRefValue(await value2);\r\n        return this._applyInfix(res1, infix, res2)\r\n    }\r\n\r\n    applyInfix(value1, infix, value2) {\r\n        if (this.context.async) {\r\n            return this.applyInfixAsync(value1, infix, value2)\r\n        } else {\r\n            const res1 = this.extractRefValue(value1);\r\n            const res2 = this.extractRefValue(value2);\r\n            return this._applyInfix(res1, infix, res2)\r\n        }\r\n    }\r\n\r\n    applyIntersect(refs) {\r\n        // console.log('applyIntersect', refs);\r\n        if (this.isFormulaError(refs[0]))\r\n            return refs[0];\r\n        if (!refs[0].ref)\r\n            throw Error(`Expecting a reference, but got ${refs[0]}.`);\r\n        // a intersection will keep track of references, value won't be retrieved here.\r\n        let maxRow, maxCol, minRow, minCol, sheet, res; // index start from 1\r\n        // first time setup\r\n        const ref = refs.shift().ref;\r\n        sheet = ref.sheet;\r\n        if (!ref.from) {\r\n            // check whole row/col reference\r\n            if (ref.row === undefined || ref.col === undefined) {\r\n                throw Error('Cannot intersect the whole row or column.')\r\n            }\r\n\r\n            // cell ref\r\n            maxRow = minRow = ref.row;\r\n            maxCol = minCol = ref.col;\r\n        } else {\r\n            // range ref\r\n            // update\r\n            maxRow = Math.max(ref.from.row, ref.to.row);\r\n            minRow = Math.min(ref.from.row, ref.to.row);\r\n            maxCol = Math.max(ref.from.col, ref.to.col);\r\n            minCol = Math.min(ref.from.col, ref.to.col);\r\n        }\r\n\r\n        let err;\r\n        refs.forEach(ref => {\r\n            if (this.isFormulaError(ref))\r\n                return ref;\r\n            ref = ref.ref;\r\n            if (!ref) throw Error(`Expecting a reference, but got ${ref}.`);\r\n            if (!ref.from) {\r\n                if (ref.row === undefined || ref.col === undefined) {\r\n                    throw Error('Cannot intersect the whole row or column.')\r\n                }\r\n                // cell ref\r\n                if (ref.row > maxRow || ref.row < minRow || ref.col > maxCol || ref.col < minCol\r\n                    || sheet !== ref.sheet) {\r\n                    err = FormulaError.NULL;\r\n                }\r\n                maxRow = minRow = ref.row;\r\n                maxCol = minCol = ref.col;\r\n            } else {\r\n                // range ref\r\n                const refMaxRow = Math.max(ref.from.row, ref.to.row);\r\n                const refMinRow = Math.min(ref.from.row, ref.to.row);\r\n                const refMaxCol = Math.max(ref.from.col, ref.to.col);\r\n                const refMinCol = Math.min(ref.from.col, ref.to.col);\r\n                if (refMinRow > maxRow || refMaxRow < minRow || refMinCol > maxCol || refMaxCol < minCol\r\n                    || sheet !== ref.sheet) {\r\n                    err = FormulaError.NULL;\r\n                }\r\n                // update\r\n                maxRow = Math.min(maxRow, refMaxRow);\r\n                minRow = Math.max(minRow, refMinRow);\r\n                maxCol = Math.min(maxCol, refMaxCol);\r\n                minCol = Math.max(minCol, refMinCol);\r\n            }\r\n        });\r\n        if (err) return err;\r\n        // check if the ref can be reduced to cell reference\r\n        if (maxRow === minRow && maxCol === minCol) {\r\n            res = {\r\n                ref: {\r\n                    sheet,\r\n                    row: maxRow,\r\n                    col: maxCol\r\n                }\r\n            }\r\n        } else {\r\n            res = {\r\n                ref: {\r\n                    sheet,\r\n                    from: {row: minRow, col: minCol},\r\n                    to: {row: maxRow, col: maxCol}\r\n                }\r\n            };\r\n        }\r\n\r\n        if (!res.ref.sheet)\r\n            delete res.ref.sheet;\r\n        return res;\r\n    }\r\n\r\n    applyUnion(refs) {\r\n        const collection = new Collection();\r\n        for (let i = 0; i < refs.length; i++) {\r\n            if (this.isFormulaError(refs[i]))\r\n                return refs[i];\r\n            collection.add(this.extractRefValue(refs[i]).val, refs[i]);\r\n        }\r\n\r\n        // console.log('applyUnion', unions);\r\n        return collection;\r\n    }\r\n\r\n    /**\r\n     * Apply multiple references, e.g. A1:B3:C8:A:1:.....\r\n     * @param refs\r\n     // * @return {{ref: {from: {col: number, row: number}, to: {col: number, row: number}}}}\r\n     */\r\n    applyRange(refs) {\r\n        let res, maxRow = -1, maxCol = -1, minRow = MAX_ROW + 1, minCol = MAX_COLUMN + 1;\r\n        refs.forEach(ref => {\r\n            if (this.isFormulaError(ref))\r\n                return ref;\r\n            // row ref is saved as number, parse the number to row ref here\r\n            if (typeof ref === 'number') {\r\n                ref = this.parseRow(ref);\r\n            }\r\n            ref = ref.ref;\r\n            // check whole row/col reference\r\n            if (ref.row === undefined) {\r\n                minRow = 1;\r\n                maxRow = MAX_ROW\r\n            }\r\n            if (ref.col === undefined) {\r\n                minCol = 1;\r\n                maxCol = MAX_COLUMN;\r\n            }\r\n\r\n            if (ref.row > maxRow)\r\n                maxRow = ref.row;\r\n            if (ref.row < minRow)\r\n                minRow = ref.row;\r\n            if (ref.col > maxCol)\r\n                maxCol = ref.col;\r\n            if (ref.col < minCol)\r\n                minCol = ref.col;\r\n        });\r\n        if (maxRow === minRow && maxCol === minCol) {\r\n            res = {\r\n                ref: {\r\n                    row: maxRow,\r\n                    col: maxCol\r\n                }\r\n            }\r\n        } else {\r\n            res = {\r\n                ref: {\r\n                    from: {row: minRow, col: minCol},\r\n                    to: {row: maxRow, col: maxCol}\r\n                }\r\n            };\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Throw away the refs, and retrieve the value.\r\n     * @return {{val: *, isArray: boolean}}\r\n     */\r\n    extractRefValue(obj) {\r\n        let res = obj, isArray = false;\r\n        if (Array.isArray(res))\r\n            isArray = true;\r\n        if (obj.ref) {\r\n            // can be number or array\r\n            return {val: this.context.retrieveRef(obj), isArray};\r\n\r\n        }\r\n        return {val: res, isArray};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param array\r\n     * @return {Array}\r\n     */\r\n    toArray(array) {\r\n        // TODO: check if array is valid\r\n        // console.log('toArray', array);\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * @param {string} number\r\n     * @return {number}\r\n     */\r\n    toNumber(number) {\r\n        return Number(number);\r\n    }\r\n\r\n    /**\r\n     * @param {string} string\r\n     * @return {string}\r\n     */\r\n    toString(string) {\r\n        return string.substring(1, string.length - 1) .replace(/\"\"/g, '\"');\r\n    }\r\n\r\n    /**\r\n     * @param {string} bool\r\n     * @return {boolean}\r\n     */\r\n    toBoolean(bool) {\r\n        return bool === 'TRUE';\r\n    }\r\n\r\n    /**\r\n     * Parse an error.\r\n     * @param {string} error\r\n     * @return {string}\r\n     */\r\n    toError(error) {\r\n        return new FormulaError(error.toUpperCase());\r\n    }\r\n\r\n    isFormulaError(obj) {\r\n        return obj instanceof FormulaError;\r\n    }\r\n\r\n    static formatChevrotainError(error, inputText) {\r\n        let line, column, msg = '';\r\n        // e.g. SUM(1))\r\n        if (error instanceof NotAllInputParsedException) {\r\n            line = error.token.startLine;\r\n            column = error.token.startColumn;\r\n        } else {\r\n            line = error.previousToken.startLine;\r\n            column = error.previousToken.startColumn + 1;\r\n        }\r\n\r\n        msg += '\\n' + inputText.split('\\n')[line - 1] + '\\n';\r\n        msg += Array(column - 1).fill(' ').join('') + '^\\n';\r\n        msg += `Error at position ${line}:${column}\\n` + error.message;\r\n        error.errorLocation = {line, column};\r\n        return FormulaError.ERROR(msg, error);\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Utils;\r\n", "const TextFunctions = require('../formulas/functions/text');\r\nconst MathFunctions = require('../formulas/functions/math');\r\nconst TrigFunctions = require('../formulas/functions/trigonometry');\r\nconst LogicalFunctions = require('../formulas/functions/logical');\r\nconst EngFunctions = require('../formulas/functions/engineering');\r\nconst ReferenceFunctions = require('../formulas/functions/reference');\r\nconst InformationFunctions = require('../formulas/functions/information');\r\nconst StatisticalFunctions = require('../formulas/functions/statistical');\r\nconst DateFunctions = require('../formulas/functions/date');\r\nconst WebFunctions = require('../formulas/functions/web');\r\nconst FormulaError = require('../formulas/error');\r\nconst {FormulaHelpers} = require('../formulas/helpers');\r\nconst {Parser, allTokens} = require('./parsing');\r\nconst lexer = require('./lexing');\r\nconst Utils = require('./utils');\r\n\r\n/**\r\n * A Excel Formula Parser & Evaluator\r\n */\r\nclass FormulaParser {\r\n\r\n    /**\r\n     * @param {{functions: {}, functionsNeedContext: {}, onVariable: function, onCell: function, onRange: function}} [config]\r\n     * @param isTest - is in testing environment\r\n     */\r\n    constructor(config, isTest = false) {\r\n        this.logs = [];\r\n        this.isTest = isTest;\r\n        this.utils = new Utils(this);\r\n        config = Object.assign({\r\n            functions: {},\r\n            functionsNeedContext: {},\r\n            onVariable: () => null,\r\n            onCell: () => 0,\r\n            onRange: () => [[0]],\r\n        }, config);\r\n\r\n        this.onVariable = config.onVariable;\r\n        this.functions = Object.assign({}, DateFunctions, StatisticalFunctions, InformationFunctions, ReferenceFunctions,\r\n            EngFunctions, LogicalFunctions, TextFunctions, MathFunctions, TrigFunctions, WebFunctions,\r\n            config.functions, config.functionsNeedContext);\r\n        this.onRange = config.onRange;\r\n        this.onCell = config.onCell;\r\n\r\n        // functions treat null as 0, other functions treats null as \"\"\r\n        this.funsNullAs0 = Object.keys(MathFunctions)\r\n            .concat(Object.keys(TrigFunctions))\r\n            .concat(Object.keys(LogicalFunctions))\r\n            .concat(Object.keys(EngFunctions))\r\n            .concat(Object.keys(ReferenceFunctions))\r\n            .concat(Object.keys(StatisticalFunctions))\r\n            .concat(Object.keys(DateFunctions));\r\n\r\n        // functions need context and don't need to retrieve references\r\n        this.funsNeedContextAndNoDataRetrieve = ['ROW', 'ROWS', 'COLUMN', 'COLUMNS', 'SUMIF', 'INDEX', 'AVERAGEIF', 'IF'];\r\n\r\n        // functions need parser context\r\n        this.funsNeedContext = [...Object.keys(config.functionsNeedContext), ...this.funsNeedContextAndNoDataRetrieve,\r\n            'INDEX', 'OFFSET', 'INDIRECT', 'IF', 'CHOOSE', 'WEBSERVICE'];\r\n\r\n        // functions preserve reference in arguments\r\n        this.funsPreserveRef = Object.keys(InformationFunctions);\r\n\r\n        this.parser = new Parser(this, this.utils);\r\n    }\r\n\r\n    /**\r\n     * Get all lexing token names. Webpack needs this.\r\n     * @return {Array.<string>} - All token names that should not be minimized.\r\n     */\r\n    static get allTokens() {\r\n        return allTokens;\r\n    }\r\n\r\n    /**\r\n     * Get value from the cell reference\r\n     * @param ref\r\n     * @return {*}\r\n     */\r\n    getCell(ref) {\r\n        // console.log('get cell', JSON.stringify(ref));\r\n        if (ref.sheet == null)\r\n            ref.sheet = this.position ? this.position.sheet : undefined;\r\n        return this.onCell(ref);\r\n    }\r\n\r\n    /**\r\n     * Get values from the range reference.\r\n     * @param ref\r\n     * @return {*}\r\n     */\r\n    getRange(ref) {\r\n        // console.log('get range', JSON.stringify(ref));\r\n        if (ref.sheet == null)\r\n            ref.sheet = this.position ? this.position.sheet : undefined;\r\n        return this.onRange(ref)\r\n    }\r\n\r\n    /**\r\n     * TODO:\r\n     * Get references or values from a user defined variable.\r\n     * @param name\r\n     * @return {*}\r\n     */\r\n    getVariable(name) {\r\n        // console.log('get variable', name);\r\n        const res = {ref: this.onVariable(name, this.position.sheet, this.position)};\r\n        if (res.ref == null)\r\n            return FormulaError.NAME;\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Retrieve values from the given reference.\r\n     * @param valueOrRef\r\n     * @return {*}\r\n     */\r\n    retrieveRef(valueOrRef) {\r\n        if (FormulaHelpers.isRangeRef(valueOrRef)) {\r\n            return this.getRange(valueOrRef.ref);\r\n        }\r\n        if (FormulaHelpers.isCellRef(valueOrRef)) {\r\n            return this.getCell(valueOrRef.ref)\r\n        }\r\n        return valueOrRef;\r\n    }\r\n\r\n    /**\r\n     * Call an excel function.\r\n     * @param name - Function name.\r\n     * @param args - Arguments that pass to the function.\r\n     * @return {*}\r\n     */\r\n    _callFunction(name, args) {\r\n        if (name.indexOf('_xlfn.') === 0)\r\n            name = name.slice(6);\r\n        name = name.toUpperCase();\r\n        // if one arg is null, it means 0 or \"\" depends on the function it calls\r\n        const nullValue = this.funsNullAs0.includes(name) ? 0 : '';\r\n\r\n        if (!this.funsNeedContextAndNoDataRetrieve.includes(name)) {\r\n            // retrieve reference\r\n            args = args.map(arg => {\r\n                if (arg === null)\r\n                    return {value: nullValue, isArray: false, omitted: true};\r\n                const res = this.utils.extractRefValue(arg);\r\n\r\n                if (this.funsPreserveRef.includes(name)) {\r\n                    return {value: res.val, isArray: res.isArray, ref: arg.ref};\r\n                }\r\n                return {\r\n                    value: res.val,\r\n                    isArray: res.isArray,\r\n                    isRangeRef: !!FormulaHelpers.isRangeRef(arg),\r\n                    isCellRef: !!FormulaHelpers.isCellRef(arg)\r\n                };\r\n            });\r\n        }\r\n        // console.log('callFunction', name, args)\r\n\r\n        if (this.functions[name]) {\r\n            let res;\r\n            try {\r\n                if (!this.funsNeedContextAndNoDataRetrieve.includes(name) && !this.funsNeedContext.includes(name))\r\n                    res = (this.functions[name](...args));\r\n                else\r\n                    res = (this.functions[name](this, ...args));\r\n            } catch (e) {\r\n                // allow functions throw FormulaError, this make functions easier to implement!\r\n                if (e instanceof FormulaError) {\r\n                    return e;\r\n                } else {\r\n                    throw e;\r\n                }\r\n            }\r\n            if (res === undefined) {\r\n                // console.log(`Function ${name} may be not implemented.`);\r\n                if (this.isTest) {\r\n                    if (!this.logs.includes(name)) this.logs.push(name);\r\n                    return {value: 0, ref: {}};\r\n                }\r\n                throw FormulaError.NOT_IMPLEMENTED(name);\r\n            }\r\n            return res;\r\n        } else {\r\n            // console.log(`Function ${name} is not implemented`);\r\n            if (this.isTest) {\r\n                if (!this.logs.includes(name)) this.logs.push(name);\r\n                return {value: 0, ref: {}};\r\n            }\r\n            throw FormulaError.NOT_IMPLEMENTED(name);\r\n        }\r\n    }\r\n\r\n    async callFunctionAsync(name, args) {\r\n        const awaitedArgs = [];\r\n        for (const arg of args) {\r\n            awaitedArgs.push(await arg);\r\n        }\r\n        const res = await this._callFunction(name, awaitedArgs);\r\n        return FormulaHelpers.checkFunctionResult(res)\r\n    }\r\n\r\n    callFunction(name, args) {\r\n        if (this.async) {\r\n            return this.callFunctionAsync(name, args);\r\n        } else {\r\n            const res = this._callFunction(name, args);\r\n            return FormulaHelpers.checkFunctionResult(res);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return currently supported functions.\r\n     * @return {this}\r\n     */\r\n    supportedFunctions() {\r\n        const supported = [];\r\n        const functions = Object.keys(this.functions);\r\n        functions.forEach(fun => {\r\n            try {\r\n                const res = this.functions[fun](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n                if (res === undefined) return;\r\n                supported.push(fun);\r\n            } catch (e) {\r\n                if (e instanceof Error)\r\n                    supported.push(fun);\r\n            }\r\n        });\r\n        return supported.sort();\r\n    }\r\n\r\n    /**\r\n     * Check and return the appropriate formula result.\r\n     * @param result\r\n     * @param {boolean} [allowReturnArray] - If the formula can return an array\r\n     * @return {*}\r\n     */\r\n    checkFormulaResult(result, allowReturnArray = false) {\r\n        const type = typeof result;\r\n        // number\r\n        if (type === 'number') {\r\n            if (isNaN(result)) {\r\n                return FormulaError.VALUE;\r\n            } else if (!isFinite(result)) {\r\n                return FormulaError.NUM;\r\n            }\r\n            result += 0; // make -0 to 0\r\n        } else if (type === 'object') {\r\n            if (result instanceof FormulaError)\r\n                return result;\r\n            if (allowReturnArray) {\r\n                if (result.ref) {\r\n                    result = this.retrieveRef(result);\r\n                }\r\n                // Disallow union, and other unknown data types.\r\n                // e.g. `=(A1:C1, A2:E9)` -> #VALUE!\r\n                if (typeof result === 'object' && !Array.isArray(result) && result != null) {\r\n                    return FormulaError.VALUE;\r\n                }\r\n\r\n            } else {\r\n                if (result.ref && result.ref.row && !result.ref.from) {\r\n                    // single cell reference\r\n                    result = this.retrieveRef(result);\r\n                } else if (result.ref && result.ref.from && result.ref.from.col === result.ref.to.col) {\r\n                    // single Column reference\r\n                    result = this.retrieveRef({\r\n                        ref: {\r\n                            row: result.ref.from.row, col: result.ref.from.col\r\n                        }\r\n                    });\r\n                } else if (Array.isArray(result)) {\r\n                    result = result[0][0]\r\n                } else {\r\n                    // array, range reference, union collections\r\n                    return FormulaError.VALUE;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Parse an excel formula.\r\n     * @param {string} inputText\r\n     * @param {{row: number, col: number}} [position] - The position of the parsed formula\r\n     *              e.g. {row: 1, col: 1}\r\n     * @param {boolean} [allowReturnArray] - If the formula can return an array. Useful when parsing array formulas,\r\n     *                                      or data validation formulas.\r\n     * @returns {*}\r\n     */\r\n    parse(inputText, position, allowReturnArray = false) {\r\n        if (inputText.length === 0) throw Error('Input must not be empty.');\r\n        this.position = position;\r\n        this.async = false;\r\n        const lexResult = lexer.lex(inputText);\r\n        this.parser.input = lexResult.tokens;\r\n        let res;\r\n        try {\r\n            res = this.parser.formulaWithBinaryOp();\r\n            res = this.checkFormulaResult(res, allowReturnArray);\r\n            if (res instanceof FormulaError) {\r\n                return res;\r\n            }\r\n        } catch (e) {\r\n            throw FormulaError.ERROR(e.message, e);\r\n        }\r\n        if (this.parser.errors.length > 0) {\r\n            const error = this.parser.errors[0];\r\n            throw Utils.formatChevrotainError(error, inputText);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Parse an excel formula asynchronously.\r\n     * Use when providing custom async functions.\r\n     * @param {string} inputText\r\n     * @param {{row: number, col: number}} [position] - The position of the parsed formula\r\n     *              e.g. {row: 1, col: 1}\r\n     * @param {boolean} [allowReturnArray] - If the formula can return an array. Useful when parsing array formulas,\r\n     *                                      or data validation formulas.\r\n     * @returns {*}\r\n     */\r\n    async parseAsync(inputText, position, allowReturnArray = false) {\r\n        if (inputText.length === 0) throw Error('Input must not be empty.');\r\n        this.position = position;\r\n        this.async = true;\r\n        const lexResult = lexer.lex(inputText);\r\n        this.parser.input = lexResult.tokens;\r\n        let res;\r\n        try {\r\n            res = await this.parser.formulaWithBinaryOp();\r\n            res = this.checkFormulaResult(res, allowReturnArray);\r\n            if (res instanceof FormulaError) {\r\n                return res;\r\n            }\r\n        } catch (e) {\r\n            throw FormulaError.ERROR(e.message, e);\r\n        }\r\n        if (this.parser.errors.length > 0) {\r\n            const error = this.parser.errors[0];\r\n            throw Utils.formatChevrotainError(error, inputText);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    FormulaParser,\r\n    FormulaHelpers,\r\n};\r\n", "const FormulaError = require('../../formulas/error');\r\nconst {FormulaHelpers, Types, Address} = require('../../formulas/helpers');\r\nconst {Prefix, Postfix, Infix, Operators} = require('../../formulas/operators');\r\nconst Collection = require('../type/collection');\r\nconst MAX_ROW = 1048576, MAX_COLUMN = 16384;\r\n\r\nclass Utils {\r\n\r\n    constructor(context) {\r\n        this.context = context;\r\n    }\r\n\r\n    columnNameToNumber(columnName) {\r\n        return Address.columnNameToNumber(columnName);\r\n    }\r\n\r\n    /**\r\n     * Parse the cell address only.\r\n     * @param {string} cellAddress\r\n     * @return {{ref: {col: number, address: string, row: number}}}\r\n     */\r\n    parseCellAddress(cellAddress) {\r\n        const res = cellAddress.match(/([$]?)([A-Za-z]{1,3})([$]?)([1-9][0-9]*)/);\r\n        // console.log('parseCellAddress', cellAddress);\r\n        return {\r\n            ref: {\r\n                col: this.columnNameToNumber(res[2]),\r\n                row: +res[4]\r\n            },\r\n        };\r\n    }\r\n\r\n    parseRow(row) {\r\n        const rowNum = +row;\r\n        if (!Number.isInteger(rowNum))\r\n            throw Error('Row number must be integer.');\r\n        return {\r\n            ref: {\r\n                col: undefined,\r\n                row: +row\r\n            },\r\n        };\r\n    }\r\n\r\n    parseCol(col) {\r\n        return {\r\n            ref: {\r\n                col: this.columnNameToNumber(col),\r\n                row: undefined,\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Apply + or - unary prefix.\r\n     * @param {Array.<string>} prefixes\r\n     * @param {*} value\r\n     * @return {*}\r\n     */\r\n    applyPrefix(prefixes, value) {\r\n        this.extractRefValue(value);\r\n        return 0;\r\n    }\r\n\r\n    applyPostfix(value, postfix) {\r\n        this.extractRefValue(value);\r\n        return 0\r\n    }\r\n\r\n    applyInfix(value1, infix, value2) {\r\n        this.extractRefValue(value1);\r\n        this.extractRefValue(value2);\r\n        return 0;\r\n    }\r\n\r\n    applyIntersect(refs) {\r\n        // console.log('applyIntersect', refs);\r\n        if (this.isFormulaError(refs[0]))\r\n            return refs[0];\r\n        if (!refs[0].ref)\r\n            throw Error(`Expecting a reference, but got ${refs[0]}.`);\r\n        // a intersection will keep track of references, value won't be retrieved here.\r\n        let maxRow, maxCol, minRow, minCol, sheet, res; // index start from 1\r\n        // first time setup\r\n        const ref = refs.shift().ref;\r\n        sheet = ref.sheet;\r\n        if (!ref.from) {\r\n            // check whole row/col reference\r\n            if (ref.row === undefined || ref.col === undefined) {\r\n                throw Error('Cannot intersect the whole row or column.')\r\n            }\r\n\r\n            // cell ref\r\n            maxRow = minRow = ref.row;\r\n            maxCol = minCol = ref.col;\r\n        } else {\r\n            // range ref\r\n            // update\r\n            maxRow = Math.max(ref.from.row, ref.to.row);\r\n            minRow = Math.min(ref.from.row, ref.to.row);\r\n            maxCol = Math.max(ref.from.col, ref.to.col);\r\n            minCol = Math.min(ref.from.col, ref.to.col);\r\n        }\r\n\r\n        let err;\r\n        refs.forEach(ref => {\r\n            if (this.isFormulaError(ref))\r\n                return ref;\r\n            ref = ref.ref;\r\n            if (!ref) throw Error(`Expecting a reference, but got ${ref}.`);\r\n            if (!ref.from) {\r\n                if (ref.row === undefined || ref.col === undefined) {\r\n                    throw Error('Cannot intersect the whole row or column.')\r\n                }\r\n                // cell ref\r\n                if (ref.row > maxRow || ref.row < minRow || ref.col > maxCol || ref.col < minCol\r\n                    || sheet !== ref.sheet) {\r\n                    err = FormulaError.NULL;\r\n                }\r\n                maxRow = minRow = ref.row;\r\n                maxCol = minCol = ref.col;\r\n            } else {\r\n                // range ref\r\n                const refMaxRow = Math.max(ref.from.row, ref.to.row);\r\n                const refMinRow = Math.min(ref.from.row, ref.to.row);\r\n                const refMaxCol = Math.max(ref.from.col, ref.to.col);\r\n                const refMinCol = Math.min(ref.from.col, ref.to.col);\r\n                if (refMinRow > maxRow || refMaxRow < minRow || refMinCol > maxCol || refMaxCol < minCol\r\n                    || sheet !== ref.sheet) {\r\n                    err = FormulaError.NULL;\r\n                }\r\n                // update\r\n                maxRow = Math.min(maxRow, refMaxRow);\r\n                minRow = Math.max(minRow, refMinRow);\r\n                maxCol = Math.min(maxCol, refMaxCol);\r\n                minCol = Math.max(minCol, refMinCol);\r\n            }\r\n        });\r\n        if (err) return err;\r\n        // check if the ref can be reduced to cell reference\r\n        if (maxRow === minRow && maxCol === minCol) {\r\n            res = {\r\n                ref: {\r\n                    sheet,\r\n                    row: maxRow,\r\n                    col: maxCol\r\n                }\r\n            }\r\n        } else {\r\n            res = {\r\n                ref: {\r\n                    sheet,\r\n                    from: {row: minRow, col: minCol},\r\n                    to: {row: maxRow, col: maxCol}\r\n                }\r\n            };\r\n        }\r\n\r\n        if (!res.ref.sheet)\r\n            delete res.ref.sheet;\r\n        return res;\r\n    }\r\n\r\n    applyUnion(refs) {\r\n        const collection = new Collection();\r\n        for (let i = 0; i < refs.length; i++) {\r\n            if (this.isFormulaError(refs[i]))\r\n                return refs[i];\r\n            collection.add(this.extractRefValue(refs[i]).val, refs[i]);\r\n        }\r\n\r\n        // console.log('applyUnion', unions);\r\n        return collection;\r\n    }\r\n\r\n    /**\r\n     * Apply multiple references, e.g. A1:B3:C8:A:1:.....\r\n     * @param refs\r\n     // * @return {{ref: {from: {col: number, row: number}, to: {col: number, row: number}}}}\r\n     */\r\n    applyRange(refs) {\r\n        let res, maxRow = -1, maxCol = -1, minRow = MAX_ROW + 1, minCol = MAX_COLUMN + 1;\r\n        refs.forEach(ref => {\r\n            if (this.isFormulaError(ref))\r\n                return ref;\r\n            // row ref is saved as number, parse the number to row ref here\r\n            if (typeof ref === 'number') {\r\n                ref = this.parseRow(ref);\r\n            }\r\n            ref = ref.ref;\r\n            // check whole row/col reference\r\n            if (ref.row === undefined) {\r\n                minRow = 1;\r\n                maxRow = MAX_ROW\r\n            }\r\n            if (ref.col === undefined) {\r\n                minCol = 1;\r\n                maxCol = MAX_COLUMN;\r\n            }\r\n\r\n            if (ref.row > maxRow)\r\n                maxRow = ref.row;\r\n            if (ref.row < minRow)\r\n                minRow = ref.row;\r\n            if (ref.col > maxCol)\r\n                maxCol = ref.col;\r\n            if (ref.col < minCol)\r\n                minCol = ref.col;\r\n        });\r\n        if (maxRow === minRow && maxCol === minCol) {\r\n            res = {\r\n                ref: {\r\n                    row: maxRow,\r\n                    col: maxCol\r\n                }\r\n            }\r\n        } else {\r\n            res = {\r\n                ref: {\r\n                    from: {row: minRow, col: minCol},\r\n                    to: {row: maxRow, col: maxCol}\r\n                }\r\n            };\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Throw away the refs, and retrieve the value.\r\n     * @return {{val: *, isArray: boolean}}\r\n     */\r\n    extractRefValue(obj) {\r\n        const isArray = Array.isArray(obj);\r\n        if (obj.ref) {\r\n            // can be number or array\r\n            return {val: this.context.retrieveRef(obj), isArray};\r\n\r\n        }\r\n        return {val: obj, isArray};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param array\r\n     * @return {Array}\r\n     */\r\n    toArray(array) {\r\n        // TODO: check if array is valid\r\n        // console.log('toArray', array);\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * @param {string} number\r\n     * @return {number}\r\n     */\r\n    toNumber(number) {\r\n        return Number(number);\r\n    }\r\n\r\n    /**\r\n     * @param {string} string\r\n     * @return {string}\r\n     */\r\n    toString(string) {\r\n        return string.substring(1, string.length - 1) .replace(/\"\"/g, '\"');\r\n    }\r\n\r\n    /**\r\n     * @param {string} bool\r\n     * @return {boolean}\r\n     */\r\n    toBoolean(bool) {\r\n        return bool === 'TRUE';\r\n    }\r\n\r\n    /**\r\n     * Parse an error.\r\n     * @param {string} error\r\n     * @return {FormulaError}\r\n     */\r\n    toError(error) {\r\n        return new FormulaError(error.toUpperCase());\r\n    }\r\n\r\n    isFormulaError(obj) {\r\n        return obj instanceof FormulaError;\r\n    }\r\n}\r\n\r\nmodule.exports = Utils;\r\n", "const FormulaError = require('../../formulas/error');\r\nconst {FormulaHelpers} = require('../../formulas/helpers');\r\nconst {Parser} = require('../parsing');\r\nconst lexer = require('../lexing');\r\nconst Utils = require('./utils');\r\nconst {formatChevrotainError} = require('../utils');\r\n\r\nclass DepParser {\r\n\r\n    /**\r\n     *\r\n     * @param {{onVariable: Function}} [config]\r\n     */\r\n    constructor(config) {\r\n        this.data = [];\r\n        this.utils = new Utils(this);\r\n        config = Object.assign({\r\n            onVariable: () => null,\r\n        }, config);\r\n        this.utils = new Utils(this);\r\n\r\n        this.onVariable = config.onVariable;\r\n        this.functions = {}\r\n\r\n        this.parser = new Parser(this, this.utils);\r\n    }\r\n\r\n    /**\r\n     * Get value from the cell reference\r\n     * @param ref\r\n     * @return {*}\r\n     */\r\n    getCell(ref) {\r\n        // console.log('get cell', JSON.stringify(ref));\r\n        if (ref.row != null) {\r\n            if (ref.sheet == null)\r\n                ref.sheet = this.position ? this.position.sheet : undefined;\r\n            const idx = this.data.findIndex(element => {\r\n                return (element.from && element.from.row <= ref.row && element.to.row >= ref.row\r\n                    && element.from.col <= ref.col && element.to.col >= ref.col)\r\n                    || (element.row === ref.row && element.col === ref.col && element.sheet === ref.sheet)\r\n            });\r\n            if (idx === -1)\r\n                this.data.push(ref);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Get values from the range reference.\r\n     * @param ref\r\n     * @return {*}\r\n     */\r\n    getRange(ref) {\r\n        // console.log('get range', JSON.stringify(ref));\r\n        if (ref.from.row != null) {\r\n            if (ref.sheet == null)\r\n                ref.sheet = this.position ? this.position.sheet : undefined;\r\n\r\n            const idx = this.data.findIndex(element => {\r\n                return element.from && element.from.row === ref.from.row && element.from.col === ref.from.col\r\n                    && element.to.row === ref.to.row && element.to.col === ref.to.col;\r\n            });\r\n            if (idx === -1)\r\n                this.data.push(ref);\r\n        }\r\n        return [[0]]\r\n    }\r\n\r\n    /**\r\n     * TODO:\r\n     * Get references or values from a user defined variable.\r\n     * @param name\r\n     * @return {*}\r\n     */\r\n    getVariable(name) {\r\n        // console.log('get variable', name);\r\n        const res = {ref: this.onVariable(name, this.position.sheet)};\r\n        if (res.ref == null)\r\n            return FormulaError.NAME;\r\n        if (FormulaHelpers.isCellRef(res))\r\n            this.getCell(res.ref);\r\n        else {\r\n            this.getRange(res.ref);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Retrieve values from the given reference.\r\n     * @param valueOrRef\r\n     * @return {*}\r\n     */\r\n    retrieveRef(valueOrRef) {\r\n        if (FormulaHelpers.isRangeRef(valueOrRef)) {\r\n            return this.getRange(valueOrRef.ref);\r\n        }\r\n        if (FormulaHelpers.isCellRef(valueOrRef)) {\r\n            return this.getCell(valueOrRef.ref)\r\n        }\r\n        return valueOrRef;\r\n    }\r\n\r\n    /**\r\n     * Call an excel function.\r\n     * @param name - Function name.\r\n     * @param args - Arguments that pass to the function.\r\n     * @return {*}\r\n     */\r\n    callFunction(name, args) {\r\n        args.forEach(arg => {\r\n            if (arg == null)\r\n                return;\r\n            this.retrieveRef(arg);\r\n        });\r\n        return {value: 0, ref: {}};\r\n    }\r\n\r\n    /**\r\n     * Check and return the appropriate formula result.\r\n     * @param result\r\n     * @return {*}\r\n     */\r\n    checkFormulaResult(result) {\r\n        this.retrieveRef(result);\r\n    }\r\n\r\n    /**\r\n     * Parse an excel formula and return the dependencies\r\n     * @param {string} inputText\r\n     * @param {{row: number, col: number, sheet: string}} position\r\n     * @param {boolean} [ignoreError=false] if true, throw FormulaError when error occurred.\r\n     *                                      if false, the parser will return partial dependencies.\r\n     * @returns {Array.<{}>}\r\n     */\r\n    parse(inputText, position, ignoreError = false) {\r\n        if (inputText.length === 0) throw Error('Input must not be empty.');\r\n        this.data = [];\r\n        this.position = position;\r\n        const lexResult = lexer.lex(inputText);\r\n        this.parser.input = lexResult.tokens;\r\n        try {\r\n            const res = this.parser.formulaWithBinaryOp();\r\n            this.checkFormulaResult(res);\r\n        } catch (e) {\r\n            if (!ignoreError) {\r\n                throw FormulaError.ERROR(e.message, e);\r\n            }\r\n        }\r\n        if (this.parser.errors.length > 0 && !ignoreError) {\r\n            const error = this.parser.errors[0];\r\n            throw formatChevrotainError(error, inputText);\r\n        }\r\n\r\n        return this.data;\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    DepParser,\r\n};\r\n", "const {FormulaParser} = require('./grammar/hooks');\r\nconst {DepParser} = require('./grammar/dependency/hooks');\r\nconst SSF = require('./ssf/ssf');\r\nconst FormulaError = require('./formulas/error');\r\n\r\n// const funs = new FormulaParser().supportedFunctions();\r\n// console.log('Supported:', funs.join(', '),\r\n//     `\\nTotal: ${funs.length}/477, ${funs.length/477*100}% implemented.`);\r\n\r\n\r\nObject.assign(FormulaParser, {\r\n    MAX_ROW: 1048576,\r\n    MAX_COLUMN: 16384,\r\n    SSF,\r\n    DepParser,\r\n    FormulaError, ...require('./formulas/helpers')\r\n});\r\nmodule.exports = FormulaParser;\r\n", "import {\n  ComponentType,\n  Context as ContextOrig,\n  MutableRefObject,\n  Provider,\n  ReactNode,\n  createElement,\n  createContext as createContextOrig,\n  useContext as useContextOrig,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  unstable_NormalPriority as NormalPriority,\n  unstable_runWithPriority as runWithPriority,\n} from 'scheduler';\n\nimport { batchedUpdates } from './batchedUpdates';\n\nconst CONTEXT_VALUE = Symbol();\nconst ORIGINAL_PROVIDER = Symbol();\n\nconst isSSR = typeof window === 'undefined'\n  || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);\n\nconst useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect;\n\n// for preact that doesn't have runWithPriority\nconst runWithNormalPriority = runWithPriority\n  ? (thunk: () => void) => {\n    try {\n      runWithPriority(NormalPriority, thunk);\n    } catch (e: any) {\n      if (e.message === 'Not implemented.') {\n        thunk();\n      } else {\n        throw e;\n      }\n    }\n  } : (thunk: () => void) => thunk();\n\ntype Version = number;\ntype Listener<Value> = (\n  action: { n: Version, p?: Promise<Value>, v?: Value }\n) => void\n\ntype ContextValue<Value> = {\n  [CONTEXT_VALUE]: {\n    /* \"v\"alue     */ v: MutableRefObject<Value>;\n    /* versio\"n\"   */ n: MutableRefObject<Version>;\n    /* \"l\"isteners */ l: Set<Listener<Value>>;\n    /* \"u\"pdate    */ u: (thunk: () => void, options?: { suspense: boolean }) => void;\n  };\n};\n\nexport interface Context<Value> {\n  Provider: ComponentType<{ value: Value; children: ReactNode }>;\n  displayName?: string;\n}\n\nconst createProvider = <Value>(\n  ProviderOrig: Provider<ContextValue<Value>>,\n) => {\n  const ContextProvider = ({ value, children }: { value: Value; children: ReactNode }) => {\n    const valueRef = useRef(value);\n    const versionRef = useRef(0);\n    const [resolve, setResolve] = useState<((v: Value) => void) | null>(null);\n    if (resolve) {\n      resolve(value);\n      setResolve(null);\n    }\n    const contextValue = useRef<ContextValue<Value>>();\n    if (!contextValue.current) {\n      const listeners = new Set<Listener<Value>>();\n      const update = (thunk: () => void, options?: { suspense: boolean }) => {\n        batchedUpdates(() => {\n          versionRef.current += 1;\n          const action: Parameters<Listener<Value>>[0] = {\n            n: versionRef.current,\n          };\n          if (options?.suspense) {\n            action.n *= -1; // this is intentional to make it temporary version\n            action.p = new Promise<Value>((r) => {\n              setResolve(() => (v: Value) => {\n                action.v = v;\n                delete action.p;\n                r(v);\n              });\n            });\n          }\n          listeners.forEach((listener) => listener(action));\n          thunk();\n        });\n      };\n      contextValue.current = {\n        [CONTEXT_VALUE]: {\n          /* \"v\"alue     */ v: valueRef,\n          /* versio\"n\"   */ n: versionRef,\n          /* \"l\"isteners */ l: listeners,\n          /* \"u\"pdate    */ u: update,\n        },\n      };\n    }\n    useIsomorphicLayoutEffect(() => {\n      valueRef.current = value;\n      versionRef.current += 1;\n      runWithNormalPriority(() => {\n        (contextValue.current as ContextValue<Value>)[CONTEXT_VALUE].l.forEach((listener) => {\n          listener({ n: versionRef.current, v: value });\n        });\n      });\n    }, [value]);\n    return createElement(ProviderOrig, { value: contextValue.current }, children);\n  };\n  return ContextProvider;\n};\n\nconst identity = <T>(x: T) => x;\n\n/**\n * This creates a special context for `useContextSelector`.\n *\n * @example\n * import { createContext } from 'use-context-selector';\n *\n * const PersonContext = createContext({ firstName: '', familyName: '' });\n */\nexport function createContext<Value>(defaultValue: Value) {\n  const context = createContextOrig<ContextValue<Value>>({\n    [CONTEXT_VALUE]: {\n      /* \"v\"alue     */ v: { current: defaultValue },\n      /* versio\"n\"   */ n: { current: -1 },\n      /* \"l\"isteners */ l: new Set(),\n      /* \"u\"pdate    */ u: (f) => f(),\n    },\n  });\n  (context as unknown as {\n    [ORIGINAL_PROVIDER]: Provider<ContextValue<Value>>;\n  })[ORIGINAL_PROVIDER] = context.Provider;\n  (context as unknown as Context<Value>).Provider = createProvider(context.Provider);\n  delete (context as any).Consumer; // no support for Consumer\n  return context as unknown as Context<Value>;\n}\n\n/**\n * This hook returns context selected value by selector.\n *\n * It will only accept context created by `createContext`.\n * It will trigger re-render if only the selected value is referentially changed.\n *\n * The selector should return referentially equal result for same input for better performance.\n *\n * @example\n * import { useContextSelector } from 'use-context-selector';\n *\n * const firstName = useContextSelector(PersonContext, state => state.firstName);\n */\nexport function useContextSelector<Value, Selected>(\n  context: Context<Value>,\n  selector: (value: Value) => Selected,\n) {\n  const contextValue = useContextOrig(\n    context as unknown as ContextOrig<ContextValue<Value>>,\n  )[CONTEXT_VALUE];\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!contextValue) {\n      throw new Error('useContextSelector requires special context');\n    }\n  }\n  const {\n    /* \"v\"alue     */ v: { current: value },\n    /* versio\"n\"   */ n: { current: version },\n    /* \"l\"isteners */ l: listeners,\n  } = contextValue;\n  const selected = selector(value);\n  const [state, dispatch] = useReducer((\n    prev: readonly [Value, Selected],\n    action?: Parameters<Listener<Value>>[0],\n  ) => {\n    if (!action) {\n      // case for `dispatch()` below\n      return [value, selected] as const;\n    }\n    if ('p' in action) {\n      throw action.p;\n    }\n    if (action.n === version) {\n      if (Object.is(prev[1], selected)) {\n        return prev; // bail out\n      }\n      return [value, selected] as const;\n    }\n    try {\n      if ('v' in action) {\n        if (Object.is(prev[0], action.v)) {\n          return prev; // do not update\n        }\n        const nextSelected = selector(action.v);\n        if (Object.is(prev[1], nextSelected)) {\n          return prev; // do not update\n        }\n        return [action.v, nextSelected] as const;\n      }\n    } catch (e) {\n      // ignored (stale props or some other reason)\n    }\n    return [...prev] as const; // schedule update\n  }, [value, selected] as const);\n  if (!Object.is(state[1], selected)) {\n    // schedule re-render\n    // this is safe because it's self contained\n    dispatch();\n  }\n  useIsomorphicLayoutEffect(() => {\n    listeners.add(dispatch);\n    return () => {\n      listeners.delete(dispatch);\n    };\n  }, [listeners]);\n  return state[1];\n}\n\n/**\n * This hook returns the entire context value.\n * Use this instead of React.useContext for consistent behavior.\n *\n * @example\n * import { useContext } from 'use-context-selector';\n *\n * const person = useContext(PersonContext);\n */\nexport function useContext<Value>(context: Context<Value>) {\n  return useContextSelector(context, identity);\n}\n\n/**\n * This hook returns an update function that accepts a thunk function\n *\n * Use this for a function that will change a value in\n * concurrent rendering in React 18.\n * Otherwise, there's no need to use this hook.\n *\n * @example\n * import { useContextUpdate } from 'use-context-selector';\n *\n * const update = useContextUpdate();\n *\n * // Wrap set state function\n * update(() => setState(...));\n *\n * // Experimental suspense mode\n * update(() => setState(...), { suspense: true });\n */\nexport function useContextUpdate<Value>(context: Context<Value>) {\n  const contextValue = useContextOrig(\n    context as unknown as ContextOrig<ContextValue<Value>>,\n  )[CONTEXT_VALUE];\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!contextValue) {\n      throw new Error('useContextUpdate requires special context');\n    }\n  }\n  const { u: update } = contextValue;\n  return update;\n}\n\n/**\n * This is a Provider component for bridging multiple react roots\n *\n * @example\n * const valueToBridge = useBridgeValue(PersonContext);\n * return (\n *   <Renderer>\n *     <BridgeProvider context={PersonContext} value={valueToBridge}>\n *       {children}\n *     </BridgeProvider>\n *   </Renderer>\n * );\n */\nexport const BridgeProvider = ({ context, value, children }:{\n  context: Context<any>;\n  value: any;\n  children: ReactNode;\n}) => {\n  const { [ORIGINAL_PROVIDER]: ProviderOrig } = context as unknown as {\n    [ORIGINAL_PROVIDER]: Provider<unknown>;\n  };\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!ProviderOrig) {\n      throw new Error('BridgeProvider requires special context');\n    }\n  }\n  return createElement(ProviderOrig, { value }, children);\n};\n\n/**\n * This hook return a value for BridgeProvider\n */\nexport const useBridgeValue = (context: Context<any>) => {\n  const bridgeValue = useContextOrig(context as unknown as ContextOrig<ContextValue<unknown>>);\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    if (!bridgeValue[CONTEXT_VALUE]) {\n      throw new Error('useBridgeValue requires special context');\n    }\n  }\n  return bridgeValue as any;\n};\n", "function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n"],
  "mappings": "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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/NA,SAAS,YAAY,KAAK,KAAK;AAC7B,MAAK,QAAQ;AAAS,UAAM,CAAA;AAC5B,MAAI,WAAW,IAAI;AAEnB,MAAI,CAAC,OAAO,OAAO,aAAa,aAAa;AAAE;EAAO;AAEtD,MAAI,OAAO,SAAS,QAAQ,SAAS,qBAAqB,MAAM,EAAE;AAClE,MAAI,QAAQ,SAAS,cAAc,OAAO;AAC1C,QAAM,OAAO;AAEb,MAAI,aAAa,OAAO;AACtB,QAAI,KAAK,YAAY;AACnB,WAAK,aAAa,OAAO,KAAK,UAAU;IAC9C,OAAW;AACL,WAAK,YAAY,KAAK;IAC5B;EACA,OAAS;AACL,SAAK,YAAY,KAAK;EAC1B;AAEE,MAAI,MAAM,YAAY;AACpB,UAAM,WAAW,UAAU;EAC/B,OAAS;AACL,UAAM,YAAY,SAAS,eAAe,GAAG,CAAC;EAClD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",
  "names": ["classNames", "FormulaError", "isArray", "context", "upper", "FormulaError", "functionName", "general_fmt_num", "write_num", "FormulaError", "set", "FormulaError", "isArray", "FormulaError", "context", "range", "FormulaError", "FormulaError", "context", "module", "BESSEL", "besselj", "besseli", "window", "Math", "undefined", "slice", "toString", "isArray", "isFunction", "jStat", "i", "map", "clear", "row", "n", "m", "copy", "toArray", "self", "sum", "first", "last", "number", "range", "curriedFunction", "x", "X", "ssr", "sse", "sst", "FormulaError", "FormulaError", "values", "context", "range", "FormulaError", "FormulaError", "range", "FormulaError", "context", "range", "FormulaError", "FormulaError", "context", "keys", "values", "RegExpParser", "range", "set", "i", "BaseRegExpVisitor", "range", "import_regexp_to_ast", "CharCodeFinder", "charCode", "__extends", "EndAnchorFinder", "StartAnchorFinder", "map", "import_regexp_to_ast", "LexerDefinitionErrorType", "Lexer", "indent", "AbstractProduction", "__extends", "NonTerminal", "Rule", "Alternative", "Option", "RepetitionMandatory", "RepetitionMandatoryWithSeparator", "Repetition", "RepetitionWithSeparator", "Alternation", "Terminal", "RestWalker", "GAstVisitor", "__extends", "DslMethodsCollectorVisitor", "first", "__extends", "ResyncFollowsWalker", "first", "getExtraProductionArgument", "__extends", "GastRefResolverVisitor", "__extends", "AbstractNextPossibleTokensWalker", "NextAfterTokenWalker", "first", "AbstractNextTerminalAfterProductionWalker", "NextTerminalAfterManyWalker", "NextTerminalAfterManySepWalker", "NextTerminalAfterAtLeastOneWalker", "NextTerminalAfterAtLeastOneSepWalker", "tokenMatcher", "currAlt", "keys", "altIdx", "prefixKeys", "PROD_TYPE", "__extends", "RestDefinitionFinderWalker", "InsideDefinitionFinderVisitor", "collectorVisitor", "errors", "__extends", "OccurrenceValidationCollector", "OrCollector", "RepetionCollector", "resolveGrammar", "validateGrammar", "__extends", "RecognitionException", "MismatchedTokenException", "NoViableAltException", "NotAllInputParsedException", "EarlyExitException", "Recoverable", "LooksAhead", "tokenMatcher", "CstVisitorDefinitionError", "TreeBuilder", "LexerAdapter", "RecognizerApi", "RecognizerEngine", "ErrorHandler", "ContentAssist", "GastRecorder", "i", "PerformanceTracer", "indent", "ParserDefinitionErrorType", "Parser", "resolveGrammar", "validateGrammar", "__extends", "CstParser", "EmbeddedActionsParser", "Parser", "resolveGrammar", "validateGrammar", "createToken", "Lexer", "FormulaError", "String", "Function", "Cell", "Number", "Boolean", "EmbeddedActionsParser", "String", "Function", "Cell", "Number", "Boolean", "context", "values", "functionName", "FormulaError", "NotAllInputParsedException", "context", "isArray", "ref", "FormulaError", "Parser", "FormulaParser", "require_utils", "FormulaError", "context", "ref", "isArray", "require_hooks", "FormulaError", "Parser", "DepParser", "FormulaParser", "DepParser", "FormulaError", "CONTEXT_VALUE", "Symbol", "ORIGINAL_PROVIDER", "isSSR", "window", "test", "navigator", "userAgent", "useIsomorphicLayoutEffect", "useEffect", "useLayoutEffect", "runWithNormalPriority", "runWithPriority", "thunk", "NormalPriority", "e", "message", "createProvider", "ProviderOrig", "ContextProvider", "value", "children", "valueRef", "useRef", "versionRef", "resolve", "setResolve", "useState", "contextValue", "current", "listeners", "Set", "update", "options", "batchedUpdates", "action", "n", "suspense", "p", "Promise", "r", "v", "forEach", "listener", "l", "u", "createElement", "createContext", "defaultValue", "context", "createContextOrig", "CONTEXT_VALUE", "v", "current", "n", "l", "Set", "u", "f", "ORIGINAL_PROVIDER", "Provider", "createProvider", "Consumer", "useContextSelector", "selector", "contextValue", "useContextOrig", "process", "Error", "value", "version", "listeners", "selected", "state", "dispatch", "useReducer", "prev", "action", "p", "Object", "is", "nextSelected", "e", "useIsomorphicLayoutEffect", "add", "delete"]
}
