import {
  clickOutsideDiv_default,
  confirmationModal_default,
  require_month_picker
} from "/build/_shared/chunk-GNOU3FC5.js";
import "/build/_shared/chunk-KATHKNLH.js";
import {
  bannerPopup_default,
  require_js
} from "/build/_shared/chunk-NMO27HVV.js";
import {
  Loader
} from "/build/_shared/chunk-SYZM45ZP.js";
import "/build/_shared/chunk-MOIBM2EW.js";
import {
  require_db
} from "/build/_shared/chunk-HHTSHZGZ.js";
import {
  Footer,
  closeIcon_default
} from "/build/_shared/chunk-NO54GCYG.js";
import {
  HeaderFile,
  require_lib
} from "/build/_shared/chunk-Y7VWJ7EJ.js";
import {
  require_react_dom
} from "/build/_shared/chunk-I24TZKN2.js";
import "/build/_shared/chunk-TQXZOQST.js";
import "/build/_shared/chunk-DBNIQQP4.js";
import {
  lunchContent_default
} from "/build/_shared/chunk-MVHRMFV3.js";
import "/build/_shared/chunk-ZPUNGY4N.js";
import {
  Q
} from "/build/_shared/chunk-776WLWWM.js";
import {
  FRONTEND_URL,
  ISS_DENMARK_HQ,
  PARENT_STATION_IDS,
  PURGE_CACHE_URL,
  SCREENCLOUD_CACHE_CLEAR_API_URL,
  directusLoaderLink
} from "/build/_shared/chunk-YBWC7QFI.js";
import {
  addDays,
  addWeeks,
  endOfYear,
  format,
  getDay,
  getWeek,
  getYear,
  lastDayOfWeek,
  startOfWeek,
  subWeeks
} from "/build/_shared/chunk-6W3RSCO2.js";
import {
  require_session
} from "/build/_shared/chunk-2FLU7E64.js";
import {
  NavLink,
  useLoaderData,
  useNavigate
} from "/build/_shared/chunk-GKE4LW75.js";
import {
  require_jsx_dev_runtime,
  require_react
} from "/build/_shared/chunk-BXKBYPJS.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "/build/_shared/chunk-JE7OEZ56.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length = values.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map3) {
        var index2 = -1, result = Array(map3.size);
        map3.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid2 ? "Symbol(src)_1." + uid2 : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined2 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip2 = object == null;
          while (++index2 < length) {
            result2[index2] = skip2 ? undefined2 : get(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index2 = 0, length = path.length;
          while (object != null && index2 < length) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path = paths[index2], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index2 = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq2(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values2[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback2) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback2, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq2(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq2(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map4, key) {
          var data = map4.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length = transforms.length;
          while (++index2 < length) {
            var data = transforms[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index2 = -1, length = path.length, result2 = false;
          while (++index2 < length) {
            var key = toKey(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
            return eq2(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index2 < length) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill2(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY2) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq2(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq2(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone4 = wrapperClone(parent2);
            clone4.__index__ = 0;
            clone4.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone4;
            } else {
              result2 = clone4;
            }
            var previous = clone4;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map3(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map3(collection, iteratee2), INFINITY2);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map3(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map3(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample2(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length = nativeMin(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone3(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY2 || value === -INFINITY2) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq2(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index2 = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index2 < length) {
            var value = object == null ? undefined2 : object[toKey(path[index2])];
            if (value === undefined2) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange2(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate3 = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate3.source + "|" + (interpolate3 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range2 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index2 < n) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round2 = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults2;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill2;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map3;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range2;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set2;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone3;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq2;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange2;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round2;
        lodash.runInContext = runInContext2;
        lodash.sample = sample2;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/react-data-grid/dist/react-data-grid.js
var require_react_data_grid = __commonJS({
  "node_modules/react-data-grid/dist/react-data-grid.js"(exports, module) {
    !function e(t, n) {
      "object" === typeof exports && "object" === typeof module ? module.exports = n(require_react(), require_react_dom()) : "function" === typeof define && define.amd ? define(["react", "react-dom"], n) : "object" === typeof exports ? exports.ReactDataGrid = n(require_react(), require_react_dom()) : t.ReactDataGrid = n(t.React, t.ReactDOM);
    }(window, function(e, t) {
      return function(e2) {
        var t2 = {};
        function n(o) {
          if (t2[o])
            return t2[o].exports;
          var r = t2[o] = { i: o, l: false, exports: {} };
          return e2[o].call(r.exports, r, r.exports, n), r.l = true, r.exports;
        }
        return n.m = e2, n.c = t2, n.d = function(e3, t3, o) {
          n.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: o });
        }, n.r = function(e3) {
          "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, n.t = function(e3, t3) {
          if (1 & t3 && (e3 = n(e3)), 8 & t3)
            return e3;
          if (4 & t3 && "object" === typeof e3 && e3 && e3.__esModule)
            return e3;
          var o = /* @__PURE__ */ Object.create(null);
          if (n.r(o), Object.defineProperty(o, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
            for (var r in e3)
              n.d(o, r, function(t4) {
                return e3[t4];
              }.bind(null, r));
          return o;
        }, n.n = function(e3) {
          var t3 = e3 && e3.__esModule ? function t4() {
            return e3.default;
          } : function t4() {
            return e3;
          };
          return n.d(t3, "a", t3), t3;
        }, n.o = function(e3, t3) {
          return Object.prototype.hasOwnProperty.call(e3, t3);
        }, n.p = "", n(n.s = 466);
      }([, function(t2, n) {
        t2.exports = e;
      }, , function(e2, t2) {
        e2.exports = function n(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        };
      }, function(e2, t2) {
        e2.exports = function n(e3, t3) {
          if (!(e3 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        };
      }, function(e2, t2) {
        function n(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var o = t3[n2];
            o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e3, o.key, o);
          }
        }
        e2.exports = function o(e3, t3, r) {
          return t3 && n(e3.prototype, t3), r && n(e3, r), e3;
        };
      }, , function(e2, t2, n) {
        var o = n(56), r = n(13);
        e2.exports = function l(e3, t3) {
          return !t3 || "object" !== o(t3) && "function" !== typeof t3 ? r(e3) : t3;
        };
      }, function(e2, t2) {
        function n(t3) {
          return e2.exports = n = Object.setPrototypeOf ? Object.getPrototypeOf : function e3(t4) {
            return t4.__proto__ || Object.getPrototypeOf(t4);
          }, n(t3);
        }
        e2.exports = n;
      }, function(e2, t2, n) {
        var o = n(116);
        e2.exports = function r(e3, t3) {
          if ("function" !== typeof t3 && null !== t3)
            throw new TypeError("Super expression must either be null or a function");
          e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), t3 && o(e3, t3);
        };
      }, function(e2, t2, n) {
        e2.exports = n(117)();
      }, function(e2, t2) {
        e2.exports = function n(e3, t3, o) {
          return t3 in e3 ? Object.defineProperty(e3, t3, { value: o, enumerable: true, configurable: true, writable: true }) : e3[t3] = o, e3;
        };
      }, , function(e2, t2) {
        e2.exports = function n(e3) {
          if (void 0 === e3)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e3;
        };
      }, , , function(e2, t2) {
        function n() {
          return e2.exports = n = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n2 = arguments[t3];
              for (var o in n2)
                Object.prototype.hasOwnProperty.call(n2, o) && (e3[o] = n2[o]);
            }
            return e3;
          }, n.apply(this, arguments);
        }
        e2.exports = n;
      }, , function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.last = t2.isImmutableMap = t2.getMixedTypeValueRetriever = t2.isImmutableCollection = t2.isEmptyObject = t2.isFunction = t2.isEmptyArray = t2.isColumnsImmutable = void 0;
        var r = o(n(56)), l = function e3() {
          return "undefined" !== typeof Immutable;
        };
        t2.isColumnsImmutable = function e3(t3) {
          return l() && t3 instanceof Immutable.List;
        };
        t2.isEmptyArray = function e3(t3) {
          return Array.isArray(t3) && 0 === t3.length;
        };
        t2.isFunction = function e3(t3) {
          return t3 && "[object Function]" === {}.toString.call(t3);
        };
        t2.isEmptyObject = function e3(t3) {
          return 0 === Object.keys(t3).length && t3.constructor === Object;
        };
        t2.isImmutableCollection = function e3(t3) {
          return l() && Immutable.Iterable.isIterable(t3);
        };
        t2.getMixedTypeValueRetriever = function e3(t3) {
          var n2 = {};
          return n2.getValue = t3 ? function e4(t4, n3) {
            return t4.get(n3);
          } : function e4(t4, n3) {
            return t4[n3];
          }, n2;
        };
        var a = l() ? Immutable.Map.isMap : function() {
          return false;
        };
        t2.isImmutableMap = a;
        t2.last = function e3(t3) {
          if (null == t3)
            throw new Error("arrayOrCollection is null");
          if (l() && Immutable.List.isList(t3))
            return t3.last();
          if (Array.isArray(t3))
            return t3[t3.length - 1];
          throw new Error("Cant get last of: " + (0, r.default)(t3));
        };
      }, function(e2, t2) {
        e2.exports = function n(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3) {
            for (var n2 in e3)
              if (Object.prototype.hasOwnProperty.call(e3, n2)) {
                var o = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e3, n2) : {};
                o.get || o.set ? Object.defineProperty(t3, n2, o) : t3[n2] = e3[n2];
              }
          }
          return t3.default = e3, t3;
        };
      }, function(e2, n) {
        e2.exports = t;
      }, , , , , function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getColumn = function o(e3, t3) {
          if (Array.isArray(e3))
            return e3[t3];
          if ("undefined" !== typeof Immutable)
            return e3.get(t3);
        }, t2.spliceColumn = function r(e3, t3, n2) {
          Array.isArray(e3.columns) ? e3.columns.splice(t3, 1, n2) : "undefined" !== typeof Immutable && (e3.columns = e3.columns.splice(t3, 1, n2));
          return e3;
        }, t2.getSize = function l(e3) {
          if (Array.isArray(e3))
            return e3.length;
          if ("undefined" !== typeof Immutable)
            return e3.size;
        }, t2.canEdit = function a(e3, t3, n2) {
          if (!e3)
            return false;
          if (null != e3.editable && "function" === typeof e3.editable)
            return true === n2 && e3.editable(t3);
          return true === n2 && (!!e3.editor || !!e3.editable);
        }, t2.getValue = function i(e3, t3) {
          var n2;
          n2 = e3.toJSON && e3.get ? e3.get(t3) : e3[t3];
          return n2;
        }, t2.isFrozen = function u(e3) {
          return true === e3.locked || true === e3.frozen;
        };
      }, function(e2, t2, n) {
        "use strict";
        e2.exports = function(e3) {
          var t3 = [];
          return t3.toString = function t4() {
            return this.map(function(t5) {
              var n2 = function o(e4, t6) {
                var n3 = e4[1] || "", o2 = e4[3];
                if (!o2)
                  return n3;
                if (t6 && "function" === typeof btoa) {
                  var r = function l(e5) {
                    return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(e5)))) + " */";
                  }(o2), a = o2.sources.map(function(e5) {
                    return "/*# sourceURL=" + o2.sourceRoot + e5 + " */";
                  });
                  return [n3].concat(a).concat([r]).join("\n");
                }
                return [n3].join("\n");
              }(t5, e3);
              return t5[2] ? "@media " + t5[2] + "{" + n2 + "}" : n2;
            }).join("");
          }, t3.i = function(e4, n2) {
            "string" === typeof e4 && (e4 = [[null, e4, ""]]);
            for (var o = {}, r = 0; r < this.length; r++) {
              var l = this[r][0];
              null != l && (o[l] = true);
            }
            for (r = 0; r < e4.length; r++) {
              var a = e4[r];
              null != a[0] && o[a[0]] || (n2 && !a[2] ? a[2] = n2 : n2 && (a[2] = "(" + a[2] + ") and (" + n2 + ")"), t3.push(a));
            }
          }, t3;
        };
      }, function(e2, t2, n) {
        var o = {}, r = function(e3) {
          var t3;
          return function() {
            return "undefined" === typeof t3 && (t3 = e3.apply(this, arguments)), t3;
          };
        }(function() {
          return window && document && document.all && !window.atob;
        }), l = function(e3) {
          var t3 = {};
          return function(e4, n2) {
            if ("function" === typeof e4)
              return e4();
            if ("undefined" === typeof t3[e4]) {
              var o2 = function(e5, t4) {
                return t4 ? t4.querySelector(e5) : document.querySelector(e5);
              }.call(this, e4, n2);
              if (window.HTMLIFrameElement && o2 instanceof window.HTMLIFrameElement)
                try {
                  o2 = o2.contentDocument.head;
                } catch (r2) {
                  o2 = null;
                }
              t3[e4] = o2;
            }
            return t3[e4];
          };
        }(), a = null, i = 0, u = [], d = n(123);
        function s(e3, t3) {
          for (var n2 = 0; n2 < e3.length; n2++) {
            var r2 = e3[n2], l2 = o[r2.id];
            if (l2) {
              l2.refs++;
              for (var a2 = 0; a2 < l2.parts.length; a2++)
                l2.parts[a2](r2.parts[a2]);
              for (; a2 < r2.parts.length; a2++)
                l2.parts.push(m(r2.parts[a2], t3));
            } else {
              var i2 = [];
              for (a2 = 0; a2 < r2.parts.length; a2++)
                i2.push(m(r2.parts[a2], t3));
              o[r2.id] = { id: r2.id, refs: 1, parts: i2 };
            }
          }
        }
        function c(e3, t3) {
          for (var n2 = [], o2 = {}, r2 = 0; r2 < e3.length; r2++) {
            var l2 = e3[r2], a2 = t3.base ? l2[0] + t3.base : l2[0], i2 = { css: l2[1], media: l2[2], sourceMap: l2[3] };
            o2[a2] ? o2[a2].parts.push(i2) : n2.push(o2[a2] = { id: a2, parts: [i2] });
          }
          return n2;
        }
        function f(e3, t3) {
          var n2 = l(e3.insertInto);
          if (!n2)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
          var o2 = u[u.length - 1];
          if ("top" === e3.insertAt)
            o2 ? o2.nextSibling ? n2.insertBefore(t3, o2.nextSibling) : n2.appendChild(t3) : n2.insertBefore(t3, n2.firstChild), u.push(t3);
          else if ("bottom" === e3.insertAt)
            n2.appendChild(t3);
          else {
            if ("object" !== typeof e3.insertAt || !e3.insertAt.before)
              throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
            var r2 = l(e3.insertAt.before, n2);
            n2.insertBefore(t3, r2);
          }
        }
        function p(e3) {
          if (null === e3.parentNode)
            return false;
          e3.parentNode.removeChild(e3);
          var t3 = u.indexOf(e3);
          t3 >= 0 && u.splice(t3, 1);
        }
        function g(e3) {
          var t3 = document.createElement("style");
          if (void 0 === e3.attrs.type && (e3.attrs.type = "text/css"), void 0 === e3.attrs.nonce) {
            var o2 = function r2() {
              0;
              return n.nc;
            }();
            o2 && (e3.attrs.nonce = o2);
          }
          return h(t3, e3.attrs), f(e3, t3), t3;
        }
        function h(e3, t3) {
          Object.keys(t3).forEach(function(n2) {
            e3.setAttribute(n2, t3[n2]);
          });
        }
        function m(e3, t3) {
          var n2, o2, r2, l2;
          if (t3.transform && e3.css) {
            if (!(l2 = "function" === typeof t3.transform ? t3.transform(e3.css) : t3.transform.default(e3.css)))
              return function() {
              };
            e3.css = l2;
          }
          if (t3.singleton) {
            var u2 = i++;
            n2 = a || (a = g(t3)), o2 = C.bind(null, n2, u2, false), r2 = C.bind(null, n2, u2, true);
          } else
            e3.sourceMap && "function" === typeof URL && "function" === typeof URL.createObjectURL && "function" === typeof URL.revokeObjectURL && "function" === typeof Blob && "function" === typeof btoa ? (n2 = function s2(e4) {
              var t4 = document.createElement("link");
              return void 0 === e4.attrs.type && (e4.attrs.type = "text/css"), e4.attrs.rel = "stylesheet", h(t4, e4.attrs), f(e4, t4), t4;
            }(t3), o2 = function c2(e4, t4, n3) {
              var o3 = n3.css, r3 = n3.sourceMap, l3 = void 0 === t4.convertToAbsoluteUrls && r3;
              (t4.convertToAbsoluteUrls || l3) && (o3 = d(o3));
              r3 && (o3 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(r3)))) + " */");
              var a2 = new Blob([o3], { type: "text/css" }), i2 = e4.href;
              e4.href = URL.createObjectURL(a2), i2 && URL.revokeObjectURL(i2);
            }.bind(null, n2, t3), r2 = function() {
              p(n2), n2.href && URL.revokeObjectURL(n2.href);
            }) : (n2 = g(t3), o2 = function m2(e4, t4) {
              var n3 = t4.css, o3 = t4.media;
              o3 && e4.setAttribute("media", o3);
              if (e4.styleSheet)
                e4.styleSheet.cssText = n3;
              else {
                for (; e4.firstChild; )
                  e4.removeChild(e4.firstChild);
                e4.appendChild(document.createTextNode(n3));
              }
            }.bind(null, n2), r2 = function() {
              p(n2);
            });
          return o2(e3), function t4(n3) {
            if (n3) {
              if (n3.css === e3.css && n3.media === e3.media && n3.sourceMap === e3.sourceMap)
                return;
              o2(e3 = n3);
            } else
              r2();
          };
        }
        e2.exports = function(e3, t3) {
          if ("undefined" !== typeof DEBUG && DEBUG && "object" !== typeof document)
            throw new Error("The style-loader cannot be used in a non-browser environment");
          (t3 = t3 || {}).attrs = "object" === typeof t3.attrs ? t3.attrs : {}, t3.singleton || "boolean" === typeof t3.singleton || (t3.singleton = r()), t3.insertInto || (t3.insertInto = "head"), t3.insertAt || (t3.insertAt = "bottom");
          var n2 = c(e3, t3);
          return s(n2, t3), function e4(r2) {
            for (var l2 = [], a2 = 0; a2 < n2.length; a2++) {
              var i2 = n2[a2];
              (u2 = o[i2.id]).refs--, l2.push(u2);
            }
            r2 && s(c(r2, t3), t3);
            for (a2 = 0; a2 < l2.length; a2++) {
              var u2;
              if (0 === (u2 = l2[a2]).refs) {
                for (var d2 = 0; d2 < u2.parts.length; d2++)
                  u2.parts[d2]();
                delete o[u2.id];
              }
            }
          };
        };
        var w = function() {
          var e3 = [];
          return function(t3, n2) {
            return e3[t3] = n2, e3.filter(Boolean).join("\n");
          };
        }();
        function C(e3, t3, n2, o2) {
          var r2 = n2 ? "" : o2.css;
          if (e3.styleSheet)
            e3.styleSheet.cssText = w(t3, r2);
          else {
            var l2 = document.createTextNode(r2), a2 = e3.childNodes;
            a2[t3] && e3.removeChild(a2[t3]), a2.length ? e3.insertBefore(l2, a2[t3]) : e3.appendChild(l2);
          }
        }
      }, , function(e2, t2, n) {
        "use strict";
        var o = n(3), r = n(19);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.HeaderRowType = t2.EventTypes = t2.CellNavigationMode = t2.DragItemTypes = t2.CellExpand = t2.UpdateActions = void 0;
        var l = r(n(119));
        t2.CellNavigationMode = l;
        var a = r(n(120));
        t2.EventTypes = a;
        var i = r(n(121));
        t2.HeaderRowType = i;
        var u = (0, o(n(122)).default)({ CELL_UPDATE: null, COLUMN_FILL: null, COPY_PASTE: null, CELL_DRAG: null });
        t2.UpdateActions = u;
        t2.DragItemTypes = { Column: "column" };
        var d = { DOWN_TRIANGLE: String.fromCharCode(9660), RIGHT_TRIANGLE: String.fromCharCode(9654) };
        t2.CellExpand = d;
      }, , , , , , , , , , , , function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(10)), l = r.default.shape({ name: r.default.node.isRequired, key: r.default.string.isRequired, width: r.default.number.isRequired, filterable: r.default.bool });
        t2.default = l;
      }, , , , , , function(e2, t2, n) {
        var o = n(11);
        e2.exports = function r(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {}, r2 = Object.keys(n2);
            "function" === typeof Object.getOwnPropertySymbols && (r2 = r2.concat(Object.getOwnPropertySymbols(n2).filter(function(e4) {
              return Object.getOwnPropertyDescriptor(n2, e4).enumerable;
            }))), r2.forEach(function(t4) {
              o(e3, t4, n2[t4]);
            });
          }
          return e3;
        };
      }, , function(e2, t2, n) {
        var o;
        !function() {
          "use strict";
          var n2 = {}.hasOwnProperty;
          function r() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) {
              var o2 = arguments[t3];
              if (o2) {
                var l = typeof o2;
                if ("string" === l || "number" === l)
                  e3.push(o2);
                else if (Array.isArray(o2) && o2.length) {
                  var a = r.apply(null, o2);
                  a && e3.push(a);
                } else if ("object" === l)
                  for (var i in o2)
                    n2.call(o2, i) && o2[i] && e3.push(i);
              }
            }
            return e3.join(" ");
          }
          e2.exports ? (r.default = r, e2.exports = r) : void 0 === (o = function() {
            return r;
          }.apply(t2, [])) || (e2.exports = o);
        }();
      }, , , , , , , function(e2, t2) {
        function n(e3) {
          return (n = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function e4(t3) {
            return typeof t3;
          } : function e4(t3) {
            return t3 && "function" === typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(e3);
        }
        function o(t3) {
          return "function" === typeof Symbol && "symbol" === n(Symbol.iterator) ? e2.exports = o = function e3(t4) {
            return n(t4);
          } : e2.exports = o = function e3(t4) {
            return t4 && "function" === typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : n(t4);
          }, o(t3);
        }
        e2.exports = o;
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var o = function r(e3, t3) {
          return t3.reduce(function(t4, n2) {
            return n2 in e3 && (t4[n2] = e3[n2]), t4;
          }, {});
        };
        t2.default = o;
      }, function(e2, t2, n) {
        var o = n(214);
        "string" === typeof o && (o = [[e2.i, o, ""]]);
        var r = { hmr: true, transform: void 0, insertInto: void 0 };
        n(27)(o, r);
        o.locals && (e2.exports = o.locals);
      }, , , , function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function o(e3, t3) {
          return t3.columns !== e3.columns || e3.row !== t3.row || t3.colOverscanStartIdx !== e3.colOverscanStartIdx || t3.colOverscanEndIdx !== e3.colOverscanEndIdx || t3.colVisibleStartIdx !== e3.colVisibleStartIdx || t3.colVisibleEndIdx !== e3.colVisibleEndIdx || t3.isSelected !== e3.isSelected || t3.isScrolling !== e3.isScrolling || e3.height !== t3.height || t3.isOver !== e3.isOver || t3.expandedRows !== e3.expandedRows || t3.canDrop !== e3.canDrop || true === t3.forceUpdate || t3.extraClasses !== e3.extraClasses;
        };
      }, function(e2, t2, n) {
        var o = n(125);
        "string" === typeof o && (o = [[e2.i, o, ""]]);
        var r = { hmr: true, transform: void 0, insertInto: void 0 };
        n(27)(o, r);
        o.locals && (e2.exports = o.locals);
      }, function(e2, t2, n) {
        "use strict";
        e2.exports = { CheckboxEditor: n(86), EditorBase: n(68), SimpleTextEditor: n(85) };
      }, , function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(10)), l = { rowKey: r.default.string.isRequired, onCellClick: r.default.func.isRequired, onCellMouseDown: r.default.func.isRequired, onCellMouseEnter: r.default.func.isRequired, onCellContextMenu: r.default.func.isRequired, onCellDoubleClick: r.default.func.isRequired, onDragEnter: r.default.func.isRequired, onRowExpandToggle: r.default.func.isRequired, onDeleteSubRow: r.default.func, onAddSubRow: r.default.func, onColumnEvent: r.default.func.isRequired, onCellExpand: r.default.func.isRequired, getCellActions: r.default.func };
        t2.default = l;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(90)), a = o(n(1)), i = o(n(10)), u = function e3(t3) {
          var n2 = t3.left, o2 = t3.top, r2 = t3.width;
          return { height: t3.height, width: r2, zIndex: t3.zIndex, position: "absolute", pointerEvents: "none", transform: "translate(".concat(n2, "px, ").concat(o2, "px)"), outline: 0 };
        }, d = function e3(t3) {
          var n2 = t3.width, o2 = t3.height, i2 = t3.top, d2 = t3.left, s2 = t3.zIndex, c = t3.children, f = t3.innerRef, p = (0, l.default)(t3, ["width", "height", "top", "left", "zIndex", "children", "innerRef"]);
          return a.default.createElement("div", (0, r.default)({ style: u({ left: d2, top: i2, width: n2, height: o2, zIndex: s2 }), "data-test": "cell-mask", ref: f }, p), c);
        };
        d.propTypes = { width: i.default.number.isRequired, height: i.default.number.isRequired, top: i.default.number.isRequired, left: i.default.number.isRequired, zIndex: i.default.number.isRequired, children: i.default.node, innerRef: i.default.func };
        var s = d;
        t2.default = s;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(9)), d = o(n(41)), s = o(n(10)), c = n(1), f = n(20), p = function(e3) {
          function t3() {
            return (0, r.default)(this, t3), (0, a.default)(this, (0, i.default)(t3).apply(this, arguments));
          }
          return (0, u.default)(t3, e3), (0, l.default)(t3, [{ key: "getStyle", value: function e4() {
            return { width: "100%" };
          } }, { key: "getValue", value: function e4() {
            var t4 = {};
            return t4[this.props.column.key] = this.getInputNode().value, t4;
          } }, { key: "getInputNode", value: function e4() {
            var t4 = f.findDOMNode(this);
            return "INPUT" === t4.tagName ? t4 : t4.querySelector("input:not([type=hidden])");
          } }, { key: "inheritContainerStyles", value: function e4() {
            return true;
          } }]), t3;
        }(c.Component);
        p.propTypes = { onKeyDown: s.default.func.isRequired, value: s.default.any.isRequired, onBlur: s.default.func.isRequired, column: s.default.shape(d.default).isRequired, commit: s.default.func.isRequired }, e2.exports = p;
      }, function(e2, t2, n) {
        var o = n(234);
        "string" === typeof o && (o = [[e2.i, o, ""]]);
        var r = { hmr: true, transform: void 0, insertInto: void 0 };
        n(27)(o, r);
        o.locals && (e2.exports = o.locals);
      }, , , , , , , , , , , , , , , , function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = n(1), f = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "setInputRef", function(e5) {
              n2.input = e5;
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "render", value: function e4() {
            return c.createElement("input", { ref: this.setInputRef, type: "text", onBlur: this.props.onBlur, className: "form-control", defaultValue: this.props.value });
          } }]), t3;
        }(n(68));
        e2.exports = f;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(10)), f = n(1);
        n(87);
        var p = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "handleChange", function(e5) {
              n2.props.column.onCellChange(n2.props.rowIdx, n2.props.column.key, n2.props.dependentValues, e5);
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "render", value: function e4() {
            var t4 = null != this.props.value && this.props.value, n2 = "checkbox" + this.props.rowIdx;
            return f.createElement("div", { className: "react-grid-checkbox-container checkbox-align", onClick: this.handleChange }, f.createElement("input", { className: "react-grid-checkbox", type: "checkbox", name: n2, checked: t4, readOnly: true }), f.createElement("label", { htmlFor: n2, className: "react-grid-checkbox-label" }));
          } }]), t3;
        }(f.Component);
        (0, s.default)(p, "propTypes", { value: c.default.bool, rowIdx: c.default.number, column: c.default.shape({ key: c.default.string, onCellChange: c.default.func }), dependentValues: c.default.object }), e2.exports = p;
      }, function(e2, t2, n) {
        var o = n(126);
        "string" === typeof o && (o = [[e2.i, o, ""]]);
        var r = { hmr: true, transform: void 0, insertInto: void 0 };
        n(27)(o, r);
        o.locals && (e2.exports = o.locals);
      }, , function(e2, t2, n) {
        "use strict";
        var o;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function r() {
          if (void 0 === o) {
            var e3 = document.createElement("div");
            e3.style.width = "50px", e3.style.height = "50px", e3.style.position = "absolute", e3.style.top = "-200px", e3.style.left = "-200px";
            var t3 = document.createElement("div");
            t3.style.height = "100px", t3.style.width = "100%", e3.appendChild(t3), document.body.appendChild(e3);
            var n2 = e3.clientWidth;
            e3.style.overflowY = "scroll";
            var r2 = t3.clientWidth;
            document.body.removeChild(e3), o = n2 - r2;
          }
          return o;
        };
      }, function(e2, t2, n) {
        var o = n(219);
        e2.exports = function r(e3, t3) {
          if (null == e3)
            return {};
          var n2, r2, l = o(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var a = Object.getOwnPropertySymbols(e3);
            for (r2 = 0; r2 < a.length; r2++)
              n2 = a[r2], t3.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n2) && (l[n2] = e3[n2]);
          }
          return l;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = { get: function e3(t3, n2) {
          return "function" === typeof t3.get ? t3.get(n2) : t3[n2];
        }, isRowSelected: function e3(t3, n2, o2, r, l) {
          return n2 && "[object Array]" === Object.prototype.toString.call(n2) ? n2.indexOf(l) > -1 : t3 && t3.rowKey && t3.values && "[object Array]" === Object.prototype.toString.call(t3.values) ? t3.values.indexOf(r[t3.rowKey]) > -1 : !(!o2 || !r || "string" !== typeof o2) && r[o2];
        } };
        e2.exports = o;
      }, , , , , , , , , , , , , , , , , , , , , , function(e2, t2, n) {
        var o = n(124);
        "string" === typeof o && (o = [[e2.i, o, ""]]);
        var r = { hmr: true, transform: void 0, insertInto: void 0 };
        n(27)(o, r);
        o.locals && (e2.exports = o.locals);
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = { Column: o(n(41)).default };
        t2.default = r;
      }, , function(e2, t2) {
        function n(t3, o) {
          return e2.exports = n = Object.setPrototypeOf || function e3(t4, n2) {
            return t4.__proto__ = n2, t4;
          }, n(t3, o);
        }
        e2.exports = n;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(118);
        function r() {
        }
        function l() {
        }
        l.resetWarningCache = r, e2.exports = function() {
          function e3(e4, t4, n3, r2, l2, a) {
            if (a !== o) {
              var i = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
              throw i.name = "Invariant Violation", i;
            }
          }
          function t3() {
            return e3;
          }
          e3.isRequired = e3;
          var n2 = { array: e3, bool: e3, func: e3, number: e3, object: e3, string: e3, symbol: e3, any: e3, arrayOf: t3, element: e3, elementType: e3, instanceOf: t3, node: e3, objectOf: t3, oneOf: t3, oneOfType: t3, shape: t3, exact: t3, checkPropTypes: l, resetWarningCache: r };
          return n2.PropTypes = n2, n2;
        };
      }, function(e2, t2, n) {
        "use strict";
        e2.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LOOP_OVER_ROW = t2.CHANGE_ROW = t2.NONE = void 0;
        t2.NONE = "none";
        t2.CHANGE_ROW = "changeRow";
        t2.LOOP_OVER_ROW = "loopOverRow";
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SCROLL_TO_COLUMN = t2.DRAG_ENTER = t2.SELECT_END = t2.SELECT_UPDATE = t2.SELECT_START = t2.SELECT_CELL = void 0;
        t2.SELECT_CELL = "SELECT_CELL";
        t2.SELECT_START = "SELECT_START";
        t2.SELECT_UPDATE = "SELECT_UPDATE";
        t2.SELECT_END = "SELECT_END";
        t2.DRAG_ENTER = "DRAG_ENTER";
        t2.SCROLL_TO_COLUMN = "SCROLL_TO_COLUMN";
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.FILTER = t2.HEADER = void 0;
        t2.HEADER = "header";
        t2.FILTER = "filter";
      }, function(e2, t2, n) {
        "use strict";
        e2.exports = function(e3) {
          var t3, n2 = {};
          if (!(e3 instanceof Object) || Array.isArray(e3))
            throw new Error("keyMirror(...): Argument must be an object.");
          for (t3 in e3)
            e3.hasOwnProperty(t3) && (n2[t3] = t3);
          return n2;
        };
      }, function(e2, t2) {
        e2.exports = function(e3) {
          var t3 = "undefined" !== typeof window && window.location;
          if (!t3)
            throw new Error("fixUrls requires window.location");
          if (!e3 || "string" !== typeof e3)
            return e3;
          var n = t3.protocol + "//" + t3.host, o = n + t3.pathname.replace(/\/[^\/]*$/, "/");
          return e3.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(e4, t4) {
            var r, l = t4.trim().replace(/^"(.*)"$/, function(e5, t5) {
              return t5;
            }).replace(/^'(.*)'$/, function(e5, t5) {
              return t5;
            });
            return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(l) ? e4 : (r = 0 === l.indexOf("//") ? l : 0 === l.indexOf("/") ? n + l : o + l.replace(/^\.\//, ""), "url(" + JSON.stringify(r) + ")");
          });
        };
      }, function(e2, t2, n) {
        (e2.exports = n(26)(false)).push([e2.i, '.react-grid-Cell {\n  background-color: #ffffff;\n  padding-left: 8px;\n  padding-right: 8px;\n  border-right: 1px solid #eee;\n  border-bottom: 1px solid #dddddd;\n}\n\n.rdg-selected {\n  border: 2px solid #66afe9;\n}\n\n.rdg-selected-range {\n  border: 1px solid #66afe9;\n  background-color: #66afe930;\n}\n\n.moving-element {\n  will-change: transform;\n}\n.react-grid-Cell--frozen {\n  /* Should have a higher value than 1 to show in front of cell masks */\n  z-index: 2;\n}\n.rdg-last--frozen {\n  border-right: 1px solid #dddddd;\n  box-shadow: 2px 0 5px -2px rgba(136, 136, 136, .3) !important;\n}\n\n/* cell which have tooltips need to have a higher z-index on hover so that the tooltip appears above the other cells*/\n.react-grid-Cell.has-tooltip:hover {\n  z-index: 1;\n}\n\n.react-grid-Cell.react-grid-Cell--frozen.has-tooltip:hover  {\n  z-index: 3\n}\n\n.react-contextmenu--visible {\n  z-index: 1000;\n}\n\n.react-grid-Cell:not(.editing) .react-grid-Cell__value {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  height: inherit;\n}\n\n.react-grid-Cell.readonly {\n  background-color : black;\n}\n\n\n.react-grid-Cell:hover {\n  background: #eee;\n}\n\n.react-grid-cell .form-control-feedback {\n  color: #a94442;\n  position: absolute;\n  top: 0px;\n  right: 10px;\n  z-index: 1000000;\n  display: block;\n  width: 34px;\n  height: 34px;\n}\n\n.react-grid-Row.row-selected .react-grid-Cell{\n background-color: #DBECFA;\n}\n\n.react-grid-Cell.editing {\n  padding: 0;\n  overflow: visible !important;\n}\n\n.react-grid-Cell.editing .has-error input {\n  border: 2px red solid !important;\n  border-radius: 2px !important;\n}\n\n.react-grid-Cell__value ul {\n  margin-top: 0;\n  margin-bottom: 0;\n  display: inline-block;\n}\n\n.react-grid-Cell__value .btn-sm {\n  padding: 0;\n}\n\n.cell-tooltip .cell-tooltip-text {\n    white-space: normal;\n    visibility: hidden;\n    width: 150px;\n    background-color: black;\n    color: #fff;\n    text-align: center;\n    border-radius: 6px;\n    padding: 5px 0;\n    position: absolute;\n    top: 50%;\n    bottom: initial;\n    left: 50%;\n    margin-top: 15px;\n    margin-left: -75px\n}\n\n.cell-tooltip:hover .cell-tooltip-text {\n    visibility: visible;\n    opacity: 0.8;\n}\n\n.cell-tooltip .cell-tooltip-text::after {\n    content: " ";\n    position: absolute;\n    bottom: 100%;  /* At the top of the tooltip */\n    left: 50%;\n    margin-left: -5px;\n    border-width: 5px;\n    border-style: solid;\n    border-color: transparent transparent black transparent;\n}\n\n.react-grid-Canvas.opaque .react-grid-Cell.cell-tooltip:hover .cell-tooltip-text {\n    visibility: hidden;\n}\n\n.rdg-cell-expand {\n    float: right;\n    display: table;\n    height: 100%;\n}\n\n.rdg-cell-expand > span {\n  display: table-cell;\n  vertical-align: middle;\n  cursor: pointer;\n}\n\n.rdg-child-row-action-cross:before, rdg-child-row-action-cross:after, .rdg-child-row-action-cross-last:before, rdg-child-row-action-cross-last:after {\n  content: "";\n  position: absolute;\n  background: grey;\n  height: 50%;\n}\n\n.rdg-child-row-action-cross:before {\n  left: 21px;\n  width: 1px;\n  height: 100%;\n}\n\n.rdg-child-row-action-cross-last:before {\n  left: 21px;\n  width: 1px;\n}\n\n.rdg-child-row-action-cross:after, .rdg-child-row-action-cross-last:after {\n  top: 50%;\n  left:20px;\n  height: 1px;\n  width: 15px;\n  content: "";\n  position: absolute;\n  background: grey;\n}\n\n.rdg-child-row-action-cross:hover {\n    background: red;\n}\n.rdg-child-row-btn {\n   position:absolute;\n   cursor:pointer;\n   border:1px solid grey;\n   border-radius:14px;\n   z-index: 2;\n   background: white;\n}\n\n.rdg-child-row-btn div {\n  font-size: 12px;\n  text-align:center;\n  line-height:19px;\n  color: grey;\n  height:20px;\n  width:20px;\n  position:absolute;\n  top:60%;\n  left:53%;\n  margin-top:-10px;\n  margin-left:-10px;\n\n}\n\n.rdg-empty-child-row:hover .glyphicon-plus-sign {\n  color: green;\n}\n\n.rdg-empty-child-row:hover a {\n  color: green;\n}\n\n.rdg-child-row-btn .glyphicon-remove-sign:hover {\n  color: red;\n}\n\n.last-column .cell-tooltip-text{\n  right: 100%;\n  left: 0% !important;\n}\n\n.rdg-cell-action {\n  float: right;\n  height: 100%;\n}\n\n.rdg-cell-action-last {\n  margin-right: -8px;\n}\n\n.rdg-cell-action-button {\n  width: 35px;\n  height: 100%;\n  text-align: center;\n  position: relative;\n  display: table;\n  color: #4a9de2;\n}\n\n.rdg-cell-action-button > span {\n  display: table-cell;\n  vertical-align: middle;\n}\n\n.rdg-cell-action-button:hover, .rdg-cell-action-button-toggled {\n  color: #447bbb;\n}\n\n.rdg-cell-action-menu {\n  position: absolute;\n  top: 100%;\n  z-index: 1000;\n  float: left;\n  min-width: 160px;\n  padding: 5px 0;\n  text-align: left;\n  list-style: none;\n  background-color: #fff;\n  -webkit-background-clip: padding-box;\n  background-clip: padding-box;\n  border: 1px solid #ccc;\n  box-shadow: 0 0 3px 0 #ccc;\n}\n\n.rdg-cell-action-menu > span {\n  display: block;\n  padding: 3px 10px;\n  clear: both;\n  font-weight: 400;\n  line-height: 1.42857143;\n  color: #333;\n  white-space: nowrap;\n}\n\n.rdg-cell-action-menu > span:hover {\n  color: #262626;\n  text-decoration: none;\n  background-color: #f5f5f5;\n}\n', ""]);
      }, function(e2, t2, n) {
        (e2.exports = n(26)(false)).push([e2.i, '.react-grid-Row:hover .react-grid-Cell,\n.react-grid-Row.row-context-menu .react-grid-Cell {\n  background-color: #f9f9f9;\n}\n\n.react-grid-Row:hover .rdg-row-index {\n  display: none;\n}\n\n.react-grid-Row:hover .rdg-actions-checkbox {\n  display: block;\n}\n\n.react-grid-Row:hover .rdg-drag-row-handle {\n  cursor: move; /* fallback if grab cursor is unsupported */\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n  width: 12px;\n  height: 30px;\n  margin-left: 0px;\n  background-image: url("data:image/svg+xml;base64, PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjlweCIgaGVpZ2h0PSIyOXB4IiB2aWV3Qm94PSIwIDAgOSAyOSIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggMzkgKDMxNjY3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5kcmFnIGljb248L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iQWN0dWFsaXNhdGlvbi12MiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkRlc2t0b3AiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNS4wMDAwMDAsIC0yNjIuMDAwMDAwKSIgZmlsbD0iI0Q4RDhEOCI+CiAgICAgICAgICAgIDxnIGlkPSJJbnRlcmFjdGlvbnMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1LjAwMDAwMCwgMjU4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJvdy1Db250cm9scyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDIuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9ImRyYWctaWNvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDIuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMTIiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iNyIgY3k9IjEyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC0zMCIgY3g9IjIiIGN5PSIxNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iMTciIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iMiIgY3k9IjIyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC0zMCIgY3g9IjciIGN5PSIyMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMjciIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iNyIgY3k9IjI3IiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==");\n  background-repeat: no-repeat;\n}\n\n.react-grid-Row.row-selected{\n background-color: #DBECFA;\n}\n\n.react-grid-Row .row-selected{\n background-color: #DBECFA;\n}\n\n.react-grid-row-group .row-expand-icon:hover {\n  color: #777777;\n}\n\n.react-grid-row-index {\n    padding: 0 18px;\n}\n\n.rdg-row-index {\n  display: block;\n  text-align: center;\n}\n\n.rdg-row-actions-cell {\n  padding: 0px;\n}\n\n.rdg-actions-checkbox {\n  display: none;\n  text-align: center;\n}\n\n.rdg-actions-checkbox.selected {\n  display: block;\n}\n\n.rdg-dragging {\n    /*cursor: url(http://www.google.com/intl/en_ALL/mapfiles/closedhand.cur);*/\n    cursor: -webkit-grabbing;\n    cursor: -moz-grabbing;\n    cursor: grabbing;\n}\n\n.rdg-dragged-row {\n  border-bottom: 1px solid black\n}\n\n.rdg-scrolling {\n  pointer-events: none;\n}\n', ""]);
      }, function(e2, t2, n) {
        (e2.exports = n(26)(false)).push([e2.i, ".react-grid-checkbox, .radio-custom {\n    opacity: 0;\n    position: absolute;\n}\n\n.react-grid-checkbox, .react-grid-checkbox-label, .radio-custom, .radio-custom-label {\n    display: inline-block;\n    vertical-align: middle;\n    cursor: pointer;\n}\n\n.react-grid-checkbox-label, .radio-custom-label {\n    position: relative;\n}\n\n.react-grid-checkbox + .react-grid-checkbox-label:before, .radio-custom + .radio-custom-label:before {\n    content: '';\n    background: #fff;\n    border: 2px solid #ddd;\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    text-align: center;\n}\n\n.react-grid-checkbox:checked + .react-grid-checkbox-label:before {\n    background: #005295;\n    box-shadow: inset 0px 0px 0px 4px #fff;\n}\n\n.react-grid-checkbox:focus + .react-grid-checkbox-label, .radio-custom:focus + .radio-custom-label {\n  outline: 1px solid #ddd; /* focus style */\n}\n\n.react-grid-HeaderCell input[type='checkbox'] {\n  z-index: 99999;\n}\n.react-grid-HeaderCell > .react-grid-checkbox-container {\n    padding: 0px 10px;\n    height: 100%\n}\n\n\n.react-grid-HeaderCell > .react-grid-checkbox-container > .react-grid-checkbox-label {\n   margin : 0;\n   position: relative;\n   top: 50%;\n   transform: translateY(-50%);\n}\n.radio-custom + .radio-custom-label:before {\n    border-radius: 50%;\n}\n\n.radio-custom:checked + .radio-custom-label:before {\n    background: #ccc;\n    box-shadow: inset 0px 0px 0px 4px #fff;\n}\n\n.checkbox-align {\n    text-align: center;\n}\n", ""]);
      }, , function(e2, t2, n) {
        "use strict";
        e2.exports = function o(e3) {
          var t3 = {};
          for (var n2 in e3)
            e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          return t3;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(128)), l = o(n(209)), a = n(25), i = o(n(89)), u = n(18);
        var d = function e3(t3) {
          return t3.reduce(function(e4, t4) {
            return e4 + t4.width;
          }, 0);
        };
        function s(e3) {
          var t3 = function n2(e4, t4) {
            return e4.map(function(e5) {
              var n3 = Object.assign({}, e5);
              return e5.width && /^([0-9]+)%$/.exec(e5.width.toString()) && (n3.width = Math.floor(e5.width / 100 * t4)), n3;
            });
          }(e3.columns, e3.totalWidth), o2 = t3.filter(function(e4) {
            return e4.width;
          }).reduce(function(e4, t4) {
            return e4 - t4.width;
          }, e3.totalWidth);
          o2 -= (0, i.default)();
          var r2 = t3.filter(function(e4) {
            return e4.width;
          }).reduce(function(e4, t4) {
            return e4 + t4.width;
          }, 0), l2 = (t3 = function s2(e4) {
            var t4 = 0;
            return e4.map(function(e5) {
              return e5.left = t4, t4 += e5.width, e5;
            });
          }(t3 = function u2(e4, t4, n2) {
            var o3 = e4.filter(function(e5) {
              return !e5.width;
            });
            return e4.map(function(e5) {
              if (!e5.width && 0 !== e5.width)
                if (t4 <= 0)
                  e5.width = n2;
                else {
                  var r3 = Math.floor(t4 / (0, a.getSize)(o3));
                  e5.width = r3 < n2 ? n2 : r3;
                }
              return e5;
            });
          }(t3, o2, e3.minColumnWidth))).filter(function(e4) {
            return (0, a.isFrozen)(e4);
          }), c = t3.filter(function(e4) {
            return !(0, a.isFrozen)(e4);
          });
          return { columns: t3 = l2.concat(c).map(function(e4, t4) {
            return e4.idx = t4, e4;
          }), width: r2, totalWidth: e3.totalWidth, totalColumnWidth: d(t3), minColumnWidth: e3.minColumnWidth };
        }
        e2.exports = { recalculate: s, resizeColumn: function c(e3, t3, n2) {
          var o2 = (0, a.getColumn)(e3.columns, t3), l2 = (0, r.default)(e3);
          l2.columns = e3.columns.slice(0);
          var i2 = (0, r.default)(o2);
          return i2.width = Math.max(n2, l2.minColumnWidth), s(l2 = (0, a.spliceColumn)(l2, t3, i2));
        }, sameColumn: l.default, sameColumns: function f(e3, t3, n2) {
          return function o2(e4, t4) {
            return (0, u.isColumnsImmutable)(e4) && (0, u.isColumnsImmutable)(t4);
          }(e3, t3) ? e3 === t3 : function r2(e4, t4, n3) {
            var o2, r3, l2, i2 = {}, u2 = {};
            if ((0, a.getSize)(e4) !== (0, a.getSize)(t4))
              return false;
            for (o2 = 0, r3 = (0, a.getSize)(e4); o2 < r3; o2++)
              i2[(l2 = e4[o2]).key] = l2;
            for (o2 = 0, r3 = (0, a.getSize)(t4); o2 < r3; o2++) {
              u2[(l2 = t4[o2]).key] = l2;
              var d2 = i2[l2.key];
              if (void 0 === d2 || !n3(d2, l2))
                return false;
            }
            for (o2 = 0, r3 = (0, a.getSize)(e4); o2 < r3; o2++)
              if (void 0 === u2[(l2 = e4[o2]).key])
                return false;
            return true;
          }(e3, t3, n2);
        } };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(1)), f = o(n(20)), p = o(n(10)), g = o(n(49)), h = o(n(41)), m = n(25), w = n(29), C = n(212);
        n(58);
        var v = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "state", { resizing: false }), (0, s.default)((0, u.default)(n2), "headerCellRef", function(e5) {
              return n2.headerCell = e5;
            }), (0, s.default)((0, u.default)(n2), "onDragStart", function(e5) {
              n2.setState({ resizing: true }), e5 && e5.dataTransfer && e5.dataTransfer.setData && e5.dataTransfer.setData("text/plain", "dummy");
            }), (0, s.default)((0, u.default)(n2), "onDrag", function(e5) {
              var t4 = n2.props.onResize || null;
              if (t4) {
                var o3 = n2.getWidthFromMouseEvent(e5);
                o3 > 0 && t4(n2.props.column, o3);
              }
            }), (0, s.default)((0, u.default)(n2), "onDragEnd", function(e5) {
              var t4 = n2.getWidthFromMouseEvent(e5);
              n2.props.onResizeEnd(n2.props.column, t4), n2.setState({ resizing: false });
            }), (0, s.default)((0, u.default)(n2), "getWidthFromMouseEvent", function(e5) {
              return (e5.pageX || e5.touches && e5.touches[0] && e5.touches[0].pageX || e5.changedTouches && e5.changedTouches[e5.changedTouches.length - 1].pageX) - f.default.findDOMNode((0, u.default)(n2)).getBoundingClientRect().left;
            }), (0, s.default)((0, u.default)(n2), "getCell", function() {
              var e5 = n2.props, t4 = e5.height, o3 = e5.column, r2 = e5.renderer;
              return c.default.isValidElement(r2) ? "string" === typeof n2.props.renderer.type ? c.default.cloneElement(r2, { height: t4 }) : c.default.cloneElement(r2, { column: o3, height: t4 }) : n2.props.renderer({ column: o3 });
            }), (0, s.default)((0, u.default)(n2), "getStyle", function() {
              return { width: n2.props.column.width, left: n2.props.column.left, display: "inline-block", position: "absolute", height: n2.props.height, margin: 0, textOverflow: "ellipsis", whiteSpace: "nowrap" };
            }), (0, s.default)((0, u.default)(n2), "setScrollLeft", function(e5) {
              var t4 = f.default.findDOMNode((0, u.default)(n2));
              t4 && (t4.style.webkitTransform = "translate3d(".concat(e5, "px, 0px, 0px)"), t4.style.transform = "translate3d(".concat(e5, "px, 0px, 0px)"));
            }), (0, s.default)((0, u.default)(n2), "removeScroll", function() {
              var e5 = f.default.findDOMNode((0, u.default)(n2));
              if (e5) {
                e5.style.webkitTransform = "none", e5.style.transform = "none";
              }
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "render", value: function e4() {
            var t4 = this.props, n2 = t4.column, o2 = t4.rowType, r2 = n2.resizable && c.default.createElement(C, { onDrag: this.onDrag, onDragStart: this.onDragStart, onDragEnd: this.onDragEnd }), l2 = (0, g.default)({ "react-grid-HeaderCell": true, "react-grid-HeaderCell--resizing": this.state.resizing, "react-grid-HeaderCell--frozen": (0, m.isFrozen)(n2) }, this.props.className, n2.cellClass), a2 = c.default.createElement("div", { ref: this.headerCellRef, className: l2, style: this.getStyle() }, this.getCell(), r2);
            if (o2 === w.HeaderRowType.HEADER && n2.draggable) {
              var i2 = this.props.draggableHeaderCell;
              return c.default.createElement(i2, { column: n2, onHeaderDrop: this.props.onHeaderDrop }, a2);
            }
            return a2;
          } }]), t3;
        }(c.default.Component);
        (0, s.default)(v, "propTypes", { renderer: p.default.oneOfType([p.default.func, p.default.element]).isRequired, column: p.default.shape(h.default).isRequired, rowType: p.default.string.isRequired, height: p.default.number.isRequired, onResize: p.default.func.isRequired, onResizeEnd: p.default.func.isRequired, onHeaderDrop: p.default.func, draggableHeaderCell: p.default.oneOfType([p.default.func, p.default.element]), className: p.default.string }), (0, s.default)(v, "defaultProps", { renderer: function b(e3) {
          var t3 = "header" === e3.column.rowType ? e3.column.name : "";
          return c.default.createElement("div", { className: "widget-HeaderCell__value" }, t3);
        } }), e2.exports = v;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(10)), f = n(1), p = n(132), g = { ASC: "ASC", DESC: "DESC", NONE: "NONE" }, h = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "onClick", function() {
              var e5, t4 = n2.props, o3 = t4.sortDirection, r2 = t4.sortDescendingFirst;
              switch (o3) {
                default:
                case null:
                case void 0:
                case g.NONE:
                  e5 = r2 ? g.DESC : g.ASC;
                  break;
                case g.ASC:
                  e5 = r2 ? g.NONE : g.DESC;
                  break;
                case g.DESC:
                  e5 = r2 ? g.ASC : g.NONE;
              }
              n2.props.onSort(n2.props.columnKey, e5);
            }), (0, s.default)((0, u.default)(n2), "getSortByText", function() {
              return "NONE" === n2.props.sortDirection ? "" : String.fromCharCode({ ASC: "9650", DESC: "9660" }[n2.props.sortDirection]);
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "render", value: function e4() {
            var t4 = p({ "react-grid-HeaderCell-sortable": true, "react-grid-HeaderCell-sortable--ascending": "ASC" === this.props.sortDirection, "react-grid-HeaderCell-sortable--descending": "DESC" === this.props.sortDirection }), n2 = this.props.headerRenderer ? f.cloneElement(this.props.headerRenderer, this.props) : this.props.column.name;
            return f.createElement("div", { className: t4, onClick: this.onClick, style: { cursor: "pointer" } }, f.createElement("span", { className: "pull-right" }, this.getSortByText()), n2);
          } }]), t3;
        }(f.Component);
        (0, s.default)(h, "propTypes", { columnKey: c.default.string.isRequired, column: c.default.shape({ name: c.default.node }), onSort: c.default.func.isRequired, sortDirection: c.default.oneOf(Object.keys(g)), headerRenderer: c.default.node, sortDescendingFirst: c.default.bool }), e2.exports = h, e2.exports.DEFINE_SORT = g;
      }, function(e2, t2, n) {
        var o;
        !function() {
          "use strict";
          var n2 = {}.hasOwnProperty;
          function r() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) {
              var o2 = arguments[t3];
              if (o2) {
                var l = typeof o2;
                if ("string" === l || "number" === l)
                  e3.push(o2);
                else if (Array.isArray(o2) && o2.length) {
                  var a = r.apply(null, o2);
                  a && e3.push(a);
                } else if ("object" === l)
                  for (var i in o2)
                    n2.call(o2, i) && o2[i] && e3.push(i);
              }
            }
            return e3.join(" ");
          }
          e2.exports ? (r.default = r, e2.exports = r) : void 0 === (o = function() {
            return r;
          }.apply(t2, [])) || (e2.exports = o);
        }();
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(4)), a = o(n(5)), i = o(n(7)), u = o(n(8)), d = o(n(13)), s = o(n(9)), c = o(n(11)), f = o(n(62)), p = o(n(1)), g = o(n(10)), h = o(n(49)), m = o(n(134)), w = o(n(57)), C = n(25);
        n(63);
        var v = ["height"], b = function(e3) {
          function t3() {
            var e4, n2;
            (0, l.default)(this, t3);
            for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
              a2[s2] = arguments[s2];
            return n2 = (0, i.default)(this, (e4 = (0, u.default)(t3)).call.apply(e4, [this].concat(a2))), (0, c.default)((0, d.default)(n2), "handleDragEnter", function(e5) {
              e5.preventDefault();
              var t4 = n2.props, o3 = t4.idx;
              (0, t4.cellMetaData.onDragEnter)({ overRowIdx: o3 });
            }), (0, c.default)((0, d.default)(n2), "handleDragOver", function(e5) {
              e5.preventDefault(), e5.dataTransfer.dropEffect = "copy";
            }), (0, c.default)((0, d.default)(n2), "handleDrop", function(e5) {
              e5.preventDefault();
            }), (0, c.default)((0, d.default)(n2), "getCell", function(e5) {
              var t4 = n2.props.cellRenderer, o3 = n2.props, l2 = o3.idx, a3 = o3.cellMetaData, i2 = o3.isScrolling, u2 = o3.row, d2 = o3.isSelected, s3 = o3.scrollLeft, c2 = o3.lastFrozenColumnIndex, f2 = e5.key, g2 = e5.formatter, h3 = { key: "".concat(f2, "-").concat(l2), idx: e5.idx, rowIdx: l2, height: n2.getRowHeight(), column: e5, cellMetaData: a3 }, m2 = { ref: function e6(t5) {
                n2[f2] = t5;
              }, value: n2.getCellValue(f2 || e5.idx), rowData: u2, isRowSelected: d2, expandableOptions: n2.getExpandableOptions(f2), formatter: g2, isScrolling: i2, scrollLeft: s3, lastFrozenColumnIndex: c2 };
              return p.default.createElement(t4, (0, r.default)({}, h3, m2));
            }), (0, c.default)((0, d.default)(n2), "getCells", function() {
              var e5 = n2.props, t4 = e5.colOverscanStartIdx, o3 = e5.colOverscanEndIdx, r2 = e5.columns, l2 = r2.filter(function(e6) {
                return (0, C.isFrozen)(e6);
              });
              return r2.slice(t4, o3 + 1).filter(function(e6) {
                return !(0, C.isFrozen)(e6);
              }).concat(l2).map(function(e6) {
                return n2.getCell(e6);
              });
            }), (0, c.default)((0, d.default)(n2), "getRowTop", function() {
              if (n2.row)
                return n2.row.offsetTop;
            }), (0, c.default)((0, d.default)(n2), "getRowHeight", function() {
              var e5 = n2.props.expandedRows || null;
              if (e5 && n2.props.idx) {
                var t4 = e5[n2.props.idx] || null;
                if (t4)
                  return t4.height;
              }
              return n2.props.height;
            }), (0, c.default)((0, d.default)(n2), "getCellValue", function(e5) {
              return "select-row" === e5 ? n2.props.isSelected : "function" === typeof n2.props.row.get ? n2.props.row.get(e5) : n2.props.row[e5];
            }), (0, c.default)((0, d.default)(n2), "getExpandableOptions", function(e5) {
              var t4 = n2.props.subRowDetails;
              return t4 ? { canExpand: t4 && t4.field === e5 && (t4.children && t4.children.length > 0 || true === t4.group), field: t4.field, expanded: t4 && t4.expanded, children: t4 && t4.children, treeDepth: t4 ? t4.treeDepth : 0, subRowDetails: t4 } : {};
            }), (0, c.default)((0, d.default)(n2), "setScrollLeft", function(e5) {
              n2.props.columns.forEach(function(t4) {
                if ((0, C.isFrozen)(t4)) {
                  if (!n2[t4.key])
                    return;
                  n2[t4.key].setScrollLeft(e5);
                }
              });
            }), (0, c.default)((0, d.default)(n2), "setRowRef", function(e5) {
              n2.row = e5;
            }), (0, c.default)((0, d.default)(n2), "getKnownDivProps", function() {
              return (0, w.default)(n2.props, v);
            }), n2;
          }
          return (0, s.default)(t3, e3), (0, a.default)(t3, [{ key: "shouldComponentUpdate", value: function e4(t4) {
            return (0, f.default)(t4, this.props);
          } }, { key: "render", value: function e4() {
            var t4 = (0, h.default)("react-grid-Row", "react-grid-Row--".concat(this.props.idx % 2 === 0 ? "even" : "odd"), { "row-selected": this.props.isSelected }, this.props.extraClasses, { "rdg-scrolling": this.props.isScrolling }), n2 = { height: this.getRowHeight(this.props), overflow: "hidden" };
            this.getCells();
            return p.default.createElement("div", (0, r.default)({}, this.getKnownDivProps(), { ref: this.setRowRef, className: t4, style: n2, onDragEnter: this.handleDragEnter, onDragOver: this.handleDragOver, onDrop: this.handleDrop }), this.getCells());
          } }]), t3;
        }(p.default.Component);
        (0, c.default)(b, "displayName", "Row"), (0, c.default)(b, "propTypes", { height: g.default.number.isRequired, columns: g.default.oneOfType([g.default.object, g.default.array]).isRequired, row: g.default.object.isRequired, cellRenderer: g.default.func, cellMetaData: g.default.object, isSelected: g.default.bool, idx: g.default.number.isRequired, expandedRows: g.default.arrayOf(g.default.object), extraClasses: g.default.string, forceUpdate: g.default.bool, subRowDetails: g.default.object, isRowHovered: g.default.bool, colVisibleStartIdx: g.default.number.isRequired, colVisibleEndIdx: g.default.number.isRequired, colOverscanStartIdx: g.default.number.isRequired, colOverscanEndIdx: g.default.number.isRequired, isScrolling: g.default.bool.isRequired, scrollLeft: g.default.number, lastFrozenColumnIndex: g.default.number }), (0, c.default)(b, "defaultProps", { cellRenderer: m.default, isSelected: false, height: 35 });
        var y = b;
        t2.default = y;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(47)), a = o(n(4)), i = o(n(5)), u = o(n(7)), d = o(n(8)), s = o(n(13)), c = o(n(9)), f = o(n(11)), p = o(n(1)), g = o(n(10)), h = o(n(49)), m = n(18), w = o(n(135)), C = o(n(57)), v = o(n(220)), b = o(n(221)), y = o(n(222)), R = n(25);
        n(113);
        var x = ["height", "value"], S = function(e3) {
          function t3() {
            var e4, n2;
            (0, a.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), i2 = 0; i2 < o2; i2++)
              r2[i2] = arguments[i2];
            return n2 = (0, u.default)(this, (e4 = (0, d.default)(t3)).call.apply(e4, [this].concat(r2))), (0, f.default)((0, s.default)(n2), "state", { isCellValueChanging: false, isLockChanging: false }), (0, f.default)((0, s.default)(n2), "onCellClick", function() {
              var e5 = n2.props, t4 = e5.idx, o3 = e5.rowIdx, r3 = e5.cellMetaData;
              (0, m.isFunction)(r3.onCellClick) && r3.onCellClick({ idx: t4, rowIdx: o3 });
            }), (0, f.default)((0, s.default)(n2), "onCellMouseDown", function() {
              var e5 = n2.props, t4 = e5.idx, o3 = e5.rowIdx, r3 = e5.cellMetaData;
              (0, m.isFunction)(r3.onCellMouseDown) && r3.onCellMouseDown({ idx: t4, rowIdx: o3 });
            }), (0, f.default)((0, s.default)(n2), "onCellMouseEnter", function() {
              var e5 = n2.props, t4 = e5.idx, o3 = e5.rowIdx, r3 = e5.cellMetaData;
              (0, m.isFunction)(r3.onCellMouseEnter) && r3.onCellMouseEnter({ idx: t4, rowIdx: o3 });
            }), (0, f.default)((0, s.default)(n2), "onCellContextMenu", function() {
              var e5 = n2.props, t4 = e5.idx, o3 = e5.rowIdx, r3 = e5.cellMetaData;
              (0, m.isFunction)(r3.onCellContextMenu) && r3.onCellContextMenu({ idx: t4, rowIdx: o3 });
            }), (0, f.default)((0, s.default)(n2), "onCellDoubleClick", function(e5) {
              e5.stopPropagation();
              var t4 = n2.props, o3 = t4.idx, r3 = t4.rowIdx, l2 = t4.cellMetaData;
              (0, m.isFunction)(l2.onCellDoubleClick) && l2.onCellDoubleClick({ idx: o3, rowIdx: r3 });
            }), (0, f.default)((0, s.default)(n2), "onCellExpand", function(e5) {
              e5.stopPropagation();
              var t4 = n2.props.cellMetaData;
              null != t4 && null != t4.onCellExpand && t4.onCellExpand({ rowIdx: n2.props.rowIdx, idx: n2.props.idx, rowData: n2.props.rowData, expandArgs: n2.props.expandableOptions });
            }), (0, f.default)((0, s.default)(n2), "onCellKeyDown", function(e5) {
              n2.canExpand() && "Enter" === e5.key && n2.onCellExpand(e5);
            }), (0, f.default)((0, s.default)(n2), "onDeleteSubRow", function() {
              var e5 = n2.props.cellMetaData;
              null != e5 && null != e5.onDeleteSubRow && e5.onDeleteSubRow({ rowIdx: n2.props.rowIdx, idx: n2.props.idx, rowData: n2.props.rowData, expandArgs: n2.props.expandableOptions });
            }), (0, f.default)((0, s.default)(n2), "onDragOver", function(e5) {
              e5.preventDefault();
            }), (0, f.default)((0, s.default)(n2), "getStyle", function() {
              return { position: "absolute", width: n2.props.column.width, height: n2.props.height, left: n2.props.column.left };
            }), (0, f.default)((0, s.default)(n2), "getFormatter", function() {
              return n2.props.column.formatter;
            }), (0, f.default)((0, s.default)(n2), "getRowData", function() {
              var e5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n2.props;
              return e5.rowData.toJSON ? e5.rowData.toJSON() : e5.rowData;
            }), (0, f.default)((0, s.default)(n2), "getFormatterDependencies", function() {
              if ("function" === typeof n2.props.column.getRowMetaData)
                return n2.props.column.getRowMetaData(n2.getRowData(), n2.props.column);
            }), (0, f.default)((0, s.default)(n2), "getCellClass", function() {
              var e5 = n2.props, t4 = e5.idx, o3 = e5.lastFrozenColumnIndex, r3 = (0, h.default)(n2.props.column.cellClass, "react-grid-Cell", n2.props.className, (0, R.isFrozen)(n2.props.column) ? "react-grid-Cell--frozen" : null, o3 === t4 ? "rdg-last--frozen" : null), l2 = (0, h.default)({ "row-selected": n2.props.isRowSelected, editing: n2.isEditorEnabled(), "has-tooltip": !!n2.props.tooltip, "rdg-child-cell": n2.props.expandableOptions && n2.props.expandableOptions.subRowDetails && n2.props.expandableOptions.treeDepth > 0, "last-column": n2.props.column.isLastColumn });
              return (0, h.default)(r3, l2);
            }), (0, f.default)((0, s.default)(n2), "getUpdateCellClass", function() {
              return n2.props.column.getUpdateCellClass ? n2.props.column.getUpdateCellClass(n2.props.selectedColumn, n2.props.column, n2.state.isCellValueChanging) : "";
            }), (0, f.default)((0, s.default)(n2), "isEditorEnabled", function() {
              return true === n2.props.isEditorEnabled;
            }), (0, f.default)((0, s.default)(n2), "setScrollLeft", function(e5) {
              var t4 = n2.node;
              if (t4) {
                var o3 = "translate3d(".concat(e5, "px, 0px, 0px)");
                t4.style.webkitTransform = o3, t4.style.transform = o3;
              }
            }), (0, f.default)((0, s.default)(n2), "removeScroll", function() {
              var e5 = n2.node;
              e5 && (e5.style.webkitTransform = null, e5.style.transform = null);
            }), (0, f.default)((0, s.default)(n2), "canExpand", function() {
              return n2.props.expandableOptions && n2.props.expandableOptions.canExpand;
            }), (0, f.default)((0, s.default)(n2), "createColumEventCallBack", function(e5, t4) {
              return function(n3) {
                e5(n3, t4);
              };
            }), (0, f.default)((0, s.default)(n2), "createCellEventCallBack", function(e5, t4) {
              return function(n3) {
                e5(n3), t4(n3);
              };
            }), (0, f.default)((0, s.default)(n2), "createEventDTO", function(e5, t4, o3) {
              var r3 = Object.assign({}, e5);
              for (var l2 in t4)
                if (t4.hasOwnProperty(l2)) {
                  var a2 = { idx: n2.props.idx, rowIdx: n2.props.rowIdx, rowId: n2.props.rowData[n2.props.cellMetaData.rowKey], name: l2 }, i3 = n2.createColumEventCallBack(o3, a2);
                  if (r3.hasOwnProperty(l2)) {
                    var u2 = r3[l2];
                    r3[l2] = n2.createCellEventCallBack(u2, i3);
                  } else
                    r3[l2] = i3;
                }
              return r3;
            }), (0, f.default)((0, s.default)(n2), "getEvents", function() {
              var e5 = n2.props.column ? Object.assign({}, n2.props.column.events) : void 0, t4 = n2.props.cellMetaData ? n2.props.cellMetaData.onColumnEvent : void 0, o3 = { onClick: n2.onCellClick, onMouseDown: n2.onCellMouseDown, onMouseEnter: n2.onCellMouseEnter, onDoubleClick: n2.onCellDoubleClick, onContextMenu: n2.onCellContextMenu, onDragOver: n2.onDragOver };
              return e5 && t4 ? n2.createEventDTO(o3, e5, t4) : o3;
            }), (0, f.default)((0, s.default)(n2), "getKnownDivProps", function() {
              return (0, C.default)(n2.props, x);
            }), (0, f.default)((0, s.default)(n2), "setCellRef", function(e5) {
              n2.node = e5;
            }), (0, f.default)((0, s.default)(n2), "renderCellContent", function(e5) {
              var t4, o3 = n2.getFormatter();
              t4 = p.default.isValidElement(o3) ? p.default.cloneElement(o3, (0, l.default)({}, e5, { dependentValues: n2.getFormatterDependencies(), row: n2.getRowData() })) : (0, m.isFunction)(o3) ? p.default.createElement(o3, { value: n2.props.value, dependentValues: n2.getFormatterDependencies(), isScrolling: n2.props.isScrolling, row: n2.getRowData() }) : p.default.createElement(w.default, { value: n2.props.value });
              var r3, a2 = !!n2.props.expandableOptions && n2.props.expandableOptions.field === n2.props.column.key, i3 = n2.props.expandableOptions ? n2.props.expandableOptions.treeDepth : 0, u2 = n2.props.expandableOptions && a2 ? 30 * n2.props.expandableOptions.treeDepth : 0, d2 = !!n2.props.cellMetaData.onDeleteSubRow;
              i3 > 0 && a2 && (r3 = p.default.createElement(y.default, { treeDepth: i3, cellHeight: n2.props.height, siblingIndex: n2.props.expandableOptions.subRowDetails.siblingIndex, numberSiblings: n2.props.expandableOptions.subRowDetails.numberSiblings, onDeleteSubRow: n2.onDeleteSubRow, isDeleteSubRowEnabled: d2 }));
              var s2 = n2.props.tooltip && p.default.createElement("span", { className: "cell-tooltip-text" }, n2.props.tooltip), c2 = (0, h.default)("react-grid-Cell__value", { "cell-tooltip": !!n2.props.tooltip });
              return p.default.createElement("div", { className: c2 }, r3, p.default.createElement("div", { style: { marginLeft: u2, position: "relative", top: "50%", transform: "translateY(-50%)" } }, p.default.createElement("span", null, t4), n2.props.cellControls), s2);
            }), n2;
          }
          return (0, c.default)(t3, e3), (0, i.default)(t3, [{ key: "componentWillReceiveProps", value: function e4(t4) {
            this.setState({ isCellValueChanging: this.props.isCellValueChanging(this.props.value, t4.value), isLockChanging: (0, R.isFrozen)(this.props.column) !== (0, R.isFrozen)(t4.column) });
          } }, { key: "componentDidMount", value: function e4() {
            this.checkScroll();
          } }, { key: "componentDidUpdate", value: function e4() {
            this.state.isLockChanging && !(0, R.isFrozen)(this.props.column) && this.removeScroll();
          } }, { key: "checkScroll", value: function e4() {
            var t4 = this.props, n2 = t4.scrollLeft, o2 = t4.column, r2 = this.node;
            (0, R.isFrozen)(o2) && r2 && null != r2.style.transform && this.setScrollLeft(n2);
          } }, { key: "getCellActions", value: function e4() {
            var t4 = this.props, n2 = t4.cellMetaData, o2 = t4.column, r2 = t4.rowData;
            if (n2 && n2.getCellActions) {
              var l2 = n2.getCellActions(o2, r2);
              return l2 && l2.length ? l2.map(function(e5, t5) {
                return p.default.createElement(v.default, { key: t5, action: e5, isFirst: 0 === t5 });
              }) : null;
            }
            return null;
          } }, { key: "render", value: function e4() {
            if (this.props.column.hidden)
              return null;
            var t4 = this.getStyle(), n2 = this.getCellClass(), o2 = this.getCellActions(), l2 = this.props, a2 = l2.value, i2 = l2.column, u2 = l2.rowIdx, d2 = l2.isExpanded, s2 = l2.isScrolling, c2 = this.props.children || this.renderCellContent({ value: a2, column: i2, rowIdx: u2, isExpanded: d2, isScrolling: s2 }), f2 = this.getEvents(), g2 = this.canExpand() && p.default.createElement(b.default, { expandableOptions: this.props.expandableOptions, onCellExpand: this.onCellExpand });
            return p.default.createElement("div", (0, r.default)({}, this.getKnownDivProps(), { className: n2, style: t4 }, f2, { ref: this.setCellRef }), o2, g2, c2);
          } }]), t3;
        }(p.default.PureComponent);
        (0, f.default)(S, "propTypes", { rowIdx: g.default.number.isRequired, idx: g.default.number.isRequired, isSelected: g.default.bool, wasPreviouslySelected: g.default.bool, isEditorEnabled: g.default.bool, selectedColumn: g.default.object, height: g.default.number, column: g.default.object.isRequired, value: g.default.oneOfType([g.default.string, g.default.number, g.default.object, g.default.bool]), isExpanded: g.default.bool, isRowSelected: g.default.bool, cellMetaData: g.default.object.isRequired, handleDragStart: g.default.func, className: g.default.string, cellControls: g.default.any, rowData: g.default.object.isRequired, forceUpdate: g.default.bool, expandableOptions: g.default.object.isRequired, tooltip: g.default.string, isScrolling: g.default.bool, isCellValueChanging: g.default.func, children: g.default.oneOfType([g.default.arrayOf(g.default.node), g.default.node]), scrollLeft: g.default.number.isRequired }), (0, f.default)(S, "defaultProps", { isExpanded: false, value: "", isCellValueChanging: function e3(t3, n2) {
          return t3 !== n2;
        } });
        var E = S;
        t2.default = E;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(9)), d = o(n(11)), s = o(n(1)), c = o(n(10)), f = function(e3) {
          function t3() {
            return (0, r.default)(this, t3), (0, a.default)(this, (0, i.default)(t3).apply(this, arguments));
          }
          return (0, u.default)(t3, e3), (0, l.default)(t3, [{ key: "shouldComponentUpdate", value: function e4(t4) {
            return t4.value !== this.props.value;
          } }, { key: "render", value: function e4() {
            return s.default.createElement("div", { title: this.props.value }, this.props.value);
          } }]), t3;
        }(s.default.Component);
        (0, d.default)(f, "propTypes", { value: c.default.oneOfType([c.default.string, c.default.number, c.default.object, c.default.bool]) });
        var p = f;
        t2.default = p;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(10)), l = { icon: r.default.oneOfType([r.default.string, r.default.element]).isRequired, callback: r.default.func, actions: r.default.arrayOf(r.default.shape({ text: r.default.string, callback: r.default.func })) };
        t2.default = l;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "EventBus", { enumerable: true, get: function e3() {
          return r.default;
        } }), Object.defineProperty(t2, "InteractionMasks", { enumerable: true, get: function e3() {
          return l.default;
        } });
        var r = o(n(225)), l = o(n(226));
      }, function(e2, t2, n) {
        "use strict";
        var o = n(19), r = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.canExitGrid = function l(e3, t3) {
          var n2 = t3.cellNavigationMode, o2 = t3.columns, r2 = t3.rowsCount, l2 = t3.selectedPosition, a = l2.rowIdx, i2 = l2.idx;
          if (n2 === u.CellNavigationMode.NONE || n2 === u.CellNavigationMode.CHANGE_ROW) {
            var d2 = i2 === o2.length - 1, s2 = 0 === i2, c2 = a === r2 - 1, f2 = 0 === a, p2 = true === e3.shiftKey;
            return p2 ? s2 && f2 : d2 && c2;
          }
          return false;
        }, t2.selectedRangeIsSingleCell = function a(e3) {
          return e3.topLeft.idx === e3.bottomRight.idx && e3.topLeft.rowIdx === e3.bottomRight.rowIdx;
        }, t2.getNextSelectedCellPosition = t2.isSelectedCellEditable = t2.getSelectedCellValue = t2.getSelectedColumn = t2.getSelectedRangeDimensions = t2.getSelectedDimensions = t2.getSelectedRow = t2.getRowTop = void 0;
        var i = r(n(47)), u = n(29), d = n(18), s = o(n(91)), c = n(25), f = o(n(139)), p = function e3(t3, n2) {
          return t3 * n2;
        };
        t2.getRowTop = p;
        var g = function e3(t3) {
          var n2 = t3.selectedPosition;
          return (0, t3.rowGetter)(n2.rowIdx);
        };
        t2.getSelectedRow = g;
        t2.getSelectedDimensions = function e3(t3) {
          var n2 = t3.selectedPosition, o2 = t3.columns, r2 = t3.rowHeight, l = t3.scrollLeft, a = n2.idx, i2 = n2.rowIdx;
          if (a >= 0) {
            var u2 = (0, c.getColumn)(o2, a), d2 = (0, c.isFrozen)(u2);
            return { width: u2.width, left: d2 ? u2.left + l : u2.left, top: p(i2, r2), height: r2, zIndex: d2 ? f.FROZEN_CELL_MASK : f.CELL_MASK };
          }
          return { width: 0, left: 0, top: 0, height: r2, zIndex: 1 };
        };
        t2.getSelectedRangeDimensions = function e3(t3) {
          var n2 = t3.selectedRange, o2 = t3.columns, r2 = t3.rowHeight, l = n2.topLeft, a = n2.bottomRight;
          if (l.idx < 0)
            return { width: 0, left: 0, top: 0, height: r2, zIndex: f.CELL_MASK };
          var i2 = function e4(t4, n3, o3) {
            for (var r3 = 0, l2 = false, a2 = t4; a2 <= n3; a2++) {
              var i3 = (0, c.getColumn)(o3, a2);
              r3 += i3.width, l2 = l2 || (0, c.isFrozen)(i3);
            }
            return { totalWidth: r3, anyColFrozen: l2, left: (0, c.getColumn)(o3, t4).left };
          }(l.idx, a.idx, o2), u2 = i2.totalWidth, d2 = i2.anyColFrozen;
          return { width: u2, left: i2.left, top: p(l.rowIdx, r2), height: (a.rowIdx - l.rowIdx + 1) * r2, zIndex: d2 ? f.FROZEN_CELL_MASK : f.CELL_MASK };
        };
        var h = function e3(t3) {
          var n2 = t3.selectedPosition, o2 = t3.columns, r2 = n2.idx;
          return (0, c.getColumn)(o2, r2);
        };
        t2.getSelectedColumn = h;
        t2.getSelectedCellValue = function e3(t3) {
          var n2 = t3.selectedPosition, o2 = t3.columns, r2 = t3.rowGetter, l = h({ selectedPosition: n2, columns: o2 }), a = g({ selectedPosition: n2, rowGetter: r2 });
          return a && l ? s.get(a, l.key) : null;
        };
        t2.isSelectedCellEditable = function e3(t3) {
          var n2 = t3.enableCellSelect, o2 = t3.selectedPosition, r2 = t3.columns, l = t3.rowGetter, a = t3.onCheckCellIsEditable, u2 = h({ selectedPosition: o2, columns: r2 }), s2 = g({ selectedPosition: o2, rowGetter: l }), f2 = !(0, d.isFunction)(a) || a((0, i.default)({ row: s2, column: u2 }, o2));
          return (0, c.canEdit)(u2, s2, n2) && f2;
        };
        t2.getNextSelectedCellPosition = function e3(t3, n2) {
          var o2 = t3.cellNavigationMode, r2 = t3.columns, l = t3.rowsCount;
          if (o2 !== u.CellNavigationMode.NONE) {
            var a = n2.idx, d2 = n2.rowIdx, s2 = -1 === a;
            if (a === r2.length) {
              if (o2 === u.CellNavigationMode.CHANGE_ROW) {
                if (d2 !== l - 1)
                  return { idx: 0, rowIdx: d2 + 1, changeRowOrColumn: true };
              } else if (o2 === u.CellNavigationMode.LOOP_OVER_ROW)
                return { rowIdx: d2, idx: 0, changeRowOrColumn: true };
            } else if (s2) {
              if (o2 === u.CellNavigationMode.CHANGE_ROW) {
                if (0 !== d2)
                  return { rowIdx: d2 - 1, idx: r2.length - 1, changeRowOrColumn: true };
              } else if (o2 === u.CellNavigationMode.LOOP_OVER_ROW)
                return { rowIdx: d2, idx: r2.length - 1, changeRowOrColumn: true };
            }
          }
          return (0, i.default)({}, n2, { changeRowOrColumn: false });
        };
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.EDITOR_CONTAINER = t2.FROZEN_CELL_MASK = t2.CELL_MASK = void 0;
        t2.CELL_MASK = 1;
        t2.FROZEN_CELL_MASK = 3;
        t2.EDITOR_CONTAINER = 2;
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isKeyPrintable = function o(e3) {
          return e3 > 47 && e3 < 58 || 32 === e3 || 13 === e3 || e3 > 64 && e3 < 91 || e3 > 95 && e3 < 112 || e3 > 185 && e3 < 193 || e3 > 218 && e3 < 223;
        }, t2.isCtrlKeyHeldDown = function r(e3) {
          return (true === e3.ctrlKey || true === e3.metaKey) && "Control" !== e3.key;
        };
      }, function(e2, t2, n) {
        "use strict";
        e2.exports = { Backspace: 8, Tab: 9, Enter: 13, Shift: 16, Ctrl: 17, Alt: 18, PauseBreak: 19, CapsLock: 20, Escape: 27, PageUp: 33, PageDown: 34, End: 35, Home: 36, LeftArrow: 37, UpArrow: 38, RightArrow: 39, DownArrow: 40, Insert: 45, Delete: 46, 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, a: 65, b: 66, c: 67, d: 68, e: 69, f: 70, g: 71, h: 72, i: 73, j: 74, k: 75, l: 76, m: 77, n: 78, o: 79, p: 80, q: 81, r: 82, s: 83, t: 84, u: 85, v: 86, w: 87, x: 88, y: 89, z: 90, LeftWindowKey: 91, RightWindowKey: 92, SelectKey: 93, NumPad0: 96, NumPad1: 97, NumPad2: 98, NumPad3: 99, NumPad4: 100, NumPad5: 101, NumPad6: 102, NumPad7: 103, NumPad8: 104, NumPad9: 105, Multiply: 106, Add: 107, Subtract: 109, DecimalPoint: 110, Divide: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F12: 123, NumLock: 144, ScrollLock: 145, SemiColon: 186, EqualSign: 187, Comma: 188, Dash: 189, Period: 190, ForwardSlash: 191, GraveAccent: 192, OpenBracket: 219, BackSlash: 220, CloseBracket: 221, SingleQuote: 222 };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(1)), l = o(n(10)), a = function e3(t3) {
          return r.default.createElement("div", { className: "react-grid-checkbox-container checkbox-align" }, r.default.createElement("input", { className: "react-grid-checkbox", type: "checkbox", name: "select-all-checkbox", id: "select-all-checkbox", ref: t3.inputRef, onChange: t3.onChange }), r.default.createElement("label", { htmlFor: "select-all-checkbox", className: "react-grid-checkbox-label" }));
        };
        a.propTypes = { onChange: l.default.func, inputRef: l.default.func };
        var i = a;
        t2.default = i;
      }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(205)), l = o(n(62)), a = o(n(134)), i = o(n(133)), u = o(n(241));
        e2.exports = r.default, e2.exports.Row = i.default, e2.exports.Cell = a.default, e2.exports.HeaderCell = n(130), e2.exports.RowComparer = l.default, e2.exports.EmptyChildRow = u.default, e2.exports.editors = n(64), e2.exports.formatters = n(242), e2.exports.shapes = n(114), e2.exports._constants = n(29), e2.exports._helpers = n(243);
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(16)), l = o(n(4)), a = o(n(5)), i = o(n(7)), u = o(n(8)), d = o(n(13)), s = o(n(9)), c = o(n(11)), f = o(n(1)), p = o(n(10)), g = n(206), h = o(n(207)), m = o(n(86)), w = o(n(91)), C = n(25), v = o(n(141)), b = n(18), y = o(n(142)), R = n(131), x = n(29), S = n(137), E = n(129);
        n(69), n(87), Object.assign || (Object.assign = n(240));
        var I = function e3(t3, n2) {
          return "".concat(t3, " has been deprecated and will be removed in a future version. Please use ").concat(n2, " instead");
        }, D = function(e3) {
          function t3(e4, n2) {
            var o2;
            (0, l.default)(this, t3), o2 = (0, i.default)(this, (0, u.default)(t3).call(this, e4, n2)), (0, c.default)((0, d.default)(o2), "selectCell", function(e5, t4) {
              var n3 = e5.idx, r3 = e5.rowIdx;
              o2.eventBus.dispatch(x.EventTypes.SELECT_CELL, { rowIdx: r3, idx: n3 }, t4);
            }), (0, c.default)((0, d.default)(o2), "selectStart", function(e5) {
              o2.eventBus.dispatch(x.EventTypes.SELECT_START, e5);
            }), (0, c.default)((0, d.default)(o2), "selectUpdate", function(e5) {
              o2.eventBus.dispatch(x.EventTypes.SELECT_UPDATE, e5);
            }), (0, c.default)((0, d.default)(o2), "selectEnd", function() {
              o2.eventBus.dispatch(x.EventTypes.SELECT_END);
            }), (0, c.default)((0, d.default)(o2), "handleDragEnter", function(e5) {
              var t4 = e5.overRowIdx;
              o2.eventBus.dispatch(x.EventTypes.DRAG_ENTER, { overRowIdx: t4 });
            }), (0, c.default)((0, d.default)(o2), "gridWidth", function() {
              return o2.grid ? o2.grid.parentElement.offsetWidth : 0;
            }), (0, c.default)((0, d.default)(o2), "getTotalWidth", function() {
              return o2._mounted ? o2.gridWidth() : (0, C.getSize)(o2.props.columns) * o2.props.minColumnWidth;
            }), (0, c.default)((0, d.default)(o2), "getColumnMetricsType", function(e5) {
              var t4 = e5.totalWidth || o2.getTotalWidth(), n3 = { columns: e5.columns, totalWidth: t4, minColumnWidth: e5.minColumnWidth };
              return E.recalculate(n3);
            }), (0, c.default)((0, d.default)(o2), "getColumn", function(e5) {
              var t4 = o2.state.columnMetrics.columns;
              return (0, C.getColumn)(t4, e5);
            }), (0, c.default)((0, d.default)(o2), "getSize", function() {
              var e5 = o2.state.columnMetrics.columns;
              return (0, C.getSize)(e5);
            }), (0, c.default)((0, d.default)(o2), "metricsUpdated", function() {
              var e5 = o2.createColumnMetrics();
              o2.setState({ columnMetrics: e5 });
            }), (0, c.default)((0, d.default)(o2), "createColumnMetrics", function() {
              var e5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o2.props, t4 = o2.setupGridColumns(e5);
              return o2.getColumnMetricsType({ columns: t4, minColumnWidth: o2.props.minColumnWidth, totalWidth: e5.minWidth });
            }), (0, c.default)((0, d.default)(o2), "onColumnResize", function(e5, t4) {
              var n3 = E.resizeColumn(o2.state.columnMetrics, e5, t4);
              o2.setState({ columnMetrics: n3 }), o2.props.onColumnResize && o2.props.onColumnResize(e5, t4);
            }), (0, c.default)((0, d.default)(o2), "onKeyDown", function(e5) {
              o2._keysDown = o2._keysDown || {}, o2._keysDown[e5.keyCode] = true;
              var t4 = o2.props.onGridKeyDown;
              (0, b.isFunction)(t4) && t4(e5);
            }), (0, c.default)((0, d.default)(o2), "onKeyUp", function(e5) {
              o2._keysDown = o2._keysDown || {}, delete o2._keysDown[e5.keyCode];
              var t4 = o2.props.onGridKeyUp;
              (0, b.isFunction)(t4) && t4(e5);
            }), (0, c.default)((0, d.default)(o2), "isSingleKeyDown", function(e5) {
              return !!o2._keysDown && (e5 in o2._keysDown && 1 === Object.keys(o2._keysDown).length);
            }), (0, c.default)((0, d.default)(o2), "onColumnEvent", function(e5, t4) {
              var n3 = t4.idx, r3 = t4.name;
              if (r3 && "undefined" !== typeof n3) {
                var l2 = o2.getColumn(n3);
                if (l2 && l2.events && (0, b.isFunction)(l2.events[r3])) {
                  var a2 = { idx: n3, rowIdx: t4.rowIdx, rowId: t4.rowId, column: l2 };
                  l2.events[r3](e5, a2);
                }
              }
            }), (0, c.default)((0, d.default)(o2), "onCellClick", function(e5) {
              var t4 = e5.rowIdx, n3 = e5.idx, r3 = o2.props, l2 = r3.onRowClick, a2 = r3.rowGetter;
              o2.selectCell({ rowIdx: t4, idx: n3 }), (0, b.isFunction)(l2) && l2(t4, a2(t4), o2.getColumn(n3));
            }), (0, c.default)((0, d.default)(o2), "onCellMouseDown", function(e5) {
              o2.selectStart(e5);
            }), (0, c.default)((0, d.default)(o2), "onCellMouseEnter", function(e5) {
              o2.selectUpdate(e5);
            }), (0, c.default)((0, d.default)(o2), "onWindowMouseUp", function() {
              o2.selectEnd();
            }), (0, c.default)((0, d.default)(o2), "onCellContextMenu", function(e5) {
              var t4 = e5.rowIdx, n3 = e5.idx;
              o2.selectCell({ rowIdx: t4, idx: n3 });
            }), (0, c.default)((0, d.default)(o2), "onCellDoubleClick", function(e5) {
              var t4 = e5.rowIdx, n3 = e5.idx, r3 = o2.props, l2 = r3.onRowDoubleClick, a2 = r3.rowGetter;
              (0, b.isFunction)(l2) && l2(t4, a2(t4), o2.getColumn(n3)), o2.openCellEditor(t4, n3);
            }), (0, c.default)((0, d.default)(o2), "onToggleFilter", function() {
              o2.setState({ canFilter: !o2.state.canFilter }, function() {
                false === o2.state.canFilter && o2.props.onClearFilters && o2.props.onClearFilters();
              });
            }), (0, c.default)((0, d.default)(o2), "onDragHandleDoubleClick", function(e5) {
              if (o2.props.onDragHandleDoubleClick && o2.props.onDragHandleDoubleClick(e5), o2.props.onGridRowsUpdated) {
                var t4 = o2.getColumn(e5.idx).key;
                o2.onGridRowsUpdated(t4, e5.rowIdx, o2.props.rowsCount - 1, (0, c.default)({}, t4, e5.rowData[t4]), x.UpdateActions.COLUMN_FILL);
              }
            }), (0, c.default)((0, d.default)(o2), "onCellExpand", function(e5) {
              o2.props.onCellExpand && o2.props.onCellExpand(e5);
            }), (0, c.default)((0, d.default)(o2), "onRowExpandToggle", function(e5) {
              "function" === typeof o2.props.onRowExpandToggle && o2.props.onRowExpandToggle(e5);
            }), (0, c.default)((0, d.default)(o2), "onGridRowsUpdated", function(e5, t4, n3, r3, l2, a2) {
              var i2 = o2.props, u2 = i2.rowGetter, d2 = i2.rowKey, s2 = i2.onGridRowsUpdated;
              if ((0, b.isFunction)(o2.props.onRowUpdated) && o2.props.onRowUpdated({ updated: r3, rowIdx: t4, cellKey: e5, value: r3[e5] }), (0, b.isFunction)(s2)) {
                for (var c2 = [], f2 = t4; f2 <= n3; f2++)
                  c2.push(u2(f2)[d2]);
                var p2 = u2(l2 === x.UpdateActions.COPY_PASTE ? a2 : t4);
                s2({ cellKey: e5, fromRow: t4, toRow: n3, fromRowId: p2[d2], toRowId: u2(n3)[d2], rowIds: c2, updated: r3, action: l2, fromRowData: p2 });
              }
            }), (0, c.default)((0, d.default)(o2), "onCommit", function(e5) {
              var t4 = e5.rowIdx;
              o2.onGridRowsUpdated(e5.cellKey, t4, t4, e5.updated, x.UpdateActions.CELL_UPDATE);
            }), (0, c.default)((0, d.default)(o2), "onScroll", function(e5) {
              (0, b.isFunction)(o2.props.onScroll) && o2.props.onScroll(e5);
            }), (0, c.default)((0, d.default)(o2), "handleSort", function(e5, t4) {
              o2.setState({ sortDirection: t4, sortColumn: e5 }, function() {
                o2.props.onGridSort(e5, t4);
              });
            }), (0, c.default)((0, d.default)(o2), "getSelectedRow", function(e5, t4) {
              var n3 = e5.filter(function(e6) {
                return e6[o2.props.rowKey] === t4;
              });
              if (n3.length > 0)
                return n3[0];
            }), (0, c.default)((0, d.default)(o2), "useNewRowSelection", function() {
              return o2.props.rowSelection && o2.props.rowSelection.selectBy;
            }), (0, c.default)((0, d.default)(o2), "handleShiftSelect", function(e5) {
              if (o2.state.lastRowIdxUiSelected > -1 && o2.isSingleKeyDown(v.default.Shift)) {
                var t4 = o2.props.rowSelection.selectBy, n3 = t4.keys, r3 = t4.indexes, l2 = t4.isSelectedKey;
                if (w.default.isRowSelected(n3, r3, l2, o2.props.rowGetter(e5), e5))
                  return false;
                var a2 = false;
                if (e5 > o2.state.lastRowIdxUiSelected) {
                  for (var i2 = [], u2 = o2.state.lastRowIdxUiSelected + 1; u2 <= e5; u2++)
                    i2.push({ rowIdx: u2, row: o2.props.rowGetter(u2) });
                  "function" === typeof o2.props.rowSelection.onRowsSelected && o2.props.rowSelection.onRowsSelected(i2), a2 = true;
                } else if (e5 < o2.state.lastRowIdxUiSelected) {
                  for (var d2 = [], s2 = e5; s2 <= o2.state.lastRowIdxUiSelected - 1; s2++)
                    d2.push({ rowIdx: s2, row: o2.props.rowGetter(s2) });
                  "function" === typeof o2.props.rowSelection.onRowsSelected && o2.props.rowSelection.onRowsSelected(d2), a2 = true;
                }
                return a2 && o2.setState({ lastRowIdxUiSelected: e5 }), a2;
              }
              return false;
            }), (0, c.default)((0, d.default)(o2), "handleNewRowSelect", function(e5, t4) {
              o2.selectAllCheckbox && true === o2.selectAllCheckbox.checked && (o2.selectAllCheckbox.checked = false);
              var n3 = o2.props.rowSelection.selectBy, r3 = n3.keys, l2 = n3.indexes, a2 = n3.isSelectedKey, i2 = w.default.isRowSelected(r3, l2, a2, t4, e5);
              o2.setState({ lastRowIdxUiSelected: i2 ? -1 : e5, selected: { rowIdx: e5, idx: 0 } }), i2 && "function" === typeof o2.props.rowSelection.onRowsDeselected ? o2.props.rowSelection.onRowsDeselected([{ rowIdx: e5, row: t4 }]) : i2 || "function" !== typeof o2.props.rowSelection.onRowsSelected || o2.props.rowSelection.onRowsSelected([{ rowIdx: e5, row: t4 }]);
            }), (0, c.default)((0, d.default)(o2), "handleRowSelect", function(e5, t4, n3, r3) {
              if (r3.stopPropagation(), o2.useNewRowSelection())
                true === o2.props.rowSelection.enableShiftSelect && o2.handleShiftSelect(e5) || o2.handleNewRowSelect(e5, n3);
              else {
                var l2 = "single" === o2.props.enableRowSelect ? [] : o2.state.selectedRows.slice(0), a2 = o2.getSelectedRow(l2, n3[o2.props.rowKey]);
                a2 ? a2.isSelected = !a2.isSelected : (n3.isSelected = true, l2.push(n3)), o2.setState({ selectedRows: l2, selected: { rowIdx: e5, idx: 0 } }), o2.props.onRowSelect && o2.props.onRowSelect(l2.filter(function(e6) {
                  return true === e6.isSelected;
                }));
              }
            }), (0, c.default)((0, d.default)(o2), "handleCheckboxChange", function(e5) {
              var t4;
              if (t4 = e5.currentTarget instanceof HTMLInputElement && true === e5.currentTarget.checked, o2.useNewRowSelection()) {
                var n3 = o2.props.rowSelection.selectBy, r3 = n3.keys, l2 = n3.indexes, a2 = n3.isSelectedKey;
                if (t4 && "function" === typeof o2.props.rowSelection.onRowsSelected) {
                  for (var i2 = [], u2 = 0; u2 < o2.props.rowsCount; u2++) {
                    var d2 = o2.props.rowGetter(u2);
                    w.default.isRowSelected(r3, l2, a2, d2, u2) || i2.push({ rowIdx: u2, row: d2 });
                  }
                  i2.length > 0 && o2.props.rowSelection.onRowsSelected(i2);
                } else if (!t4 && "function" === typeof o2.props.rowSelection.onRowsDeselected) {
                  for (var s2 = [], c2 = 0; c2 < o2.props.rowsCount; c2++) {
                    var f2 = o2.props.rowGetter(c2);
                    w.default.isRowSelected(r3, l2, a2, f2, c2) && s2.push({ rowIdx: c2, row: f2 });
                  }
                  s2.length > 0 && o2.props.rowSelection.onRowsDeselected(s2);
                }
              } else {
                for (var p2 = [], g2 = 0; g2 < o2.props.rowsCount; g2++) {
                  var h3 = Object.assign({}, o2.props.rowGetter(g2), { isSelected: t4 });
                  p2.push(h3);
                }
                o2.setState({ selectedRows: p2 }), "function" === typeof o2.props.onRowSelect && o2.props.onRowSelect(p2.filter(function(e6) {
                  return true === e6.isSelected;
                }));
              }
            }), (0, c.default)((0, d.default)(o2), "getRowOffsetHeight", function() {
              var e5 = 0;
              return o2.getHeaderRows().forEach(function(t4) {
                return e5 += parseFloat(t4.height, 10);
              }), e5;
            }), (0, c.default)((0, d.default)(o2), "getHeaderRows", function() {
              var e5 = [{ height: o2.props.headerRowHeight || o2.props.rowHeight, rowType: x.HeaderRowType.HEADER }];
              return true === o2.state.canFilter && e5.push({ filterable: true, onFilterChange: o2.props.onAddFilter, height: o2.props.headerFiltersHeight, rowType: x.HeaderRowType.FILTER }), e5;
            }), (0, c.default)((0, d.default)(o2), "getInitialSelectedRows", function() {
              for (var e5 = [], t4 = 0; t4 < o2.props.rowsCount; t4++)
                e5.push(false);
              return e5;
            }), (0, c.default)((0, d.default)(o2), "getRowSelectionProps", function() {
              return o2.props.rowSelection ? o2.props.rowSelection.selectBy : null;
            }), (0, c.default)((0, d.default)(o2), "getSelectedRows", function() {
              return o2.props.rowSelection ? null : o2.state.selectedRows.filter(function(e5) {
                return true === e5.isSelected;
              });
            }), (0, c.default)((0, d.default)(o2), "getDataGridDOMNode", function() {
              return o2.grid;
            }), (0, c.default)((0, d.default)(o2), "openCellEditor", function(e5, t4) {
              o2.selectCell({ rowIdx: e5, idx: t4 }, true);
            }), (0, c.default)((0, d.default)(o2), "scrollToColumn", function(e5) {
              o2.eventBus.dispatch(x.EventTypes.SCROLL_TO_COLUMN, e5);
            }), (0, c.default)((0, d.default)(o2), "setupGridColumns", function() {
              var e5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o2.props, t4 = e5.columns;
              if (o2._cachedColumns === t4)
                return o2._cachedComputedColumns;
              o2._cachedColumns = t4;
              var n3 = t4.slice(0), r3 = {};
              if (o2.props.rowActionsCell || e5.enableRowSelect && !o2.props.rowSelection || e5.rowSelection && false !== e5.rowSelection.showCheckbox) {
                var l2 = o2.props.selectAllRenderer || y.default, a2 = f.default.createElement(l2, { onChange: o2.handleCheckboxChange, inputRef: function e6(t5) {
                  return o2.selectAllCheckbox = t5;
                } }), i2 = "single" === e5.enableRowSelect ? null : a2, u2 = o2.props.rowActionsCell ? o2.props.rowActionsCell : m.default, d2 = { key: "select-row", name: "", formatter: f.default.createElement(u2, { rowSelection: o2.props.rowSelection }), onCellChange: o2.handleRowSelect, filterable: false, headerRenderer: i2, width: 60, frozen: true, getRowMetaData: function e6(t5) {
                  return t5;
                }, cellClass: o2.props.rowActionsCell ? "rdg-row-actions-cell" : "" };
                r3 = n3.unshift(d2), n3 = r3 > 0 ? n3 : r3;
              }
              return o2._cachedComputedColumns = n3, o2._cachedComputedColumns;
            }), (0, c.default)((0, d.default)(o2), "setGridRef", function(e5) {
              o2.grid = e5;
            }), (0, c.default)((0, d.default)(o2), "setBaseGridRef", function(e5) {
              o2.base = e5;
            }), (0, c.default)((0, d.default)(o2), "renderToolbar", function() {
              var e5 = o2.props.toolbar, t4 = { columns: o2.props.columns, onToggleFilter: o2.onToggleFilter, numberOfRows: o2.props.rowsCount };
              return f.default.isValidElement(e5) ? f.default.cloneElement(e5, t4) : (0, b.isFunction)(e5) ? f.default.createElement(e5, t4) : void 0;
            });
            var r2 = { columnMetrics: o2.createColumnMetrics(), selectedRows: [], expandedRows: [], canFilter: false, columnFilters: {}, sortDirection: null, sortColumn: null, scrollOffset: 0, lastRowIdxUiSelected: -1 };
            return o2.props.sortColumn && o2.props.sortDirection && (r2.sortColumn = o2.props.sortColumn, r2.sortDirection = o2.props.sortDirection), o2.state = r2, o2.eventBus = new S.EventBus(), o2;
          }
          return (0, s.default)(t3, e3), (0, a.default)(t3, [{ key: "componentDidMount", value: function e4() {
            this._mounted = true, window.addEventListener("resize", this.metricsUpdated), this.props.cellRangeSelection && window.addEventListener("mouseup", this.onWindowMouseUp), this.metricsUpdated();
          } }, { key: "componentWillUnmount", value: function e4() {
            this._mounted = false, window.removeEventListener("resize", this.metricsUpdated), window.removeEventListener("mouseup", this.onWindowMouseUp);
          } }, { key: "componentWillReceiveProps", value: function e4(t4) {
            if (t4.columns && (!E.sameColumns(this.props.columns, t4.columns, this.props.columnEquality) || t4.minWidth !== this.props.minWidth)) {
              var n2 = this.createColumnMetrics(t4);
              this.setState({ columnMetrics: n2 });
            }
          } }, { key: "render", value: function e4() {
            var t4 = { rowKey: this.props.rowKey, onCellClick: this.onCellClick, onCellContextMenu: this.onCellContextMenu, onCellDoubleClick: this.onCellDoubleClick, onColumnEvent: this.onColumnEvent, onCellExpand: this.onCellExpand, onRowExpandToggle: this.onRowExpandToggle, getCellActions: this.props.getCellActions, onDeleteSubRow: this.props.onDeleteSubRow, onAddSubRow: this.props.onAddSubRow, onDragEnter: this.handleDragEnter };
            this.props.cellRangeSelection && (t4.onCellMouseDown = this.onCellMouseDown, t4.onCellMouseEnter = this.onCellMouseEnter);
            var n2 = this.renderToolbar(), o2 = this.props.minWidth || this.gridWidth(), l2 = o2 - this.state.scrollOffset;
            return ("undefined" === typeof o2 || isNaN(o2) || 0 === o2) && (o2 = "100%"), ("undefined" === typeof l2 || isNaN(l2) || 0 === l2) && (l2 = "100%"), f.default.createElement("div", { className: "react-grid-Container", style: { width: o2 }, ref: this.setGridRef }, n2, f.default.createElement("div", { className: "react-grid-Main" }, f.default.createElement(h.default, (0, r.default)({ ref: this.setBaseGridRef }, this.props, { rowKey: this.props.rowKey, headerRows: this.getHeaderRows(), columnMetrics: this.state.columnMetrics, rowGetter: this.props.rowGetter, rowsCount: this.props.rowsCount, rowHeight: this.props.rowHeight, cellMetaData: t4, selectedRows: this.getSelectedRows(), rowSelection: this.getRowSelectionProps(), expandedRows: this.state.expandedRows, rowOffsetHeight: this.getRowOffsetHeight(), sortColumn: this.state.sortColumn, sortDirection: this.state.sortDirection, onSort: this.handleSort, minHeight: this.props.minHeight, totalWidth: l2, onViewportKeydown: this.onKeyDown, onViewportKeyup: this.onKeyUp, onColumnResize: this.onColumnResize, rowScrollTimeout: this.props.rowScrollTimeout, scrollToRowIndex: this.props.scrollToRowIndex, contextMenu: this.props.contextMenu, overScan: this.props.overScan, enableCellSelect: this.props.enableCellSelect, enableCellAutoFocus: this.props.enableCellAutoFocus, cellNavigationMode: this.props.cellNavigationMode, eventBus: this.eventBus, onCheckCellIsEditable: this.props.onCheckCellIsEditable, onCellCopyPaste: this.props.onCellCopyPaste, onGridRowsUpdated: this.onGridRowsUpdated, onDragHandleDoubleClick: this.onDragHandleDoubleClick, onCellSelected: this.props.onCellSelected, onCellDeSelected: this.props.onCellDeSelected, onCellRangeSelectionStarted: this.props.cellRangeSelection && this.props.cellRangeSelection.onStart, onCellRangeSelectionUpdated: this.props.cellRangeSelection && this.props.cellRangeSelection.onUpdate, onCellRangeSelectionCompleted: this.props.cellRangeSelection && this.props.cellRangeSelection.onComplete, onCommit: this.onCommit, onScroll: this.onScroll, editorPortalTarget: this.props.editorPortalTarget }))));
          } }]), t3;
        }(f.default.Component);
        (0, c.default)(D, "displayName", "ReactDataGrid"), (0, c.default)(D, "propTypes", { rowHeight: p.default.number, headerRowHeight: p.default.number, headerFiltersHeight: p.default.number, minHeight: p.default.number.isRequired, minWidth: p.default.number, enableRowSelect: (0, g.deprecate)(p.default.func, I("enableRowSelect", "rowSelection")), onRowUpdated: (0, g.deprecate)(p.default.func, I("onRowUpdated", "onGridRowsUpdated")), rowGetter: p.default.func.isRequired, rowsCount: p.default.number.isRequired, toolbar: p.default.element, enableCellSelect: p.default.bool, columns: p.default.arrayOf(p.default.shape({ name: p.default.node.isRequired, key: p.default.string.isRequired, width: p.default.number, filterable: p.default.bool, filterRenderer: p.default.node, resizable: p.default.bool, sortable: p.default.bool, sortDescendingFirst: p.default.bool, dragable: p.default.bool, editable: p.default.node, editor: p.default.node, formatter: p.default.node, headerRenderer: p.default.node, frozen: p.default.bool, events: p.default.object })).isRequired, onFilter: p.default.func, onCellCopyPaste: (0, g.deprecate)(p.default.func, I("onCellCopyPaste", "onGridRowsUpdated")), onCellsDragged: (0, g.deprecate)(p.default.func, I("onCellsDragged", "onGridRowsUpdated")), getCellActions: p.default.func, onAddFilter: p.default.func, onGridSort: p.default.func, sortColumn: p.default.string, sortDirection: p.default.oneOf(Object.keys(R.DEFINE_SORT)), onDragHandleDoubleClick: (0, g.deprecate)(p.default.func, I("onDragHandleDoubleClick", "onGridRowsUpdated")), onGridRowsUpdated: p.default.func, onRowSelect: p.default.func, rowKey: p.default.string, rowScrollTimeout: (0, g.deprecate)(p.default.number), scrollToRowIndex: p.default.number, onClearFilters: p.default.func, contextMenu: p.default.element, cellNavigationMode: p.default.oneOf(["none", "loopOverRow", "changeRow"]), onCellSelected: p.default.func, onCellDeSelected: p.default.func, cellRangeSelection: p.default.shape({ onStart: p.default.func, onUpdate: p.default.func, onComplete: p.default.func }), onCellExpand: p.default.func, enableDragAndDrop: p.default.bool, onRowExpandToggle: p.default.func, draggableHeaderCell: p.default.func, getValidFilterValues: p.default.func, rowSelection: p.default.shape({ enableShiftSelect: p.default.bool, onRowsSelected: p.default.func, onRowsDeselected: p.default.func, showCheckbox: p.default.bool, selectBy: p.default.oneOfType([p.default.shape({ indexes: p.default.arrayOf(p.default.number).isRequired }), p.default.shape({ isSelectedKey: p.default.string.isRequired }), p.default.shape({ keys: p.default.shape({ values: p.default.array.isRequired, rowKey: p.default.string.isRequired }).isRequired })]).isRequired }), onRowClick: p.default.func, onRowDoubleClick: p.default.func, onGridKeyUp: p.default.func, onGridKeyDown: p.default.func, rowGroupRenderer: p.default.func, rowActionsCell: p.default.func, onCheckCellIsEditable: p.default.func, onDeleteSubRow: p.default.func, onAddSubRow: p.default.func, enableCellAutoFocus: p.default.bool, onBeforeEdit: p.default.func, selectAllRenderer: p.default.object, minColumnWidth: p.default.number, onColumnResize: p.default.func, onScroll: p.default.func, editorPortalTarget: p.default.instanceOf(Element) }), (0, c.default)(D, "defaultProps", { enableCellSelect: false, rowHeight: 35, headerFiltersHeight: 45, enableRowSelect: false, minHeight: 350, rowKey: "id", rowScrollTimeout: 0, scrollToRowIndex: 0, cellNavigationMode: x.CellNavigationMode.NONE, overScan: { colsStart: 2, colsEnd: 2, rowsStart: 2, rowsEnd: 2 }, enableCellAutoFocus: true, onBeforeEdit: function e3() {
        }, minColumnWidth: 80, columnEquality: E.sameColumn, editorPortalTarget: document.body }), e2.exports = D;
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var o = Object.assign || function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = arguments[t3];
            for (var o2 in n2)
              Object.prototype.hasOwnProperty.call(n2, o2) && (e3[o2] = n2[o2]);
          }
          return e3;
        };
        function r(e3, t3) {
          var n2 = false;
          return function() {
            for (var o2 = arguments.length, r2 = Array(o2), l = 0; l < o2; l++)
              r2[l] = arguments[l];
            var a = r2[0][r2[1]];
            return void 0 === a || null === a || n2 || (n2 = true, console.warn(t3)), e3.call.apply(e3, [this].concat(r2));
          };
        }
        t2.deprecate = r, t2.addIsDeprecated = function l(e3) {
          var t3 = o({}, e3);
          for (var n2 in t3)
            if (t3.hasOwnProperty(n2)) {
              var l2 = t3[n2];
              (l2 = l2.bind(t3)).isDeprecated = r.bind(t3, l2), t3[n2] = l2;
            }
          return t3;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(4)), a = o(n(5)), i = o(n(7)), u = o(n(8)), d = o(n(13)), s = o(n(9)), c = o(n(11)), f = o(n(1)), p = o(n(10)), g = o(n(208)), h = o(n(217)), m = o(n(66)), w = n(25);
        n(69);
        var C = function(e3) {
          function t3() {
            var e4, n2;
            (0, l.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), a2 = 0; a2 < o2; a2++)
              r2[a2] = arguments[a2];
            return n2 = (0, i.default)(this, (e4 = (0, u.default)(t3)).call.apply(e4, [this].concat(r2))), (0, c.default)((0, d.default)(n2), "_scrollLeft", void 0), (0, c.default)((0, d.default)(n2), "getStyle", function() {
              return { overflow: "hidden", outline: 0, position: "relative", minHeight: n2.props.minHeight };
            }), (0, c.default)((0, d.default)(n2), "_onScroll", function() {
              void 0 !== n2._scrollLeft && (n2.header.setScrollLeft(n2._scrollLeft), n2.viewport && n2.viewport.setScrollLeft(n2._scrollLeft));
            }), (0, c.default)((0, d.default)(n2), "onScroll", function(e5) {
              n2.props.onScroll(e5);
              var t4 = e5.scrollLeft;
              (n2._scrollLeft !== t4 || n2.areFrozenColumnsScrolledLeft(t4)) && (n2._scrollLeft = t4, n2._onScroll());
            }), (0, c.default)((0, d.default)(n2), "setHeaderRef", function(e5) {
              n2.header = e5;
            }), (0, c.default)((0, d.default)(n2), "setViewportRef", function(e5) {
              n2.viewport = e5;
            }), (0, c.default)((0, d.default)(n2), "setViewportContainerRef", function(e5) {
              n2.viewPortContainer = e5;
            }), (0, c.default)((0, d.default)(n2), "setEmptyViewRef", function(e5) {
              n2.emptyView = e5;
            }), n2;
          }
          return (0, s.default)(t3, e3), (0, a.default)(t3, [{ key: "areFrozenColumnsScrolledLeft", value: function e4(t4) {
            return t4 > 0 && this.props.columns.some(function(e5) {
              return (0, w.isFrozen)(e5);
            });
          } }, { key: "componentDidMount", value: function e4() {
            this._scrollLeft = this.viewport ? this.viewport.getScroll().scrollLeft : 0, this._onScroll();
          } }, { key: "componentDidUpdate", value: function e4() {
            this._onScroll();
          } }, { key: "componentWillUnmount", value: function e4() {
            this._scrollLeft = void 0;
          } }, { key: "render", value: function e4() {
            var t4 = this.props.headerRows, n2 = this.props.emptyRowsView;
            return f.default.createElement("div", { style: this.getStyle(), className: "react-grid-Grid" }, f.default.createElement(g.default, { ref: this.setHeaderRef, columnMetrics: this.props.columnMetrics, onColumnResize: this.props.onColumnResize, height: this.props.rowHeight, totalWidth: this.props.totalWidth, headerRows: t4, sortColumn: this.props.sortColumn, sortDirection: this.props.sortDirection, draggableHeaderCell: this.props.draggableHeaderCell, onSort: this.props.onSort, onHeaderDrop: this.props.onHeaderDrop, getValidFilterValues: this.props.getValidFilterValues, cellMetaData: this.props.cellMetaData }), this.props.rowsCount >= 1 || 0 === this.props.rowsCount && !this.props.emptyRowsView ? f.default.createElement("div", { ref: this.setViewportContainerRef, onKeyDown: this.props.onViewportKeydown, onKeyUp: this.props.onViewportKeyup }, f.default.createElement(h.default, (0, r.default)({}, this.props, { ref: this.setViewportRef, rowKey: this.props.rowKey, width: this.props.columnMetrics.width, rowHeight: this.props.rowHeight, rowRenderer: this.props.rowRenderer, rowGetter: this.props.rowGetter, rowsCount: this.props.rowsCount, selectedRows: this.props.selectedRows, expandedRows: this.props.expandedRows, columnMetrics: this.props.columnMetrics, totalWidth: this.props.totalWidth, onScroll: this.onScroll, onRows: this.props.onRows, cellMetaData: this.props.cellMetaData, rowOffsetHeight: this.props.rowOffsetHeight || this.props.rowHeight * t4.length, minHeight: this.props.minHeight, rowScrollTimeout: this.props.rowScrollTimeout, scrollToRowIndex: this.props.scrollToRowIndex, contextMenu: this.props.contextMenu, rowSelection: this.props.rowSelection, getSubRowDetails: this.props.getSubRowDetails, rowGroupRenderer: this.props.rowGroupRenderer, overScan: this.props.overScan, enableCellSelect: this.props.enableCellSelect, enableCellAutoFocus: this.props.enableCellAutoFocus, cellNavigationMode: this.props.cellNavigationMode, eventBus: this.props.eventBus, onCheckCellIsEditable: this.props.onCheckCellIsEditable, onCellCopyPaste: this.props.onCellCopyPaste, onGridRowsUpdated: this.props.onGridRowsUpdated, onDragHandleDoubleClick: this.props.onDragHandleDoubleClick, onCellSelected: this.props.onCellSelected, onCellDeSelected: this.props.onCellDeSelected, onCellRangeSelectionStarted: this.props.onCellRangeSelectionStarted, onCellRangeSelectionUpdated: this.props.onCellRangeSelectionUpdated, onCellRangeSelectionCompleted: this.props.onCellRangeSelectionCompleted, onCommit: this.props.onCommit, RowsContainer: this.props.RowsContainer, editorPortalTarget: this.props.editorPortalTarget }))) : f.default.createElement("div", { ref: this.setEmptyViewRef, className: "react-grid-Empty" }, f.default.createElement(n2, null)));
          } }]), t3;
        }(f.default.Component);
        (0, c.default)(C, "displayName", "Grid"), (0, c.default)(C, "propTypes", { rowGetter: p.default.oneOfType([p.default.array, p.default.func]).isRequired, columns: p.default.oneOfType([p.default.array, p.default.object]), columnMetrics: p.default.object, minHeight: p.default.number, totalWidth: p.default.oneOfType([p.default.number, p.default.string]), headerRows: p.default.oneOfType([p.default.array, p.default.func]), rowHeight: p.default.number, rowRenderer: p.default.oneOfType([p.default.element, p.default.func]), emptyRowsView: p.default.func, expandedRows: p.default.oneOfType([p.default.array, p.default.func]), selectedRows: p.default.oneOfType([p.default.array, p.default.func]), rowSelection: p.default.oneOfType([p.default.shape({ indexes: p.default.arrayOf(p.default.number).isRequired }), p.default.shape({ isSelectedKey: p.default.string.isRequired }), p.default.shape({ keys: p.default.shape({ values: p.default.array.isRequired, rowKey: p.default.string.isRequired }).isRequired })]), rowsCount: p.default.number, onRows: p.default.func, sortColumn: p.default.string, cellMetaData: p.default.shape(m.default).isRequired, sortDirection: p.default.oneOf(["ASC", "DESC", "NONE"]), rowOffsetHeight: p.default.number.isRequired, onViewportKeydown: p.default.func.isRequired, onViewportKeyup: p.default.func, onColumnResize: p.default.func, onSort: p.default.func, onHeaderDrop: p.default.func, rowKey: p.default.string.isRequired, rowScrollTimeout: p.default.number, scrollToRowIndex: p.default.number, contextMenu: p.default.element, getSubRowDetails: p.default.func, draggableHeaderCell: p.default.func, getValidFilterValues: p.default.func, rowGroupRenderer: p.default.func, overScan: p.default.object, enableCellSelect: p.default.bool.isRequired, enableCellAutoFocus: p.default.bool.isRequired, cellNavigationMode: p.default.string.isRequired, eventBus: p.default.object.isRequired, onCheckCellIsEditable: p.default.func, onCellCopyPaste: p.default.func, onGridRowsUpdated: p.default.func.isRequired, onDragHandleDoubleClick: p.default.func.isRequired, onCellSelected: p.default.func, onCellDeSelected: p.default.func, onCellRangeSelectionStarted: p.default.func, onCellRangeSelectionUpdated: p.default.func, onCellRangeSelectionCompleted: p.default.func, onCommit: p.default.func.isRequired, onScroll: p.default.func, scrollLeft: p.default.number, RowsContainer: p.default.node, editorPortalTarget: p.default.instanceOf(Element).isRequired }), (0, c.default)(C, "defaultProps", { rowHeight: 35, minHeight: 350 });
        var v = C;
        t2.default = v;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(16)), l = o(n(4)), a = o(n(5)), i = o(n(7)), u = o(n(8)), d = o(n(13)), s = o(n(9)), c = o(n(11)), f = o(n(1)), p = o(n(20)), g = o(n(49)), h = o(n(128)), m = o(n(129)), w = n(25), C = o(n(210)), v = o(n(89)), b = o(n(10)), y = o(n(57)), R = o(n(66)), x = n(29);
        n(58);
        var S = ["height", "onScroll"], E = function(e3) {
          function t3() {
            var e4, n2;
            (0, l.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), a2 = 0; a2 < o2; a2++)
              r2[a2] = arguments[a2];
            return n2 = (0, i.default)(this, (e4 = (0, u.default)(t3)).call.apply(e4, [this].concat(r2))), (0, c.default)((0, d.default)(n2), "state", { resizing: null }), (0, c.default)((0, d.default)(n2), "onColumnResize", function(e5, t4) {
              var o3 = n2.state.resizing || n2.props, r3 = n2.getColumnPosition(e5);
              if (null != r3) {
                var l2 = { columnMetrics: (0, h.default)(o3.columnMetrics) };
                l2.columnMetrics = m.default.resizeColumn(l2.columnMetrics, r3, t4), l2.columnMetrics.totalWidth < o3.columnMetrics.totalWidth && (l2.columnMetrics.totalWidth = o3.columnMetrics.totalWidth), l2.column = (0, w.getColumn)(l2.columnMetrics.columns, r3), n2.setState({ resizing: l2 });
              }
            }), (0, c.default)((0, d.default)(n2), "onColumnResizeEnd", function(e5, t4) {
              var o3 = n2.getColumnPosition(e5);
              null !== o3 && n2.props.onColumnResize && n2.props.onColumnResize(o3, t4 || e5.width);
            }), (0, c.default)((0, d.default)(n2), "setRowRef", function(e5) {
              n2.row = e5;
            }), (0, c.default)((0, d.default)(n2), "setFilterRowRef", function(e5) {
              n2.filterRow = e5;
            }), (0, c.default)((0, d.default)(n2), "getHeaderRows", function() {
              var e5 = n2.getColumnMetrics(), t4 = n2.state.resizing ? n2.state.resizing.column : void 0;
              return n2.props.headerRows.map(function(o3, r3) {
                var l2 = o3.rowType === x.HeaderRowType.FILTER, a3 = l2 ? "500px" : "auto", i2 = (0, v.default)() > 0 ? (0, v.default)() : 0, u2 = isNaN(n2.props.totalWidth - i2) ? n2.props.totalWidth : n2.props.totalWidth - i2, d2 = { position: "absolute", top: n2.getCombinedHeaderHeights(r3), left: 0, width: u2, overflowX: "hidden", minHeight: a3 };
                return f.default.createElement(C.default, { key: o3.rowType, ref: l2 ? n2.setFilterRowRef : n2.setRowRef, rowType: o3.rowType, style: d2, onColumnResize: n2.onColumnResize, onColumnResizeEnd: n2.onColumnResizeEnd, width: e5.width, height: o3.height || n2.props.height, columns: e5.columns, resizing: t4, draggableHeaderCell: n2.props.draggableHeaderCell, filterable: o3.filterable, onFilterChange: o3.onFilterChange, onHeaderDrop: n2.props.onHeaderDrop, sortColumn: n2.props.sortColumn, sortDirection: n2.props.sortDirection, onSort: n2.props.onSort, onScroll: n2.props.onScroll, getValidFilterValues: n2.props.getValidFilterValues });
              });
            }), (0, c.default)((0, d.default)(n2), "getColumnMetrics", function() {
              return n2.state.resizing ? n2.state.resizing.columnMetrics : n2.props.columnMetrics;
            }), (0, c.default)((0, d.default)(n2), "getColumnPosition", function(e5) {
              var t4 = n2.getColumnMetrics(), o3 = -1;
              return t4.columns.forEach(function(t5, n3) {
                t5.key === e5.key && (o3 = n3);
              }), -1 === o3 ? null : o3;
            }), (0, c.default)((0, d.default)(n2), "getCombinedHeaderHeights", function(e5) {
              var t4 = n2.props.headerRows.length;
              "undefined" !== typeof e5 && (t4 = e5);
              for (var o3 = 0, r3 = 0; r3 < t4; r3++)
                o3 += n2.props.headerRows[r3].height || n2.props.height;
              return o3;
            }), (0, c.default)((0, d.default)(n2), "getStyle", function() {
              return { position: "relative", height: n2.getCombinedHeaderHeights() };
            }), (0, c.default)((0, d.default)(n2), "setScrollLeft", function(e5) {
              (p.default.findDOMNode(n2.row).scrollLeft = e5, n2.row.setScrollLeft(e5), n2.filterRow) && (p.default.findDOMNode(n2.filterRow).scrollLeft = e5, n2.filterRow.setScrollLeft(e5));
            }), (0, c.default)((0, d.default)(n2), "getKnownDivProps", function() {
              return (0, y.default)(n2.props, S);
            }), (0, c.default)((0, d.default)(n2), "onHeaderClick", function() {
              n2.props.cellMetaData.onCellClick({ rowIdx: -1, idx: -1 });
            }), n2;
          }
          return (0, s.default)(t3, e3), (0, a.default)(t3, [{ key: "componentWillReceiveProps", value: function e4() {
            this.setState({ resizing: null });
          } }, { key: "shouldComponentUpdate", value: function e4(t4, n2) {
            return !m.default.sameColumns(this.props.columnMetrics.columns, t4.columnMetrics.columns, m.default.sameColumn) || this.props.totalWidth !== t4.totalWidth || this.props.headerRows.length !== t4.headerRows.length || this.state.resizing !== n2.resizing || this.props.sortColumn !== t4.sortColumn || this.props.sortDirection !== t4.sortDirection;
          } }, { key: "render", value: function e4() {
            var t4 = (0, g.default)({ "react-grid-Header": true, "react-grid-Header--resizing": !!this.state.resizing }), n2 = this.getHeaderRows();
            return f.default.createElement("div", (0, r.default)({}, this.getKnownDivProps(), { style: this.getStyle(), className: t4, onClick: this.onHeaderClick }), n2);
          } }]), t3;
        }(f.default.Component);
        (0, c.default)(E, "propTypes", { columnMetrics: b.default.shape({ width: b.default.number.isRequired, columns: b.default.any }).isRequired, totalWidth: b.default.oneOfType([b.default.number, b.default.string]), height: b.default.number.isRequired, headerRows: b.default.array.isRequired, sortColumn: b.default.string, sortDirection: b.default.oneOf(["ASC", "DESC", "NONE"]), onSort: b.default.func, onColumnResize: b.default.func, onScroll: b.default.func, onHeaderDrop: b.default.func, draggableHeaderCell: b.default.func, getValidFilterValues: b.default.func, cellMetaData: b.default.shape(R.default) }), e2.exports = E;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(1).isValidElement;
        e2.exports = function e3(t3, n2) {
          var r;
          for (r in t3)
            if (t3.hasOwnProperty(r)) {
              if ("function" === typeof t3[r] && "function" === typeof n2[r] || o(t3[r]) && o(n2[r]))
                continue;
              if (!n2.hasOwnProperty(r) || t3[r] !== n2[r])
                return false;
            }
          for (r in n2)
            if (n2.hasOwnProperty(r) && !t3.hasOwnProperty(r))
              return false;
          return true;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(47)), l = o(n(16)), a = o(n(4)), i = o(n(5)), u = o(n(7)), d = o(n(8)), s = o(n(13)), c = o(n(9)), f = o(n(11)), p = o(n(1)), g = o(n(211)), h = o(n(130)), m = o(n(89)), w = n(25), C = o(n(131)), v = o(n(215)), b = o(n(216)), y = o(n(57)), R = n(29);
        n(58);
        var x = o(n(10)), S = { overflow: x.default.string, width: x.default.oneOfType([x.default.number, x.default.string]), height: x.default.number, position: x.default.string }, E = ["width", "height", "style", "onScroll"], I = function(e3) {
          function t3() {
            var e4, n2;
            (0, a.default)(this, t3);
            for (var o2 = arguments.length, i2 = new Array(o2), c2 = 0; c2 < o2; c2++)
              i2[c2] = arguments[c2];
            return n2 = (0, u.default)(this, (e4 = (0, d.default)(t3)).call.apply(e4, [this].concat(i2))), (0, f.default)((0, s.default)(n2), "cells", []), (0, f.default)((0, s.default)(n2), "getHeaderCellType", function(e5) {
              return e5.filterable && n2.props.filterable ? b.default.FILTERABLE : e5.sortable && e5.rowType !== R.HeaderRowType.FILTER ? b.default.SORTABLE : b.default.NONE;
            }), (0, f.default)((0, s.default)(n2), "getFilterableHeaderCell", function(e5) {
              var t4 = v.default;
              return void 0 !== e5.filterRenderer && (t4 = e5.filterRenderer), p.default.createElement(t4, (0, l.default)({}, n2.props, { onChange: n2.props.onFilterChange }));
            }), (0, f.default)((0, s.default)(n2), "getSortableHeaderCell", function(e5) {
              var t4 = n2.props.sortColumn === e5.key ? n2.props.sortDirection : C.default.DEFINE_SORT.NONE, o3 = void 0 !== e5.sortDescendingFirst && e5.sortDescendingFirst;
              return p.default.createElement(C.default, { columnKey: e5.key, onSort: n2.props.onSort, sortDirection: t4, sortDescendingFirst: o3, headerRenderer: e5.headerRenderer });
            }), (0, f.default)((0, s.default)(n2), "getHeaderRenderer", function(e5) {
              if (e5.headerRenderer && !e5.sortable && !n2.props.filterable)
                return e5.headerRenderer;
              switch (n2.getHeaderCellType(e5)) {
                case b.default.SORTABLE:
                  return n2.getSortableHeaderCell(e5);
                case b.default.FILTERABLE:
                  return n2.getFilterableHeaderCell(e5);
                default:
                  return;
              }
            }), (0, f.default)((0, s.default)(n2), "getStyle", function() {
              return { overflow: "hidden", width: "100%", height: n2.props.height, position: "absolute" };
            }), (0, f.default)((0, s.default)(n2), "getCells", function() {
              for (var e5 = [], t4 = [], o3 = n2.props, l2 = o3.columns, a2 = o3.rowType, i3 = function o4(i4, u3) {
                var d3 = (0, r.default)({ rowType: a2 }, (0, w.getColumn)(l2, i4)), s2 = "select-row" === d3.key && a2 === R.HeaderRowType.FILTER ? p.default.createElement("div", null) : n2.getHeaderRenderer(d3), c3 = p.default.createElement(h.default, { key: d3.key, ref: function e6(t5) {
                  return n2.cells[i4] = t5;
                }, column: d3, rowType: a2, height: n2.props.height, renderer: s2, resizing: n2.props.resizing === d3, onResize: n2.props.onColumnResize, onResizeEnd: n2.props.onColumnResizeEnd, onHeaderDrop: n2.props.onHeaderDrop, draggableHeaderCell: n2.props.draggableHeaderCell });
                (0, w.isFrozen)(d3) ? t4.push(c3) : e5.push(c3);
              }, u2 = 0, d2 = (0, w.getSize)(l2); u2 < d2; u2++)
                i3(u2);
              return e5.concat(t4);
            }), (0, f.default)((0, s.default)(n2), "setScrollLeft", function(e5) {
              n2.props.columns.forEach(function(t4, o3) {
                (0, w.isFrozen)(t4) ? n2.cells[o3].setScrollLeft(e5) : n2.cells[o3] && n2.cells[o3].removeScroll && n2.cells[o3].removeScroll();
              });
            }), (0, f.default)((0, s.default)(n2), "getKnownDivProps", function() {
              return (0, y.default)(n2.props, E);
            }), n2;
          }
          return (0, c.default)(t3, e3), (0, i.default)(t3, [{ key: "shouldComponentUpdate", value: function e4(t4) {
            return t4.width !== this.props.width || t4.height !== this.props.height || t4.columns !== this.props.columns || !(0, g.default)(t4.style, this.props.style) || this.props.sortColumn !== t4.sortColumn || this.props.sortDirection !== t4.sortDirection;
          } }, { key: "render", value: function e4() {
            var t4 = { width: this.props.width ? this.props.width + (0, m.default)() : "100%", height: this.props.height, whiteSpace: "nowrap", overflowX: "hidden", overflowY: "hidden" }, n2 = this.getCells();
            return p.default.createElement("div", (0, l.default)({}, this.getKnownDivProps(), { className: "react-grid-HeaderRow" }), p.default.createElement("div", { style: t4 }, n2));
          } }]), t3;
        }(p.default.Component);
        (0, f.default)(I, "displayName", "HeaderRow"), (0, f.default)(I, "propTypes", { width: x.default.oneOfType([x.default.number, x.default.string]), height: x.default.number.isRequired, columns: x.default.oneOfType([x.default.array, x.default.object]).isRequired, onColumnResize: x.default.func, onSort: x.default.func.isRequired, onColumnResizeEnd: x.default.func, style: x.default.shape(S), sortColumn: x.default.string, sortDirection: x.default.oneOf(Object.keys(C.default.DEFINE_SORT)), cellRenderer: x.default.func, headerCellRenderer: x.default.func, filterable: x.default.bool, onFilterChange: x.default.func, resizing: x.default.object, onScroll: x.default.func, rowType: x.default.string, draggableHeaderCell: x.default.func, onHeaderDrop: x.default.func }), e2.exports = I;
      }, function(e2, t2) {
        e2.exports = function e3(t3, n, o, r) {
          var l = o ? o.call(r, t3, n) : void 0;
          if (void 0 !== l)
            return !!l;
          if (t3 === n)
            return true;
          if ("object" !== typeof t3 || !t3 || "object" !== typeof n || !n)
            return false;
          var a = Object.keys(t3), i = Object.keys(n);
          if (a.length !== i.length)
            return false;
          for (var u = Object.prototype.hasOwnProperty.bind(n), d = 0; d < a.length; d++) {
            var s = a[d];
            if (!u(s))
              return false;
            var c = t3[s], f = n[s];
            if (false === (l = o ? o.call(r, c, f, s) : void 0) || void 0 === l && c !== f)
              return false;
          }
          return true;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(16)), l = o(n(4)), a = o(n(5)), i = o(n(7)), u = o(n(8)), d = o(n(9)), s = n(1), c = n(213);
        n(58);
        var f = { position: "absolute", top: 0, right: 0, width: 6, height: "100%" }, p = function(e3) {
          function t3() {
            return (0, l.default)(this, t3), (0, i.default)(this, (0, u.default)(t3).apply(this, arguments));
          }
          return (0, d.default)(t3, e3), (0, a.default)(t3, [{ key: "render", value: function e4() {
            return s.createElement(c, (0, r.default)({}, this.props, { className: "react-grid-HeaderCell__resizeHandle", style: f }));
          } }]), t3;
        }(s.Component);
        e2.exports = p;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(16)), l = o(n(4)), a = o(n(5)), i = o(n(7)), u = o(n(8)), d = o(n(13)), s = o(n(9)), c = o(n(11)), f = o(n(1)), p = o(n(10)), g = o(n(57));
        n(58);
        var h = ["onDragStart", "onDragEnd", "onDrag", "style"], m = function(e3) {
          function t3() {
            var e4, n2;
            (0, l.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), a2 = 0; a2 < o2; a2++)
              r2[a2] = arguments[a2];
            return n2 = (0, i.default)(this, (e4 = (0, u.default)(t3)).call.apply(e4, [this].concat(r2))), (0, c.default)((0, d.default)(n2), "state", { drag: null }), (0, c.default)((0, d.default)(n2), "onMouseDown", function(e5) {
              var t4 = n2.props.onDragStart(e5);
              e5.preventDefault && e5.preventDefault(), null === t4 && 0 !== e5.button || (window.addEventListener("mouseup", n2.onMouseUp), window.addEventListener("mousemove", n2.onMouseMove), window.addEventListener("touchend", n2.onMouseUp), window.addEventListener("touchmove", n2.onMouseMove), n2.setState({ drag: t4 }));
            }), (0, c.default)((0, d.default)(n2), "onMouseMove", function(e5) {
              null !== n2.state.drag && (e5.preventDefault && e5.preventDefault(), n2.props.onDrag(e5));
            }), (0, c.default)((0, d.default)(n2), "onMouseUp", function(e5) {
              n2.cleanUp(), n2.props.onDragEnd(e5, n2.state.drag), n2.setState({ drag: null });
            }), (0, c.default)((0, d.default)(n2), "cleanUp", function() {
              window.removeEventListener("mouseup", n2.onMouseUp), window.removeEventListener("mousemove", n2.onMouseMove), window.removeEventListener("touchend", n2.onMouseUp), window.removeEventListener("touchmove", n2.onMouseMove);
            }), (0, c.default)((0, d.default)(n2), "getKnownDivProps", function() {
              return (0, g.default)(n2.props, h);
            }), n2;
          }
          return (0, s.default)(t3, e3), (0, a.default)(t3, [{ key: "componentWillUnmount", value: function e4() {
            this.cleanUp();
          } }, { key: "render", value: function e4() {
            return f.default.createElement("div", (0, r.default)({}, this.getKnownDivProps(), { onMouseDown: this.onMouseDown, onTouchStart: this.onMouseDown, className: "react-grid-HeaderCell__draggable" }));
          } }]), t3;
        }(f.default.Component);
        (0, c.default)(m, "propTypes", { onDragStart: p.default.func, onDragEnd: p.default.func, onDrag: p.default.func, component: p.default.oneOfType([p.default.func, p.default.constructor]), style: p.default.object }), (0, c.default)(m, "defaultProps", { onDragStart: function e3() {
          return true;
        }, onDragEnd: function e3() {
        }, onDrag: function e3() {
        } }), e2.exports = m;
      }, function(e2, t2, n) {
        (e2.exports = n(26)(false)).push([e2.i, ".react-grid-Header {\n  box-shadow: 0px 0px 4px 0px #dddddd;\n  background: #f9f9f9;\n}\n.react-grid-Header--resizing {\n  cursor: ew-resize;\n}\n.react-grid-HeaderRow {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.react-grid-HeaderCell {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background: #f9f9f9;\n  padding: 8px;\n  font-weight: bold;\n  border-right: 1px solid #dddddd;\n  border-bottom: 1px solid #dddddd;\n}\n.react-grid-HeaderCell__value {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  position: relative;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.react-grid-HeaderCell__resizeHandle:hover {\n  cursor: ew-resize;\n  background: #dddddd;\n}\n.react-grid-HeaderCell--frozen:last-of-type {\n    box-shadow: 2px 0 5px -2px rgba(136, 136, 136, .3);\n}\n.react-grid-HeaderCell--resizing .react-grid-HeaderCell__resizeHandle {\n  background: #dddddd;\n}\n.react-grid-HeaderCell__draggable {\n    cursor: col-resize\n}\n.rdg-can-drop > .react-grid-HeaderCell {\n  background: #ececec;\n}\n\n.react-grid-HeaderCell .Select {\n    max-height: 30px;\n    font-size: 12px;\n    font-weight: normal;\n}\n\n.react-grid-HeaderCell .Select-control {\n    max-height: 30px;\n    border: 1px solid #cccccc;\n    color: #555;\n    border-radius: 3px;\n}\n\n.react-grid-HeaderCell .is-focused:not(.is-open) > .Select-control {\n    border-color: #66afe9;\n    outline: 0;\n    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102,175,233,.6);\n    box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102,175,233,.6);\n}\n\n.react-grid-HeaderCell .Select-control .Select-placeholder {\n    line-height: 20px;\n    color: #999;\n    padding: 4px;\n}\n\n.react-grid-HeaderCell .Select-control .Select-input {\n    max-height: 28px;\n    padding: 4px;\n    margin-left: 0px\n}\n\n.react-grid-HeaderCell .Select-control .Select-input input {\n    padding: 0px;\n    height: 100%;\n}\n\n.react-grid-HeaderCell .Select-control .Select-arrow-zone .Select-arrow {\n    border-color: gray transparent transparent;\n    border-width: 4px 4px 2.5px;\n}\n\n\n.react-grid-HeaderCell .Select-control .Select-value {\n    padding: 4px;\n    line-height: 20px !important;\n}\n\n.react-grid-HeaderCell .Select--multi .Select-control .Select-value {\n    padding: 0px;\n    line-height: 16px !important;\n    max-height: 20px;\n}\n\n.react-grid-HeaderCell .Select--multi .Select-control .Select-value .Select-value-icon {\n    max-height: 20px;\n}\n\n.react-grid-HeaderCell .Select--multi .Select-control .Select-value .Select-value-label {\n    max-height: 20px;\n}\n\n.react-grid-HeaderCell .Select-control .Select-value .Select-value-label {\n    color: #555555 !important;\n}\n\n.react-grid-HeaderCell .Select-menu-outer {\n  z-index: 2;\n}\n\n.react-grid-HeaderCell .Select-menu-outer .Select-option {\n    padding: 4px;\n    line-height: 20px;\n}\n\n.react-grid-HeaderCell .Select-menu-outer .Select-menu .Select-option.is-selected {\n    color: #555555;\n}\n\n.react-grid-HeaderCell .Select-menu-outer .Select-menu .Select-option.is-focused {\n    color: #555555;\n}\n\n", ""]);
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(1)), f = o(n(41)), p = o(n(10)), g = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "state", { filterTerm: "" }), (0, s.default)((0, u.default)(n2), "handleChange", function(e5) {
              var t4 = e5.target.value;
              n2.setState({ filterTerm: t4 }), n2.props.onChange({ filterTerm: t4, column: n2.props.column });
            }), (0, s.default)((0, u.default)(n2), "renderInput", function() {
              if (false === n2.props.column.filterable)
                return c.default.createElement("span", null);
              var e5 = "header-filter-" + n2.props.column.key;
              return c.default.createElement("input", { key: e5, type: "text", className: "form-control input-sm", placeholder: "Search", value: n2.state.filterTerm, onChange: n2.handleChange });
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "render", value: function e4() {
            return c.default.createElement("div", null, c.default.createElement("div", { className: "form-group" }, this.renderInput()));
          } }]), t3;
        }(c.default.Component);
        (0, s.default)(g, "propTypes", { onChange: p.default.func.isRequired, column: p.default.shape(f.default) }), e2.exports = g;
      }, function(e2, t2, n) {
        "use strict";
        e2.exports = { SORTABLE: 0, FILTERABLE: 1, NONE: 2, CHECKBOX: 3 };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(1)), f = o(n(218)), p = o(n(66)), g = o(n(10)), h = n(25), m = n(239), w = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "state", (0, m.getGridState)(n2.props)), (0, s.default)((0, u.default)(n2), "onScroll", function(e5) {
              var t4 = e5.scrollTop, o3 = e5.scrollLeft, r2 = n2.props, l3 = r2.rowHeight, a2 = r2.rowsCount, i2 = r2.onScroll, u2 = n2.updateScroll({ scrollTop: t4, scrollLeft: o3, height: n2.state.height, rowHeight: l3, rowsCount: a2 });
              i2 && i2(u2);
            }), (0, s.default)((0, u.default)(n2), "getScroll", function() {
              return n2.canvas.getScroll();
            }), (0, s.default)((0, u.default)(n2), "setScrollLeft", function(e5) {
              n2.canvas.setScrollLeft(e5);
            }), (0, s.default)((0, u.default)(n2), "getDOMNodeOffsetWidth", function() {
              return n2.viewport ? n2.viewport.offsetWidth : 0;
            }), (0, s.default)((0, u.default)(n2), "clearScrollTimer", function() {
              n2.resetScrollStateTimeoutId && clearTimeout(n2.resetScrollStateTimeoutId);
            }), (0, s.default)((0, u.default)(n2), "resetScrollStateAfterDelay", function() {
              n2.clearScrollTimer(), n2.resetScrollStateTimeoutId = setTimeout(n2.resetScrollStateAfterDelayCallback, 500);
            }), (0, s.default)((0, u.default)(n2), "resetScrollStateAfterDelayCallback", function() {
              n2.resetScrollStateTimeoutId = null, n2.setState({ isScrolling: false });
            }), (0, s.default)((0, u.default)(n2), "updateScroll", function(e5) {
              n2.resetScrollStateAfterDelay();
              var t4 = n2.getNextScrollState(e5);
              return n2.setState(t4), t4;
            }), (0, s.default)((0, u.default)(n2), "metricsUpdated", function() {
              var e5 = n2.viewportHeight(), t4 = n2.viewportWidth();
              if (e5) {
                var o3 = n2.state, r2 = o3.scrollTop, l3 = o3.scrollLeft, a2 = n2.props, i2 = a2.rowHeight, u2 = a2.rowsCount;
                n2.updateScroll({ scrollTop: r2, scrollLeft: l3, height: e5, rowHeight: i2, rowsCount: u2, width: t4 });
              }
            }), (0, s.default)((0, u.default)(n2), "viewportHeight", function() {
              return n2.viewport ? n2.viewport.offsetHeight : 0;
            }), (0, s.default)((0, u.default)(n2), "viewportWidth", function() {
              return n2.viewport ? n2.viewport.offsetWidth : 0;
            }), (0, s.default)((0, u.default)(n2), "setViewportRef", function(e5) {
              n2.viewport = e5;
            }), (0, s.default)((0, u.default)(n2), "setCanvasRef", function(e5) {
              n2.canvas = e5;
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "getNextScrollState", value: function e4(t4) {
            var n2 = t4.scrollTop, o2 = t4.scrollLeft, r2 = t4.height, l2 = t4.rowHeight, a2 = t4.rowsCount, i2 = this.props.columnMetrics.columns, u2 = (0, m.getScrollDirection)(this.state, n2, o2), d2 = (0, m.getVisibleBoundaries)(r2, l2, n2, a2), s2 = d2.rowVisibleStartIdx, c2 = d2.rowVisibleEndIdx, f2 = (0, m.getRowOverscanStartIdx)(u2, s2), p2 = (0, m.getRowOverscanEndIdx)(u2, c2, a2), g2 = (0, h.getSize)(i2), w2 = (0, m.findLastFrozenColumnIndex)(i2), C = (0, m.getNonFrozenVisibleColStartIdx)(i2, o2), v = (0, m.getNonFrozenRenderedColumnCount)(this.props.columnMetrics, this.getDOMNodeOffsetWidth(), o2), b = Math.min(C + v, g2);
            return { height: r2, scrollTop: n2, scrollLeft: o2, rowVisibleStartIdx: s2, rowVisibleEndIdx: c2, rowOverscanStartIdx: f2, rowOverscanEndIdx: p2, colVisibleStartIdx: C, colVisibleEndIdx: b, colOverscanStartIdx: (0, m.getColOverscanStartIdx)(u2, C, w2), colOverscanEndIdx: (0, m.getColOverscanEndIdx)(u2, b, g2), scrollDirection: u2, lastFrozenColumnIndex: w2, isScrolling: true };
          } }, { key: "componentWillReceiveProps", value: function e4(t4) {
            var n2 = t4.rowHeight, o2 = t4.rowsCount;
            if (this.props.rowHeight !== t4.rowHeight || this.props.minHeight !== t4.minHeight) {
              var r2 = (0, m.getGridState)(t4), l2 = r2.scrollTop, a2 = r2.scrollLeft, i2 = r2.height;
              this.updateScroll({ scrollTop: l2, scrollLeft: a2, height: i2, rowHeight: n2, rowsCount: o2 });
            } else if ((0, h.getSize)(this.props.columnMetrics.columns) !== (0, h.getSize)(t4.columnMetrics.columns))
              this.setState((0, m.getGridState)(t4));
            else if (this.props.rowsCount !== t4.rowsCount) {
              var u2 = this.state, d2 = u2.scrollTop, s2 = u2.scrollLeft, c2 = u2.height;
              this.updateScroll({ scrollTop: d2, scrollLeft: s2, height: c2, rowHeight: n2, rowsCount: o2 });
            } else if (this.props.rowOffsetHeight !== t4.rowOffsetHeight) {
              var f2 = this.state, p2 = f2.scrollTop, g2 = f2.scrollLeft, w2 = this.state.height + this.props.rowOffsetHeight - t4.rowOffsetHeight;
              this.updateScroll({ scrollTop: p2, scrollLeft: g2, height: w2, rowHeight: n2, rowsCount: o2 });
            }
          } }, { key: "componentDidMount", value: function e4() {
            window.addEventListener("resize", this.metricsUpdated), this.metricsUpdated();
          } }, { key: "componentWillUnmount", value: function e4() {
            window.removeEventListener("resize", this.metricsUpdated), this.clearScrollTimer();
          } }, { key: "render", value: function e4() {
            var t4 = { padding: 0, bottom: 0, left: 0, right: 0, overflow: "hidden", position: "absolute", top: this.props.rowOffsetHeight };
            return c.default.createElement("div", { className: "react-grid-Viewport", style: t4, ref: this.setViewportRef }, c.default.createElement(f.default, { ref: this.setCanvasRef, rowKey: this.props.rowKey, totalWidth: this.props.totalWidth, width: this.props.columnMetrics.width, totalColumnWidth: this.props.columnMetrics.totalColumnWidth, rowGetter: this.props.rowGetter, rowsCount: this.props.rowsCount, selectedRows: this.props.selectedRows, expandedRows: this.props.expandedRows, columns: this.props.columnMetrics.columns, rowRenderer: this.props.rowRenderer, rowOverscanStartIdx: this.state.rowOverscanStartIdx, rowOverscanEndIdx: this.state.rowOverscanEndIdx, rowVisibleStartIdx: this.state.rowVisibleStartIdx, rowVisibleEndIdx: this.state.rowVisibleEndIdx, colVisibleStartIdx: this.state.colVisibleStartIdx, colVisibleEndIdx: this.state.colVisibleEndIdx, colOverscanStartIdx: this.state.colOverscanStartIdx, colOverscanEndIdx: this.state.colOverscanEndIdx, lastFrozenColumnIndex: this.state.lastFrozenColumnIndex, cellMetaData: this.props.cellMetaData, height: this.state.height, rowHeight: this.props.rowHeight, onScroll: this.onScroll, onRows: this.props.onRows, rowScrollTimeout: this.props.rowScrollTimeout, scrollToRowIndex: this.props.scrollToRowIndex, contextMenu: this.props.contextMenu, rowSelection: this.props.rowSelection, getSubRowDetails: this.props.getSubRowDetails, rowGroupRenderer: this.props.rowGroupRenderer, isScrolling: this.state.isScrolling || false, enableCellSelect: this.props.enableCellSelect, enableCellAutoFocus: this.props.enableCellAutoFocus, cellNavigationMode: this.props.cellNavigationMode, eventBus: this.props.eventBus, onCheckCellIsEditable: this.props.onCheckCellIsEditable, onCellCopyPaste: this.props.onCellCopyPaste, onGridRowsUpdated: this.props.onGridRowsUpdated, onDragHandleDoubleClick: this.props.onDragHandleDoubleClick, onCellSelected: this.props.onCellSelected, onCellDeSelected: this.props.onCellDeSelected, onCellRangeSelectionStarted: this.props.onCellRangeSelectionStarted, onCellRangeSelectionUpdated: this.props.onCellRangeSelectionUpdated, onCellRangeSelectionCompleted: this.props.onCellRangeSelectionCompleted, onCommit: this.props.onCommit, RowsContainer: this.props.RowsContainer, prevScrollLeft: this.state.prevScrollLeft, prevScrollTop: this.state.prevScrollTop, editorPortalTarget: this.props.editorPortalTarget }));
          } }]), t3;
        }(c.default.Component);
        (0, s.default)(w, "displayName", "Viewport"), (0, s.default)(w, "propTypes", { rowOffsetHeight: g.default.number.isRequired, totalWidth: g.default.oneOfType([g.default.number, g.default.string]).isRequired, columnMetrics: g.default.object.isRequired, rowGetter: g.default.oneOfType([g.default.array, g.default.func]).isRequired, selectedRows: g.default.array, rowSelection: g.default.oneOfType([g.default.shape({ indexes: g.default.arrayOf(g.default.number).isRequired }), g.default.shape({ isSelectedKey: g.default.string.isRequired }), g.default.shape({ keys: g.default.shape({ values: g.default.array.isRequired, rowKey: g.default.string.isRequired }).isRequired })]), expandedRows: g.default.array, rowRenderer: g.default.oneOfType([g.default.element, g.default.func]), rowsCount: g.default.number.isRequired, rowHeight: g.default.number.isRequired, onRows: g.default.func, onScroll: g.default.func, minHeight: g.default.number, cellMetaData: g.default.shape(p.default), rowKey: g.default.string.isRequired, rowScrollTimeout: g.default.number, scrollToRowIndex: g.default.number, contextMenu: g.default.element, getSubRowDetails: g.default.func, rowGroupRenderer: g.default.func, enableCellSelect: g.default.bool.isRequired, enableCellAutoFocus: g.default.bool.isRequired, cellNavigationMode: g.default.string.isRequired, eventBus: g.default.object.isRequired, onCheckCellIsEditable: g.default.func, onCellCopyPaste: g.default.func, onGridRowsUpdated: g.default.func.isRequired, onDragHandleDoubleClick: g.default.func.isRequired, onCellSelected: g.default.func, onCellDeSelected: g.default.func, onCellRangeSelectionStarted: g.default.func, onCellRangeSelectionUpdated: g.default.func, onCellRangeSelectionCompleted: g.default.func, onCommit: g.default.func.isRequired, RowsContainer: g.default.node, editorPortalTarget: g.default.instanceOf(Element).isRequired }), (0, s.default)(w, "defaultProps", { rowHeight: 30 }), e2.exports = w;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(19), r = n(3), l = r(n(16)), a = r(n(47)), i = r(n(90)), u = r(n(4)), d = r(n(5)), s = r(n(7)), c = r(n(8)), f = r(n(13)), p = r(n(9)), g = r(n(11)), h = r(n(1)), m = r(n(10)), w = r(n(133)), C = r(n(223)), v = r(n(136)), b = o(n(91)), y = r(n(224)), R = n(137), x = n(238), S = n(18), E = n(29);
        n(69);
        var I = function(e3) {
          function t3() {
            var e4, n2;
            (0, u.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), l2 = 0; l2 < o2; l2++)
              r2[l2] = arguments[l2];
            return n2 = (0, s.default)(this, (e4 = (0, c.default)(t3)).call.apply(e4, [this].concat(r2))), (0, g.default)((0, f.default)(n2), "state", { scrollingTimeout: null }), (0, g.default)((0, f.default)(n2), "rows", []), (0, g.default)((0, f.default)(n2), "_currentRowsRange", { start: 0, end: 0 }), (0, g.default)((0, f.default)(n2), "_scroll", { scrollTop: 0, scrollLeft: 0 }), (0, g.default)((0, f.default)(n2), "onRows", function() {
              n2._currentRowsRange !== { start: 0, end: 0 } && (n2.props.onRows(n2._currentRowsRange), n2._currentRowsRange = { start: 0, end: 0 });
            }), (0, g.default)((0, f.default)(n2), "scrollToRow", function(e5) {
              var t4 = n2.props, o3 = t4.rowHeight, r3 = t4.rowsCount, l3 = t4.height;
              n2.canvas.scrollTop = Math.min(e5 * o3, r3 * o3 - l3);
            }), (0, g.default)((0, f.default)(n2), "onScroll", function(e5) {
              if (n2.canvas === e5.target) {
                var t4 = e5.target, o3 = t4.scrollLeft, r3 = { scrollTop: t4.scrollTop, scrollLeft: o3 };
                n2._scroll = r3, n2.props.onScroll(r3);
              }
            }), (0, g.default)((0, f.default)(n2), "getClientScrollTopOffset", function(e5) {
              var t4 = n2.props.rowHeight, o3 = e5.scrollTop % t4;
              return o3 > 0 ? t4 - o3 : 0;
            }), (0, g.default)((0, f.default)(n2), "onHitBottomCanvas", function() {
              var e5 = n2.props.rowHeight, t4 = n2.canvas;
              t4.scrollTop += e5 + n2.getClientScrollTopOffset(t4);
            }), (0, g.default)((0, f.default)(n2), "onHitTopCanvas", function() {
              var e5 = n2.props.rowHeight, t4 = n2.canvas;
              t4.scrollTop -= e5 - n2.getClientScrollTopOffset(t4);
            }), (0, g.default)((0, f.default)(n2), "scrollToColumn", function(e5) {
              var t4 = n2.canvas, o3 = t4.scrollLeft, r3 = t4.clientWidth, l3 = (0, x.getColumnScrollPosition)(n2.props.columns, e5, o3, r3);
              null != l3 && (n2.canvas.scrollLeft = o3 + l3);
            }), (0, g.default)((0, f.default)(n2), "onHitLeftCanvas", function(e5) {
              var t4 = e5.idx;
              n2.scrollToColumn(t4);
            }), (0, g.default)((0, f.default)(n2), "onHitRightCanvas", function(e5) {
              var t4 = e5.idx;
              n2.scrollToColumn(t4);
            }), (0, g.default)((0, f.default)(n2), "getRows", function(e5, t4) {
              if (n2._currentRowsRange = { start: e5, end: t4 }, Array.isArray(n2.props.rowGetter))
                return n2.props.rowGetter.slice(e5, t4);
              for (var o3 = [], r3 = e5; r3 < t4; ) {
                var l3 = n2.props.rowGetter(r3), a2 = {};
                n2.props.getSubRowDetails && (a2 = n2.props.getSubRowDetails(l3)), o3.push({ row: l3, subRowDetails: a2 }), r3++;
              }
              return o3;
            }), (0, g.default)((0, f.default)(n2), "getScroll", function() {
              var e5 = n2.canvas;
              return { scrollTop: e5.scrollTop, scrollLeft: e5.scrollLeft };
            }), (0, g.default)((0, f.default)(n2), "isRowSelected", function(e5, t4) {
              if (null !== n2.props.selectedRows) {
                var o3 = n2.props.selectedRows.filter(function(e6) {
                  var o4 = t4.get ? t4.get(n2.props.rowKey) : t4[n2.props.rowKey];
                  return e6[n2.props.rowKey] === o4;
                });
                return o3.length > 0 && o3[0].isSelected;
              }
              if (n2.props.rowSelection) {
                var r3 = n2.props.rowSelection, l3 = r3.keys, a2 = r3.indexes, i2 = r3.isSelectedKey;
                return b.isRowSelected(l3, a2, i2, t4, e5);
              }
              return false;
            }), (0, g.default)((0, f.default)(n2), "setScrollLeft", function(e5) {
              n2.interactionMasks && n2.interactionMasks.setScrollLeft && n2.interactionMasks.setScrollLeft(e5), n2.rows.forEach(function(t4, o3) {
                if (t4) {
                  var r3 = n2.getRowByRef(o3);
                  r3 && r3.setScrollLeft && r3.setScrollLeft(e5);
                }
              });
            }), (0, g.default)((0, f.default)(n2), "getRowByRef", function(e5) {
              var t4 = n2.rows[e5] && n2.rows[e5].getDecoratedComponentInstance ? n2.rows[e5].getDecoratedComponentInstance(e5) : null;
              return t4 ? t4.row : n2.rows[e5];
            }), (0, g.default)((0, f.default)(n2), "getRowTop", function(e5) {
              var t4 = n2.getRowByRef(e5);
              return t4 && (0, S.isFunction)(t4.getRowTop) ? t4.getRowTop() : n2.props.rowHeight * e5;
            }), (0, g.default)((0, f.default)(n2), "getRowHeight", function(e5) {
              var t4 = n2.getRowByRef(e5);
              return t4 && (0, S.isFunction)(t4.getRowHeight) ? t4.getRowHeight() : n2.props.rowHeight;
            }), (0, g.default)((0, f.default)(n2), "getRowColumns", function(e5) {
              var t4 = n2.getRowByRef(e5);
              return t4 && t4.props ? t4.props.columns : n2.props.columns;
            }), (0, g.default)((0, f.default)(n2), "setCanvasRef", function(e5) {
              n2.canvas = e5;
            }), (0, g.default)((0, f.default)(n2), "setRowRef", function(e5) {
              return function(t4) {
                n2.rows[e5] = t4;
              };
            }), (0, g.default)((0, f.default)(n2), "setInteractionMasksRef", function(e5) {
              n2.interactionMasks = e5;
            }), (0, g.default)((0, f.default)(n2), "renderRow", function(e5) {
              var t4 = e5.row;
              return t4.__metaData && t4.__metaData.getRowRenderer ? t4.__metaData.getRowRenderer(n2.props, e5.idx) : t4.__metaData && t4.__metaData.isGroup ? n2.renderGroupRow(e5) : n2.props.rowRenderer ? n2.renderCustomRowRenderer(e5) : h.default.createElement(w.default, e5);
            }), (0, g.default)((0, f.default)(n2), "renderPlaceholder", function(e5, t4) {
              return h.default.createElement("div", { key: e5, style: { height: t4 } }, n2.props.columns.map(function(e6, t5) {
                return h.default.createElement("div", { style: { width: e6.width }, key: t5 });
              }));
            }), n2;
          }
          return (0, p.default)(t3, e3), (0, d.default)(t3, [{ key: "componentDidMount", value: function e4() {
            this.unsubscribeScrollToColumn = this.props.eventBus.subscribe(E.EventTypes.SCROLL_TO_COLUMN, this.scrollToColumn), this.onRows();
          } }, { key: "componentWillUnmount", value: function e4() {
            this._currentRowsRange = { start: 0, end: 0 }, this._scroll = { scrollTop: 0, scrollLeft: 0 }, this.rows = [], this.unsubscribeScrollToColumn();
          } }, { key: "componentDidUpdate", value: function e4(t4) {
            var n2 = this.props.scrollToRowIndex;
            t4.scrollToRowIndex !== n2 && 0 !== n2 && this.scrollToRow(n2), this.onRows();
          } }, { key: "renderCustomRowRenderer", value: function e4(t4) {
            var n2 = t4.ref, o2 = (0, i.default)(t4, ["ref"]), r2 = this.props.rowRenderer, u2 = (0, a.default)({}, o2, { renderBaseRow: function e5(t5) {
              return h.default.createElement(w.default, (0, l.default)({ ref: n2 }, t5));
            } });
            return r2.type === w.default ? h.default.createElement(w.default, t4) : (0, S.isFunction)(r2) ? h.default.createElement(r2, u2) : h.default.isValidElement(r2) ? h.default.cloneElement(r2, u2) : void 0;
          } }, { key: "renderGroupRow", value: function e4(t4) {
            var n2 = t4.ref, o2 = (0, i.default)(t4, ["ref"]);
            return h.default.createElement(y.default, (0, l.default)({}, o2, t4.row.__metaData, { rowRef: t4.ref, name: t4.row.name, eventBus: this.props.eventBus, renderer: this.props.rowGroupRenderer, renderBaseRow: function e5(t5) {
              return h.default.createElement(w.default, (0, l.default)({ ref: n2 }, t5));
            } }));
          } }, { key: "render", value: function e4() {
            var t4 = this, n2 = this.props, o2 = n2.rowOverscanStartIdx, r2 = n2.rowOverscanEndIdx, l2 = n2.cellMetaData, a2 = n2.columns, i2 = n2.colOverscanStartIdx, u2 = n2.colOverscanEndIdx, d2 = n2.colVisibleStartIdx, s2 = n2.colVisibleEndIdx, c2 = n2.lastFrozenColumnIndex, f2 = n2.expandedRows, p2 = n2.rowHeight, g2 = n2.rowsCount, m2 = n2.totalColumnWidth, w2 = n2.totalWidth, C2 = n2.height, v2 = n2.rowGetter, b2 = n2.RowsContainer, y2 = n2.contextMenu, x2 = this.getRows(o2, r2).map(function(e5, n3) {
              var g3 = o2 + n3, h3 = "row-".concat(g3);
              return e5.row && t4.renderRow({ key: h3, ref: t4.setRowRef(g3), idx: g3, rowVisibleStartIdx: t4.props.rowVisibleStartIdx, rowVisibleEndIdx: t4.props.rowVisibleEndIdx, row: e5.row, height: p2, onMouseOver: t4.onMouseOver, columns: a2, isSelected: t4.isRowSelected(g3, e5.row, o2, r2), expandedRows: f2, cellMetaData: l2, subRowDetails: e5.subRowDetails, colVisibleStartIdx: d2, colVisibleEndIdx: s2, colOverscanStartIdx: i2, colOverscanEndIdx: u2, lastFrozenColumnIndex: c2, isScrolling: t4.props.isScrolling, scrollLeft: t4._scroll.scrollLeft });
            });
            o2 > 0 && x2.unshift(this.renderPlaceholder("top", o2 * p2)), g2 - r2 > 0 && x2.push(this.renderPlaceholder("bottom", (g2 - r2) * p2));
            var S2 = { position: "absolute", top: 0, left: 0, overflowX: "auto", overflowY: "scroll", width: w2, height: C2 };
            return h.default.createElement("div", { ref: this.setCanvasRef, style: S2, onScroll: this.onScroll, className: "react-grid-Canvas" }, h.default.createElement(R.InteractionMasks, { ref: this.setInteractionMasksRef, rowGetter: v2, rowsCount: g2, width: this.props.totalWidth, height: C2, rowHeight: p2, columns: a2, rowOverscanStartIdx: this.props.rowOverscanStartIdx, rowVisibleStartIdx: this.props.rowVisibleStartIdx, rowVisibleEndIdx: this.props.rowVisibleEndIdx, colVisibleStartIdx: d2, colVisibleEndIdx: s2, enableCellSelect: this.props.enableCellSelect, enableCellAutoFocus: this.props.enableCellAutoFocus, cellNavigationMode: this.props.cellNavigationMode, eventBus: this.props.eventBus, contextMenu: this.props.contextMenu, onHitBottomBoundary: this.onHitBottomCanvas, onHitTopBoundary: this.onHitTopCanvas, onHitLeftBoundary: this.onHitLeftCanvas, onHitRightBoundary: this.onHitRightCanvas, onCommit: this.props.onCommit, onCheckCellIsEditable: this.props.onCheckCellIsEditable, onCellCopyPaste: this.props.onCellCopyPaste, onGridRowsUpdated: this.props.onGridRowsUpdated, onDragHandleDoubleClick: this.props.onDragHandleDoubleClick, onCellSelected: this.props.onCellSelected, onCellDeSelected: this.props.onCellDeSelected, onCellRangeSelectionStarted: this.props.onCellRangeSelectionStarted, onCellRangeSelectionUpdated: this.props.onCellRangeSelectionUpdated, onCellRangeSelectionCompleted: this.props.onCellRangeSelectionCompleted, scrollLeft: this._scroll.scrollLeft, scrollTop: this._scroll.scrollTop, getRowHeight: this.getRowHeight, getRowTop: this.getRowTop, getRowColumns: this.getRowColumns, editorPortalTarget: this.props.editorPortalTarget }), h.default.createElement(b2, { id: y2 ? y2.props.id : "rowsContainer" }, h.default.createElement("div", { style: { width: m2 } }, x2)));
          } }]), t3;
        }(h.default.PureComponent);
        (0, g.default)(I, "displayName", "Canvas"), (0, g.default)(I, "propTypes", { rowRenderer: m.default.oneOfType([m.default.func, m.default.element]), rowHeight: m.default.number.isRequired, height: m.default.number.isRequired, width: m.default.number, totalWidth: m.default.oneOfType([m.default.number, m.default.string]), style: m.default.string, className: m.default.string, rowOverscanStartIdx: m.default.number.isRequired, rowOverscanEndIdx: m.default.number.isRequired, rowVisibleStartIdx: m.default.number.isRequired, rowVisibleEndIdx: m.default.number.isRequired, colVisibleStartIdx: m.default.number.isRequired, colVisibleEndIdx: m.default.number.isRequired, colOverscanStartIdx: m.default.number.isRequired, colOverscanEndIdx: m.default.number.isRequired, rowsCount: m.default.number.isRequired, rowGetter: m.default.oneOfType([m.default.func.isRequired, m.default.array.isRequired]), expandedRows: m.default.array, onRows: m.default.func, onScroll: m.default.func, columns: m.default.oneOfType([m.default.object, m.default.array]).isRequired, cellMetaData: m.default.shape(v.default).isRequired, selectedRows: m.default.array, rowKey: m.default.string, rowScrollTimeout: m.default.number, scrollToRowIndex: m.default.number, contextMenu: m.default.element, getSubRowDetails: m.default.func, rowSelection: m.default.oneOfType([m.default.shape({ indexes: m.default.arrayOf(m.default.number).isRequired }), m.default.shape({ isSelectedKey: m.default.string.isRequired }), m.default.shape({ keys: m.default.shape({ values: m.default.array.isRequired, rowKey: m.default.string.isRequired }).isRequired })]), rowGroupRenderer: m.default.func, isScrolling: m.default.bool, length: m.default.number, enableCellSelect: m.default.bool.isRequired, enableCellAutoFocus: m.default.bool.isRequired, cellNavigationMode: m.default.string.isRequired, eventBus: m.default.object.isRequired, onCheckCellIsEditable: m.default.func, onCellCopyPaste: m.default.func, onGridRowsUpdated: m.default.func.isRequired, onDragHandleDoubleClick: m.default.func.isRequired, onCellSelected: m.default.func, onCellDeSelected: m.default.func, onCellRangeSelectionStarted: m.default.func, onCellRangeSelectionUpdated: m.default.func, onCellRangeSelectionCompleted: m.default.func, onCommit: m.default.func.isRequired, editorPortalTarget: m.default.instanceOf(Element).isRequired }), (0, g.default)(I, "defaultProps", { onRows: function e3() {
        }, selectedRows: [], rowScrollTimeout: 0, scrollToRowIndex: 0, RowsContainer: C.default }), e2.exports = I;
      }, function(e2, t2) {
        e2.exports = function n(e3, t3) {
          if (null == e3)
            return {};
          var n2, o, r = {}, l = Object.keys(e3);
          for (o = 0; o < l.length; o++)
            n2 = l[o], t3.indexOf(n2) >= 0 || (r[n2] = e3[n2]);
          return r;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(49)), f = o(n(1)), p = o(n(10)), g = o(n(136)), h = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "state", { isMenuOpen: false }), (0, s.default)((0, u.default)(n2), "onToggleMenu", function() {
              n2.setState(function(e5) {
                return { isMenuOpen: !e5.isMenuOpen };
              });
            }), (0, s.default)((0, u.default)(n2), "onHideMenu", function() {
              n2.setState({ isMenuOpen: false });
            }), (0, s.default)((0, u.default)(n2), "onGetMenuOptions", function() {
              return n2.props.action.actions.map(function(e5, t4) {
                return f.default.createElement("span", { key: t4, onClick: e5.callback }, e5.text);
              });
            }), (0, s.default)((0, u.default)(n2), "isActionMenu", function() {
              return !n2.props.action.callback && n2.props.action.actions && n2.props.action.actions.length;
            }), (0, s.default)((0, u.default)(n2), "onActionButtonBlur", function() {
              n2.isActionMenu() && n2.onHideMenu();
            }), (0, s.default)((0, u.default)(n2), "onActionIconClick", function() {
              n2.isActionMenu() ? n2.props.action.actions && n2.props.action.actions.length && n2.onToggleMenu() : n2.props.action.callback();
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "render", value: function e4() {
            var t4 = this.isActionMenu(), n2 = (0, c.default)("rdg-cell-action", { "rdg-cell-action-last": this.props.isFirst }), o2 = (0, c.default)("rdg-cell-action-button", { "rdg-cell-action-button-toggled": this.state.isMenuOpen });
            return f.default.createElement("div", { className: n2, onMouseLeave: this.onActionButtonBlur }, f.default.createElement("div", { className: o2, onClick: this.onActionIconClick }, "string" === typeof this.props.action.icon ? f.default.createElement("span", { className: this.props.action.icon }) : this.props.action.icon), t4 && this.state.isMenuOpen && f.default.createElement("div", { className: "rdg-cell-action-menu" }, this.onGetMenuOptions()));
          } }]), t3;
        }(f.default.Component);
        (0, s.default)(h, "propTypes", { action: p.default.shape(g.default).isRequired, isFirst: p.default.bool.isRequired });
        var m = h;
        t2.default = m;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(1)), f = o(n(10)), p = n(29), g = function(e3) {
          function t3(e4) {
            var n2;
            (0, r.default)(this, t3), n2 = (0, a.default)(this, (0, i.default)(t3).call(this, e4)), (0, s.default)((0, u.default)(n2), "onCellExpand", function(e5) {
              n2.setState({ expanded: !n2.state.expanded }), n2.props.onCellExpand(e5);
            });
            var o2 = e4.expandableOptions && e4.expandableOptions.expanded;
            return n2.state = { expanded: o2 }, n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "componentWillReceiveProps", value: function e4(t4) {
            var n2 = t4.expandableOptions && t4.expandableOptions.expanded;
            this.state.expanded !== n2 && this.setState({ expanded: n2 });
          } }, { key: "render", value: function e4() {
            return c.default.createElement("div", { className: "rdg-cell-expand" }, c.default.createElement("span", { onClick: this.onCellExpand }, this.state.expanded ? p.CellExpand.DOWN_TRIANGLE : p.CellExpand.RIGHT_TRIANGLE));
          } }]), t3;
        }(c.default.Component);
        (0, s.default)(g, "propTypes", { expandableOptions: f.default.object.isRequired, onCellExpand: f.default.func.isRequired });
        var h = g;
        t2.default = h;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(1)), l = o(n(49)), a = function e3(t3) {
          var n2 = t3.treeDepth, o2 = t3.cellHeight, a2 = t3.siblingIndex, i = t3.numberSiblings, u = t3.onDeleteSubRow, d = t3.isDeleteSubRowEnabled, s = t3.allowAddChildRow, c = void 0 === s || s, f = a2 === i - 1, p = (0, l.default)({ "rdg-child-row-action-cross": true === c || !f }, { "rdg-child-row-action-cross-last": false === c && (f || 1 === i) }), g = 15 * n2, h = (o2 - 12) / 2;
          return r.default.createElement("div", null, r.default.createElement("div", { className: p }), d && r.default.createElement("div", { style: { left: g, top: h, width: 12, height: 12 }, className: "rdg-child-row-btn", onClick: u }, r.default.createElement("div", { className: "glyphicon glyphicon-remove-sign" })));
        };
        t2.default = a;
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        t2.default = function e3(t3) {
          return t3.children;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(19), r = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var l = r(n(16)), a = r(n(4)), i = r(n(5)), u = r(n(7)), d = r(n(8)), s = r(n(13)), c = r(n(9)), f = r(n(11)), p = o(n(1)), g = r(n(10)), h = n(18), m = r(n(66)), w = n(29);
        n(63);
        var C = function(e3) {
          function t3() {
            var e4, n2;
            (0, a.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), l2 = 0; l2 < o2; l2++)
              r2[l2] = arguments[l2];
            return n2 = (0, u.default)(this, (e4 = (0, d.default)(t3)).call.apply(e4, [this].concat(r2))), (0, f.default)((0, s.default)(n2), "onRowExpandToggle", function(e5) {
              var t4 = null == e5 ? !n2.props.isExpanded : e5, o3 = n2.props.cellMetaData;
              null != o3 && "function" === typeof o3.onRowExpandToggle && o3.onRowExpandToggle({ rowIdx: n2.props.idx, shouldExpand: t4, columnGroupName: n2.props.columnGroupName, name: n2.props.name });
            }), (0, f.default)((0, s.default)(n2), "onClick", function() {
              n2.props.eventBus.dispatch(w.EventTypes.SELECT_CELL, { rowIdx: n2.props.idx });
            }), (0, f.default)((0, s.default)(n2), "onRowExpandClick", function() {
              n2.onRowExpandToggle(!n2.props.isExpanded);
            }), n2;
          }
          return (0, c.default)(t3, e3), (0, i.default)(t3, [{ key: "render", value: function e4() {
            var t4 = (0, h.last)(this.props.columns), n2 = { width: t4.left + t4.width };
            return p.default.createElement("div", { style: n2, className: "react-grid-row-group", onClick: this.onClick }, p.default.createElement(this.props.renderer, (0, l.default)({}, this.props, { onRowExpandClick: this.onRowExpandClick, onRowExpandToggle: this.onRowExpandToggle })));
          } }]), t3;
        }(p.Component);
        C.propTypes = { height: g.default.number.isRequired, columns: g.default.oneOfType([g.default.object, g.default.array]).isRequired, row: g.default.any.isRequired, cellRenderer: g.default.func, cellMetaData: g.default.shape(m.default), isSelected: g.default.bool, idx: g.default.number.isRequired, expandedRows: g.default.arrayOf(g.default.object), extraClasses: g.default.string, forceUpdate: g.default.bool, subRowDetails: g.default.object, isRowHovered: g.default.bool, colVisibleStartIdx: g.default.number.isRequired, colVisibleEndIdx: g.default.number.isRequired, colOverscanStartIdx: g.default.number.isRequired, colOverscanEndIdx: g.default.number.isRequired, isScrolling: g.default.bool.isRequired, columnGroupName: g.default.string.isRequired, isExpanded: g.default.bool.isRequired, treeDepth: g.default.number.isRequired, name: g.default.string.isRequired, renderer: g.default.func, eventBus: g.default.object.isRequired, rowRef: g.default.func.isRequired };
        var v = function(e3) {
          function t3() {
            var e4, n2;
            (0, a.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), l2 = 0; l2 < o2; l2++)
              r2[l2] = arguments[l2];
            return n2 = (0, u.default)(this, (e4 = (0, d.default)(t3)).call.apply(e4, [this].concat(r2))), (0, f.default)((0, s.default)(n2), "onKeyDown", function(e5) {
              var t4 = n2.props, o3 = t4.onRowExpandToggle, r3 = t4.isExpanded;
              "ArrowLeft" === e5.key && o3(false), "ArrowRight" === e5.key && o3(true), "Enter" === e5.key && o3(!r3);
            }), n2;
          }
          return (0, c.default)(t3, e3), (0, i.default)(t3, [{ key: "render", value: function e4() {
            var t4 = this.props, n2 = t4.treeDepth, o2 = void 0 === n2 ? 0 : n2, r2 = t4.height, l2 = t4.rowRef, a2 = t4.onRowExpandClick, i2 = t4.isExpanded, u2 = t4.columnGroupDisplayName, d2 = t4.name, s2 = 20 * o2, c2 = { height: r2, border: "1px solid #dddddd", paddingTop: "15px", paddingLeft: "5px" };
            return p.default.createElement("div", { style: c2, onKeyDown: this.onKeyDown, tabIndex: 0, ref: l2 }, p.default.createElement("span", { className: "row-expand-icon", style: { float: "left", marginLeft: s2, cursor: "pointer" }, onClick: a2 }, i2 ? String.fromCharCode(9660) : String.fromCharCode(9658)), p.default.createElement("strong", null, u2, ": ", d2));
          } }]), t3;
        }(p.Component);
        v.propTypes = { onRowExpandClick: g.default.func.isRequired, onRowExpandToggle: g.default.func.isRequired, isExpanded: g.default.bool.isRequired, height: g.default.number.isRequired, treeDepth: g.default.number.isRequired, name: g.default.string.isRequired, columnGroupName: g.default.string.isRequired, columnGroupDisplayName: g.default.string.isRequired, rowRef: g.default.func.isRequired, hideColumnName: g.default.bool }, C.defaultProps = { renderer: v };
        var b = C;
        t2.default = b;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(4)), l = o(n(5)), a = o(n(11)), i = function() {
          function e3() {
            (0, r.default)(this, e3), (0, a.default)(this, "subscribers", {});
          }
          return (0, l.default)(e3, [{ key: "subscribe", value: function e4(t3, n2) {
            this.subscribers[t3] || (this.subscribers[t3] = []);
            var o2 = this.subscribers[t3];
            return o2.push(n2), function() {
              var e5 = o2.indexOf(n2);
              e5 > 0 && o2.splice(e5, 1);
            };
          } }, { key: "dispatch", value: function e4(t3) {
            for (var n2 = arguments.length, o2 = new Array(n2 > 1 ? n2 - 1 : 0), r2 = 1; r2 < n2; r2++)
              o2[r2 - 1] = arguments[r2];
            var l2 = this.subscribers[t3];
            Array.isArray(l2) && l2.forEach(function(e5) {
              return e5.apply(void 0, o2);
            });
          } }]), e3;
        }();
        t2.default = i;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(19), r = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var l = r(n(16)), a = r(n(90)), i = r(n(47)), u = r(n(4)), d = r(n(5)), s = r(n(7)), c = r(n(8)), f = r(n(13)), p = r(n(9)), g = r(n(11)), h = o(n(1)), m = r(n(10)), w = r(n(227)), C = r(n(228)), v = r(n(229)), b = r(n(230)), y = r(n(231)), R = r(n(232)), x = r(n(235)), S = n(29), E = n(140), I = n(138), D = n(18), k = n(25), O = o(n(141));
        n(236);
        var T = function(e3) {
          function t3() {
            var e4, n2;
            (0, u.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), l2 = 0; l2 < o2; l2++)
              r2[l2] = arguments[l2];
            return n2 = (0, s.default)(this, (e4 = (0, c.default)(t3)).call.apply(e4, [this].concat(r2))), (0, g.default)((0, f.default)(n2), "state", { selectedPosition: { idx: -1, rowIdx: -1 }, selectedRange: { topLeft: { idx: -1, rowIdx: -1 }, bottomRight: { idx: -1, rowIdx: -1 } }, copiedPosition: null, draggedPosition: null, isEditorEnabled: false, firstEditorKeyPress: null }), (0, g.default)((0, f.default)(n2), "getEditorPosition", function() {
              if (n2.selectionMask) {
                var e5 = n2.props.editorPortalTarget, t4 = n2.selectionMask.getBoundingClientRect(), o3 = t4.left, r3 = t4.top;
                if (e5 === document.body) {
                  var l3 = document.scrollingElement || document.documentElement;
                  return { left: o3 + l3.scrollLeft, top: r3 + l3.scrollTop };
                }
                var a2 = e5.getBoundingClientRect(), i2 = a2.left, u2 = a2.top;
                return { left: o3 - i2 + e5.scrollLeft, top: r3 - u2 + e5.scrollTop };
              }
            }), (0, g.default)((0, f.default)(n2), "setMaskScollLeft", function(e5, t4, o3) {
              if (e5) {
                var r3 = t4.idx, l3 = t4.rowIdx;
                if (r3 >= 0 && l3 >= 0) {
                  var a2 = n2.props, i2 = a2.columns, u2 = a2.getRowTop, d2 = (0, k.getColumn)(i2, r3);
                  if ((0, k.isFrozen)(d2)) {
                    var s2 = u2(l3), c2 = o3 + d2.left, f2 = "translate(".concat(c2, "px, ").concat(s2, "px)");
                    e5.style.transform !== f2 && (e5.style.transform = f2);
                  }
                }
              }
            }), (0, g.default)((0, f.default)(n2), "setScrollLeft", function(e5) {
              var t4 = (0, f.default)(n2), o3 = t4.selectionMask, r3 = t4.copyMask, l3 = t4.state, a2 = l3.selectedPosition, i2 = l3.copiedPosition;
              n2.setMaskScollLeft(o3, a2, e5), n2.setMaskScollLeft(r3, i2, e5);
            }), (0, g.default)((0, f.default)(n2), "onKeyDown", function(e5) {
              (0, E.isCtrlKeyHeldDown)(e5) ? n2.onPressKeyWithCtrl(e5) : e5.keyCode === O.Escape ? n2.onPressEscape(e5) : e5.keyCode === O.Tab ? n2.onPressTab(e5) : n2.isKeyboardNavigationEvent(e5) ? n2.changeCellFromEvent(e5) : ((0, E.isKeyPrintable)(e5.keyCode) || -1 !== [O.Backspace, O.Delete, O.Enter].indexOf(e5.keyCode)) && n2.openEditor(e5);
            }), (0, g.default)((0, f.default)(n2), "isSelectedCellEditable", function() {
              var e5 = n2.props, t4 = e5.enableCellSelect, o3 = e5.columns, r3 = e5.rowGetter, l3 = e5.onCheckCellIsEditable, a2 = n2.state.selectedPosition;
              return (0, I.isSelectedCellEditable)({ enableCellSelect: t4, columns: o3, rowGetter: r3, selectedPosition: a2, onCheckCellIsEditable: l3 });
            }), (0, g.default)((0, f.default)(n2), "openEditor", function() {
              var e5 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).key;
              n2.isSelectedCellEditable() && !n2.state.isEditorEnabled && n2.setState({ isEditorEnabled: true, firstEditorKeyPress: e5, editorPosition: n2.getEditorPosition() });
            }), (0, g.default)((0, f.default)(n2), "closeEditor", function() {
              n2.setState({ isEditorEnabled: false, firstEditorKeyPress: null, editorPosition: null });
            }), (0, g.default)((0, f.default)(n2), "onPressKeyWithCtrl", function(e5) {
              var t4 = e5.keyCode;
              if (n2.copyPasteEnabled())
                if (t4 === O.c) {
                  var o3 = n2.props, r3 = o3.columns, l3 = o3.rowGetter, a2 = n2.state.selectedPosition, i2 = (0, I.getSelectedCellValue)({ selectedPosition: a2, columns: r3, rowGetter: l3 });
                  n2.handleCopy({ value: i2 });
                } else
                  t4 === O.v && n2.handlePaste();
            }), (0, g.default)((0, f.default)(n2), "onFocus", function(e5) {
              var t4 = true === e5.shiftKey, o3 = n2.state.selectedPosition, r3 = o3.idx, l3 = o3.rowIdx;
              -1 === r3 && -1 === l3 && (t4 ? n2.selectLastCell() : n2.selectFirstCell());
            }), (0, g.default)((0, f.default)(n2), "onPressTab", function(e5) {
              var t4 = n2.props, o3 = t4.cellNavigationMode, r3 = t4.columns, l3 = t4.rowsCount, a2 = n2.state, i2 = a2.selectedPosition, u2 = a2.isEditorEnabled;
              if (0 !== l3)
                return (0, I.canExitGrid)(e5, { cellNavigationMode: o3, columns: r3, rowsCount: l3, selectedPosition: i2 }) ? u2 ? void n2.closeEditor() : void n2.setState({ selectedPosition: { idx: -1, rowIdx: -1 } }) : void n2.changeCellFromEvent(e5);
            }), (0, g.default)((0, f.default)(n2), "onPressEscape", function() {
              n2.copyPasteEnabled() && (n2.handleCancelCopy(), n2.closeEditor());
            }), (0, g.default)((0, f.default)(n2), "copyPasteEnabled", function() {
              return null !== n2.props.onCellCopyPaste && n2.isSelectedCellEditable();
            }), (0, g.default)((0, f.default)(n2), "handleCopy", function(e5) {
              var t4 = e5.value, o3 = n2.state.selectedPosition, r3 = o3.rowIdx, l3 = o3.idx;
              n2.setState({ copiedPosition: { rowIdx: r3, idx: l3, value: t4 } });
            }), (0, g.default)((0, f.default)(n2), "handleCancelCopy", function() {
              n2.setState({ copiedPosition: null });
            }), (0, g.default)((0, f.default)(n2), "handlePaste", function() {
              var e5 = n2.props, t4 = e5.columns, o3 = e5.onCellCopyPaste, r3 = e5.onGridRowsUpdated, l3 = n2.state, a2 = l3.selectedPosition, i2 = l3.copiedPosition, u2 = a2.rowIdx;
              if (null != i2) {
                var d2 = (0, I.getSelectedColumn)({ selectedPosition: a2, columns: t4 }).key, s2 = i2.rowIdx, c2 = i2.value;
                (0, D.isFunction)(o3) && o3({ cellKey: d2, rowIdx: u2, fromRow: s2, toRow: u2, value: c2 }), r3(d2, u2, u2, (0, g.default)({}, d2, c2), S.UpdateActions.COPY_PASTE, s2);
              }
            }), (0, g.default)((0, f.default)(n2), "isCellWithinBounds", function(e5) {
              var t4 = e5.idx, o3 = e5.rowIdx, r3 = n2.props, l3 = r3.columns, a2 = r3.rowsCount;
              return o3 >= 0 && o3 < a2 && t4 >= 0 && t4 < (0, k.getSize)(l3);
            }), (0, g.default)((0, f.default)(n2), "isGridSelected", function() {
              return n2.isCellWithinBounds(n2.state.selectedPosition);
            }), (0, g.default)((0, f.default)(n2), "isFocused", function() {
              return document.activeElement === n2.selectionMask;
            }), (0, g.default)((0, f.default)(n2), "isFocusedOnBody", function() {
              return document.activeElement === document.body;
            }), (0, g.default)((0, f.default)(n2), "focus", function() {
              n2.selectionMask && !n2.isFocused() && n2.selectionMask.focus();
            }), (0, g.default)((0, f.default)(n2), "selectFirstCell", function() {
              n2.selectCell({ rowIdx: 0, idx: 0 });
            }), (0, g.default)((0, f.default)(n2), "selectLastCell", function() {
              var e5 = n2.props, t4 = e5.rowsCount, o3 = e5.columns;
              n2.selectCell({ rowIdx: t4 - 1, idx: (0, k.getSize)(o3) - 1 });
            }), (0, g.default)((0, f.default)(n2), "selectCell", function(e5, t4) {
              var o3 = t4 ? n2.openEditor : function() {
                return null;
              };
              n2.state.isEditorEnabled && n2.closeEditor(), n2.setState(function(t5) {
                var o4 = (0, i.default)({}, t5.selectedPosition, e5);
                return n2.isCellWithinBounds(o4) ? { selectedPosition: o4, selectedRange: { topLeft: o4, bottomRight: o4, startCell: o4, cursorCell: o4, isDragging: false } } : t5;
              }, o3);
            }), (0, g.default)((0, f.default)(n2), "onSelectCellRangeStarted", function(e5) {
              n2.setState({ selectedRange: n2.createSingleCellSelectedRange(e5, true), selectedPosition: e5 }, function() {
                (0, D.isFunction)(n2.props.onCellRangeSelectionStarted) && n2.props.onCellRangeSelectionStarted(n2.state.selectedRange);
              });
            }), (0, g.default)((0, f.default)(n2), "onSelectCellRangeUpdated", function(e5, t4, o3) {
              if ((n2.state.selectedRange.isDragging || t4) && n2.isCellWithinBounds(e5)) {
                var r3 = n2.state.selectedRange.startCell || n2.state.selectedPosition, l3 = [r3.idx, e5.idx].sort(function(e6, t5) {
                  return e6 - t5;
                }), a2 = [r3.rowIdx, e5.rowIdx].sort(function(e6, t5) {
                  return e6 - t5;
                }), u2 = { idx: l3[0], rowIdx: a2[0] }, d2 = { idx: l3[1], rowIdx: a2[1] }, s2 = (0, i.default)({ startCell: n2.state.selectedPosition }, n2.state.selectedRange, { topLeft: u2, bottomRight: d2, cursorCell: e5 });
                n2.setState({ selectedRange: s2 }, function() {
                  (0, D.isFunction)(n2.props.onCellRangeSelectionUpdated) && n2.props.onCellRangeSelectionUpdated(n2.state.selectedRange), (0, D.isFunction)(o3) && o3();
                });
              }
            }), (0, g.default)((0, f.default)(n2), "onSelectCellRangeEnded", function() {
              var e5 = (0, i.default)({}, n2.state.selectedRange, { isDragging: false });
              n2.setState({ selectedRange: e5 }, function() {
                (0, D.isFunction)(n2.props.onCellRangeSelectionCompleted) && n2.props.onCellRangeSelectionCompleted(n2.state.selectedRange), n2.focus();
              });
            }), (0, g.default)((0, f.default)(n2), "isDragEnabled", function() {
              var e5 = n2.props, t4 = e5.onGridRowsUpdated, o3 = e5.onCellsDragged;
              return n2.isSelectedCellEditable() && ((0, D.isFunction)(t4) || (0, D.isFunction)(o3));
            }), (0, g.default)((0, f.default)(n2), "handleDragStart", function(e5) {
              var t4 = n2.state.selectedPosition, o3 = t4.idx, r3 = t4.rowIdx, l3 = e5 && e5.target && e5.target.className;
              if (o3 > -1 && l3) {
                e5.dataTransfer.effectAllowed = "copy";
                var a2 = JSON.stringify({ idx: o3, rowIdx: r3 });
                try {
                  e5.dataTransfer.setData("text/plain", a2);
                } catch (i2) {
                  e5.dataTransfer.setData("text", a2);
                }
                n2.setState({ draggedPosition: { idx: o3, rowIdx: r3 } });
              }
            }), (0, g.default)((0, f.default)(n2), "handleDragEnter", function(e5) {
              var t4 = e5.overRowIdx;
              null != n2.state.draggedPosition && n2.setState(function(e6) {
                var n3 = e6.draggedPosition;
                return { draggedPosition: (0, i.default)({}, n3, { overRowIdx: t4 }) };
              });
            }), (0, g.default)((0, f.default)(n2), "handleDragEnd", function() {
              var e5 = n2.state.draggedPosition;
              if (null != e5) {
                var t4 = e5.rowIdx, o3 = e5.overRowIdx;
                if (null != o3) {
                  var r3 = n2.props, l3 = r3.columns, a2 = r3.onCellsDragged, i2 = r3.onGridRowsUpdated, u2 = r3.rowGetter, d2 = (0, I.getSelectedColumn)({ selectedPosition: e5, columns: l3 }), s2 = (0, I.getSelectedCellValue)({ selectedPosition: e5, columns: l3, rowGetter: u2 }), c2 = d2.key, f2 = t4 < o3 ? t4 : o3, p2 = t4 > o3 ? t4 : o3;
                  (0, D.isFunction)(a2) && a2({ cellKey: c2, fromRow: f2, toRow: p2, value: s2 }), (0, D.isFunction)(i2) && i2(c2, f2, p2, (0, g.default)({}, c2, s2), S.UpdateActions.CELL_DRAG);
                }
                n2.setState({ draggedPosition: null });
              }
            }), (0, g.default)((0, f.default)(n2), "onDragHandleDoubleClick", function() {
              var e5 = n2.props, t4 = e5.onDragHandleDoubleClick, o3 = e5.rowGetter, r3 = n2.state.selectedPosition;
              t4({ idx: r3.idx, rowIdx: r3.rowIdx, rowData: (0, I.getSelectedRow)({ selectedPosition: r3, rowGetter: o3 }) });
            }), (0, g.default)((0, f.default)(n2), "onCommit", function() {
              var e5;
              (e5 = n2.props).onCommit.apply(e5, arguments), n2.closeEditor();
            }), (0, g.default)((0, f.default)(n2), "onCommitCancel", function() {
              n2.closeEditor();
            }), (0, g.default)((0, f.default)(n2), "setSelectionMaskRef", function(e5) {
              n2.selectionMask = e5;
            }), (0, g.default)((0, f.default)(n2), "setCopyMaskRef", function(e5) {
              n2.copyMask = e5;
            }), (0, g.default)((0, f.default)(n2), "getSelectedDimensions", function(e5, t4) {
              var o3 = n2.props, r3 = o3.scrollLeft, l3 = o3.getRowHeight, a2 = o3.getRowTop, u2 = o3.getRowColumns, d2 = o3.columns, s2 = t4 ? d2 : u2(e5.rowIdx), c2 = a2(e5.rowIdx), f2 = l3(e5.rowIdx);
              return (0, i.default)({}, (0, I.getSelectedDimensions)({ selectedPosition: e5, columns: s2, scrollLeft: r3, rowHeight: f2 }), { top: c2 });
            }), (0, g.default)((0, f.default)(n2), "renderSingleCellSelectView", function() {
              var e5 = n2.state.selectedPosition;
              return !n2.state.isEditorEnabled && n2.isGridSelected() && h.default.createElement(w.default, { selectedPosition: e5, innerRef: n2.setSelectionMaskRef, getSelectedDimensions: n2.getSelectedDimensions }, n2.isDragEnabled() && h.default.createElement(y.default, { onDragStart: n2.handleDragStart, onDragEnd: n2.handleDragEnd, onDoubleClick: n2.onDragHandleDoubleClick }));
            }), (0, g.default)((0, f.default)(n2), "renderCellRangeSelectView", function() {
              var e5 = n2.props, t4 = e5.columns, o3 = e5.rowHeight;
              return [h.default.createElement(C.default, { key: "range-mask", selectedRange: n2.state.selectedRange, columns: t4, rowHeight: o3 }), h.default.createElement(w.default, { key: "selection-mask", selectedPosition: n2.state.selectedRange.startCell, innerRef: n2.setSelectionMaskRef, getSelectedDimensions: n2.getSelectedDimensions })];
            }), n2;
          }
          return (0, p.default)(t3, e3), (0, d.default)(t3, [{ key: "componentDidUpdate", value: function e4(t4, n2) {
            var o2 = this.state, r2 = o2.selectedPosition, l2 = o2.isEditorEnabled, a2 = n2.selectedPosition, u2 = n2.isEditorEnabled, d2 = r2 !== a2 && (r2.rowIdx !== a2.rowIdx || r2.idx !== a2.idx), s2 = l2 !== u2 && !l2;
            if (d2) {
              var c2 = this.props, f2 = c2.onCellSelected, p2 = c2.onCellDeSelected;
              (0, D.isFunction)(p2) && this.isCellWithinBounds(a2) && p2((0, i.default)({}, a2)), (0, D.isFunction)(f2) && this.isCellWithinBounds(r2) && f2((0, i.default)({}, r2));
            }
            (d2 && this.isCellWithinBounds(r2) || s2) && this.focus();
          } }, { key: "componentDidMount", value: function e4() {
            var t4 = this.props, n2 = t4.eventBus, o2 = t4.enableCellAutoFocus;
            this.unsubscribeSelectCell = n2.subscribe(S.EventTypes.SELECT_CELL, this.selectCell), this.unsubscribeSelectStart = n2.subscribe(S.EventTypes.SELECT_START, this.onSelectCellRangeStarted), this.unsubscribeSelectUpdate = n2.subscribe(S.EventTypes.SELECT_UPDATE, this.onSelectCellRangeUpdated), this.unsubscribeSelectEnd = n2.subscribe(S.EventTypes.SELECT_END, this.onSelectCellRangeEnded), this.unsubscribeDragEnter = n2.subscribe(S.EventTypes.DRAG_ENTER, this.handleDragEnter), o2 && this.isFocusedOnBody() && this.selectFirstCell();
          } }, { key: "componentWillUnmount", value: function e4() {
            this.unsubscribeSelectCell(), this.unsubscribeSelectStart(), this.unsubscribeSelectUpdate(), this.unsubscribeSelectEnd(), this.unsubscribeDragEnter();
          } }, { key: "isKeyboardNavigationEvent", value: function e4(t4) {
            return null != this.getKeyNavActionFromEvent(t4);
          } }, { key: "isGroupedRowSelected", value: function e4() {
            var t4 = this.props.rowGetter, n2 = this.state.selectedPosition, o2 = (0, I.getSelectedRow)({ selectedPosition: n2, rowGetter: t4 });
            return !(!o2 || !o2.__metaData) && o2.__metaData.isGroup;
          } }, { key: "getKeyNavActionFromEvent", value: function e4(t4) {
            var n2 = this.props, o2 = n2.rowVisibleEndIdx, r2 = n2.rowVisibleStartIdx, l2 = n2.colVisibleEndIdx, a2 = n2.colVisibleStartIdx, u2 = n2.onHitBottomBoundary, d2 = n2.onHitRightBoundary, s2 = n2.onHitLeftBoundary, c2 = n2.onHitTopBoundary, f2 = function e5(t5) {
              return t5.rowIdx >= o2 - 2;
            }, p2 = function e5(t5) {
              return 0 !== t5.rowIdx && t5.rowIdx <= r2 - 1;
            }, g2 = { ArrowDown: { getNext: function e5(t5) {
              return (0, i.default)({}, t5, { rowIdx: t5.rowIdx + 1 });
            }, isCellAtBoundary: f2, onHitBoundary: u2 }, ArrowUp: { getNext: function e5(t5) {
              return (0, i.default)({}, t5, { rowIdx: t5.rowIdx - 1 });
            }, isCellAtBoundary: p2, onHitBoundary: c2 }, ArrowRight: { getNext: function e5(t5) {
              return (0, i.default)({}, t5, { idx: t5.idx + 1 });
            }, isCellAtBoundary: function e5(t5) {
              return 0 !== t5.idx && t5.idx >= l2 - 1;
            }, onHitBoundary: function e5(t5) {
              d2(t5), f2(t5) && u2(t5);
            } }, ArrowLeft: { getNext: function e5(t5) {
              return (0, i.default)({}, t5, { idx: t5.idx - 1 });
            }, isCellAtBoundary: function e5(t5) {
              return 0 !== t5.idx && t5.idx <= a2 + 1;
            }, onHitBoundary: function e5(t5) {
              s2(t5), p2(t5) && c2(t5);
            } } };
            return t4.keyCode === O.Tab ? true === t4.shiftKey ? g2.ArrowLeft : g2.ArrowRight : g2[t4.key];
          } }, { key: "changeCellFromEvent", value: function e4(t4) {
            t4.preventDefault();
            var n2 = t4.keyCode === O.Tab, o2 = t4.shiftKey;
            if (n2) {
              var r2 = this.props.cellNavigationMode === S.CellNavigationMode.NONE ? S.CellNavigationMode.CHANGE_ROW : this.props.cellNavigationMode;
              this.changeCellFromKeyAction(t4, r2);
            } else
              o2 ? this.changeSelectedRangeFromArrowKeyAction(t4) : this.changeCellFromKeyAction(t4, this.props.cellNavigationMode);
          } }, { key: "changeCellFromKeyAction", value: function e4(t4, n2) {
            var o2 = this.state.selectedPosition, r2 = this.getKeyNavActionFromEvent(t4), l2 = this.getNextSelectedCellPositionForKeyNavAction(r2, o2, n2);
            this.checkIsAtGridBoundary(r2, l2), this.selectCell((0, i.default)({}, l2));
          } }, { key: "changeSelectedRangeFromArrowKeyAction", value: function e4(t4) {
            var n2 = this, o2 = this.props.cellNavigationMode, r2 = this.state.selectedRange.cursorCell || this.state.selectedPosition, l2 = this.getKeyNavActionFromEvent(t4), a2 = this.getNextSelectedCellPositionForKeyNavAction(l2, r2, o2);
            this.checkIsAtGridBoundary(l2, a2), this.onSelectCellRangeUpdated((0, i.default)({}, a2), true, function() {
              n2.onSelectCellRangeEnded();
            });
          } }, { key: "getNextSelectedCellPositionForKeyNavAction", value: function e4(t4, n2, o2) {
            var r2 = (0, t4.getNext)(n2), l2 = this.props, a2 = l2.columns, i2 = l2.rowsCount;
            return (0, I.getNextSelectedCellPosition)({ columns: a2, rowsCount: i2, cellNavigationMode: o2 }, r2);
          } }, { key: "checkIsAtGridBoundary", value: function e4(t4, n2) {
            var o2 = t4.isCellAtBoundary, r2 = t4.onHitBoundary, l2 = n2.changeRowOrColumn, i2 = (0, a.default)(n2, ["changeRowOrColumn"]);
            (o2(i2) || l2) && r2(i2);
          } }, { key: "createSingleCellSelectedRange", value: function e4(t4, n2) {
            return { topLeft: t4, bottomRight: t4, startCell: t4, cursorCell: t4, isDragging: n2 };
          } }, { key: "render", value: function e4() {
            var t4 = this.props, n2 = t4.rowGetter, o2 = t4.contextMenu, r2 = t4.getRowColumns, a2 = t4.scrollLeft, u2 = t4.scrollTop, d2 = this.state, s2 = d2.isEditorEnabled, c2 = d2.firstEditorKeyPress, f2 = d2.selectedPosition, p2 = d2.draggedPosition, g2 = d2.copiedPosition, m2 = (0, I.getSelectedRow)({ selectedPosition: f2, rowGetter: n2 }), w2 = r2(f2.rowIdx);
            return h.default.createElement("div", { onKeyDown: this.onKeyDown, onFocus: this.onFocus }, g2 && h.default.createElement(v.default, { copiedPosition: g2, innerRef: this.setCopyMaskRef, getSelectedDimensions: this.getSelectedDimensions }), p2 && h.default.createElement(b.default, { draggedPosition: p2, getSelectedDimensions: this.getSelectedDimensions }), (0, I.selectedRangeIsSingleCell)(this.state.selectedRange) ? this.renderSingleCellSelectView() : this.renderCellRangeSelectView(), s2 && h.default.createElement(x.default, { target: this.props.editorPortalTarget }, h.default.createElement(R.default, (0, l.default)({ firstEditorKeyPress: c2, onCommit: this.onCommit, onCommitCancel: this.onCommitCancel, rowIdx: f2.rowIdx, value: (0, I.getSelectedCellValue)({ selectedPosition: f2, columns: w2, rowGetter: n2 }), rowData: m2, column: (0, I.getSelectedColumn)({ selectedPosition: f2, columns: w2 }), scrollLeft: a2, scrollTop: u2, editorPortalTarget: this.props.editorPortalTarget }, (0, i.default)({}, this.getSelectedDimensions(f2), this.state.editorPosition)))), (0, h.isValidElement)(o2) && (0, h.cloneElement)(o2, (0, i.default)({}, f2)));
          } }]), t3;
        }(h.default.Component);
        (0, g.default)(T, "dispplayName", "InteractionMasks"), (0, g.default)(T, "propTypes", { colVisibleStartIdx: m.default.number.isRequired, colVisibleEndIdx: m.default.number.isRequired, rowVisibleStartIdx: m.default.number.isRequired, rowVisibleEndIdx: m.default.number.isRequired, rowOverscanStartIdx: m.default.number.isRequired, columns: m.default.array, width: m.default.number, rowHeight: m.default.number.isRequired, rowGetter: m.default.func.isRequired, rowsCount: m.default.number.isRequired, enableCellSelect: m.default.bool.isRequired, enableCellAutoFocus: m.default.bool.isRequired, cellNavigationMode: m.default.oneOf([S.CellNavigationMode.NONE, S.CellNavigationMode.LOOP_OVER_ROW, S.CellNavigationMode.CHANGE_ROW]).isRequired, eventBus: m.default.object.isRequired, contextMenu: m.default.element, onCheckCellIsEditable: m.default.func, onCellCopyPaste: m.default.func, onGridRowsUpdated: m.default.func.isRequired, onHitBottomBoundary: m.default.func.isRequired, onHitTopBoundary: m.default.func.isRequired, onHitRightBoundary: m.default.func.isRequired, onHitLeftBoundary: m.default.func.isRequired, onCommit: m.default.func.isRequired, onCommitCancel: m.default.func, onCellSelected: m.default.func, onCellDeSelected: m.default.func, onCellRangeSelectionStarted: m.default.func, onCellRangeSelectionUpdated: m.default.func, onCellRangeSelectionCompleted: m.default.func, onCellsDragged: m.default.func, onDragHandleDoubleClick: m.default.func.isRequired, scrollLeft: m.default.number.isRequired, scrollTop: m.default.number.isRequired, rows: m.default.array.isRequired, getRowHeight: m.default.func.isRequired, getRowTop: m.default.func.isRequired, getRowColumns: m.default.func.isRequired, editorPortalTarget: m.default.instanceOf(Element).isRequired });
        var A = T;
        t2.default = A;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(1)), a = o(n(10)), i = o(n(67));
        function u(e3) {
          var t3 = e3.selectedPosition, n2 = e3.innerRef, o2 = e3.getSelectedDimensions, a2 = e3.children, u2 = o2(t3, true);
          return l.default.createElement(i.default, (0, r.default)({}, u2, { className: "rdg-selected", innerRef: n2, tabIndex: "0" }), a2);
        }
        u.propTypes = { selectedPosition: a.default.object.isRequired, getSelectedDimensions: a.default.func.isRequired, innerRef: a.default.func.isRequired };
        var d = u;
        t2.default = d;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(1)), a = o(n(10)), i = n(138), u = o(n(67));
        function d(e3) {
          var t3 = e3.selectedRange, n2 = e3.columns, o2 = e3.rowHeight, a2 = e3.children, d2 = (0, i.getSelectedRangeDimensions)({ selectedRange: t3, columns: n2, rowHeight: o2 });
          return l.default.createElement(u.default, (0, r.default)({}, d2, { className: "rdg-selected-range" }), a2);
        }
        d.propTypes = { selectedRange: a.default.shape({ topLeft: a.default.shape({ idx: a.default.number.isRequired, rowIdx: a.default.number.isRequired }).isRequired, bottomRight: a.default.shape({ idx: a.default.number.isRequired, rowIdx: a.default.number.isRequired }).isRequired, startCell: a.default.shape({ idx: a.default.number.isRequired, rowIdx: a.default.number.isRequired }).isRequired, cursorCell: a.default.shape({ idx: a.default.number.isRequired, rowIdx: a.default.number.isRequired }).isRequired }).isRequired, columns: a.default.array.isRequired, rowHeight: a.default.number.isRequired };
        var s = d;
        t2.default = s;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(1)), a = o(n(10)), i = o(n(67));
        function u(e3) {
          var t3 = e3.copiedPosition, n2 = e3.innerRef, o2 = (0, e3.getSelectedDimensions)(t3);
          return l.default.createElement(i.default, (0, r.default)({}, o2, { className: "react-grid-cell-copied", innerRef: n2 }));
        }
        u.propTypes = { copiedPosition: a.default.object.isRequired, getSelectedDimensions: a.default.func.isRequired, innerRef: a.default.func.isRequired };
        var d = u;
        t2.default = d;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(16)), l = o(n(1)), a = o(n(10)), i = o(n(67));
        function u(e3) {
          var t3 = e3.draggedPosition, n2 = e3.getSelectedDimensions, o2 = t3.overRowIdx, a2 = t3.idx, u2 = t3.rowIdx;
          if (null != o2 && u2 !== o2) {
            for (var d2 = u2 < o2, s = d2 ? u2 + 1 : o2, c = d2 ? o2 : u2 - 1, f = d2 ? "react-grid-cell-dragged-over-down" : "react-grid-cell-dragged-over-up", p = n2({ idx: a2, rowIdx: s }), g = s + 1; g <= c; g++) {
              var h = n2({ idx: a2, rowIdx: g }).height;
              p.height += h;
            }
            return l.default.createElement(i.default, (0, r.default)({}, p, { className: f }));
          }
          return null;
        }
        u.propTypes = { draggedPosition: a.default.object.isRequired, getSelectedDimensions: a.default.func.isRequired };
        var d = u;
        t2.default = d;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(1)), l = o(n(10));
        function a(e3) {
          var t3 = e3.onDragStart, n2 = e3.onDragEnd, o2 = e3.onDoubleClick;
          return r.default.createElement("div", { className: "drag-handle", draggable: "true", onDragStart: t3, onDragEnd: n2, onDoubleClick: o2 });
        }
        a.propTypes = { onDragStart: l.default.func.isRequired, onDragEnd: l.default.func.isRequired, onDoubleClick: l.default.func.isRequired };
        var i = a;
        t2.default = i;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(19), r = n(3), l = r(n(16)), a = r(n(4)), i = r(n(5)), u = r(n(7)), d = r(n(8)), s = r(n(13)), c = r(n(9)), f = r(n(11)), p = r(n(1)), g = r(n(10)), h = r(n(132)), m = r(n(85)), w = n(18), C = n(140), v = o(n(139)), b = r(n(233));
        n(69);
        var y = function(e3) {
          function t3() {
            var e4, n2;
            (0, a.default)(this, t3);
            for (var o2 = arguments.length, r2 = new Array(o2), i2 = 0; i2 < o2; i2++)
              r2[i2] = arguments[i2];
            return n2 = (0, u.default)(this, (e4 = (0, d.default)(t3)).call.apply(e4, [this].concat(r2))), (0, f.default)((0, s.default)(n2), "state", { isInvalid: false }), (0, f.default)((0, s.default)(n2), "changeCommitted", false), (0, f.default)((0, s.default)(n2), "changeCanceled", false), (0, f.default)((0, s.default)(n2), "isKeyExplicitlyHandled", function(e5) {
              return (0, w.isFunction)(n2["onPress" + e5]);
            }), (0, f.default)((0, s.default)(n2), "checkAndCall", function(e5, t4) {
              (0, w.isFunction)(n2[e5]) && n2[e5](t4);
            }), (0, f.default)((0, s.default)(n2), "onKeyDown", function(e5) {
              if ((0, C.isCtrlKeyHeldDown)(e5))
                n2.checkAndCall("onPressKeyWithCtrl", e5);
              else if (n2.isKeyExplicitlyHandled(e5.key)) {
                var t4 = "onPress" + e5.key;
                n2.checkAndCall(t4, e5);
              } else
                (0, C.isKeyPrintable)(e5.keyCode) && (e5.stopPropagation(), n2.checkAndCall("onPressChar", e5));
              n2._keysDown = n2._keysDown || {}, n2._keysDown[e5.keyCode] = true, (0, w.isFunction)(n2.props.onGridKeyDown) && n2.props.onGridKeyDown(e5);
            }), (0, f.default)((0, s.default)(n2), "setEditorRef", function(e5) {
              n2.editor = e5;
            }), (0, f.default)((0, s.default)(n2), "createEditor", function() {
              var e5 = { ref: n2.setEditorRef, column: n2.props.column, value: n2.getInitialValue(), onCommit: n2.commit, onCommitCancel: n2.commitCancel, rowMetaData: n2.getRowMetaData(), rowData: n2.props.rowData, height: n2.props.height, onBlur: n2.commit, onOverrideKeyDown: n2.onKeyDown }, t4 = n2.props.column.editor;
              return p.default.isValidElement(t4) ? p.default.cloneElement(t4, e5) : (0, w.isFunction)(t4) ? p.default.createElement(t4, (0, l.default)({ ref: n2.setEditorRef }, e5)) : p.default.createElement(m.default, { ref: n2.setEditorRef, column: n2.props.column, value: n2.getInitialValue(), onBlur: n2.commit, rowMetaData: n2.getRowMetaData() });
            }), (0, f.default)((0, s.default)(n2), "onPressEnter", function() {
              n2.commit({ key: "Enter" });
            }), (0, f.default)((0, s.default)(n2), "onPressTab", function() {
              n2.commit({ key: "Tab" });
            }), (0, f.default)((0, s.default)(n2), "onPressEscape", function(e5) {
              n2.editorIsSelectOpen() ? e5.stopPropagation() : n2.commitCancel();
            }), (0, f.default)((0, s.default)(n2), "onPressArrowDown", function(e5) {
              n2.editorHasResults() ? e5.stopPropagation() : n2.commit(e5);
            }), (0, f.default)((0, s.default)(n2), "onPressArrowUp", function(e5) {
              n2.editorHasResults() ? e5.stopPropagation() : n2.commit(e5);
            }), (0, f.default)((0, s.default)(n2), "onPressArrowLeft", function(e5) {
              n2.isCaretAtBeginningOfInput() ? n2.commit(e5) : e5.stopPropagation();
            }), (0, f.default)((0, s.default)(n2), "onPressArrowRight", function(e5) {
              n2.isCaretAtEndOfInput() ? n2.commit(e5) : e5.stopPropagation();
            }), (0, f.default)((0, s.default)(n2), "editorHasResults", function() {
              return !!(0, w.isFunction)(n2.getEditor().hasResults) && n2.getEditor().hasResults();
            }), (0, f.default)((0, s.default)(n2), "editorIsSelectOpen", function() {
              return !!(0, w.isFunction)(n2.getEditor().isSelectOpen) && n2.getEditor().isSelectOpen();
            }), (0, f.default)((0, s.default)(n2), "getRowMetaData", function() {
              if ("function" === typeof n2.props.column.getRowMetaData)
                return n2.props.column.getRowMetaData(n2.props.rowData, n2.props.column);
            }), (0, f.default)((0, s.default)(n2), "getEditor", function() {
              return n2.editor;
            }), (0, f.default)((0, s.default)(n2), "getInputNode", function() {
              return n2.getEditor().getInputNode();
            }), (0, f.default)((0, s.default)(n2), "getInitialValue", function() {
              var e5 = n2.props, t4 = e5.firstEditorKeyPress, o3 = e5.value;
              return "Delete" === t4 || "Backspace" === t4 ? "" : "Enter" === t4 ? o3 : t4 || o3;
            }), (0, f.default)((0, s.default)(n2), "getContainerClass", function() {
              return (0, h.default)({ "rdg-editor-container": true, "has-error": true === n2.state.isInvalid });
            }), (0, f.default)((0, s.default)(n2), "commit", function(e5) {
              var t4 = n2.props.onCommit, o3 = e5 || {}, r3 = n2.getEditor().getValue();
              n2.isNewValueValid(r3) && (n2.changeCommitted = true, t4({ cellKey: n2.props.column.key, rowIdx: n2.props.rowIdx, updated: r3, key: o3.key }));
            }), (0, f.default)((0, s.default)(n2), "commitCancel", function() {
              n2.changeCanceled = true, n2.props.onCommitCancel();
            }), (0, f.default)((0, s.default)(n2), "isNewValueValid", function(e5) {
              if ((0, w.isFunction)(n2.getEditor().validate)) {
                var t4 = n2.getEditor().validate(e5);
                return n2.setState({ isInvalid: !t4 }), t4;
              }
              return true;
            }), (0, f.default)((0, s.default)(n2), "setCaretAtEndOfInput", function() {
              var e5 = n2.getInputNode(), t4 = e5.value.length;
              if (e5.setSelectionRange)
                e5.setSelectionRange(t4, t4);
              else if (e5.createTextRange) {
                var o3 = e5.createTextRange();
                o3.moveStart("character", t4), o3.collapse(), o3.select();
              }
            }), (0, f.default)((0, s.default)(n2), "isCaretAtBeginningOfInput", function() {
              var e5 = n2.getInputNode();
              return e5.selectionStart === e5.selectionEnd && 0 === e5.selectionStart;
            }), (0, f.default)((0, s.default)(n2), "isCaretAtEndOfInput", function() {
              var e5 = n2.getInputNode();
              return e5.selectionStart === e5.value.length;
            }), (0, f.default)((0, s.default)(n2), "handleRightClick", function(e5) {
              e5.stopPropagation();
            }), (0, f.default)((0, s.default)(n2), "setTextInputFocus", function() {
              var e5 = n2.props.firstEditorKeyPress, t4 = n2.getInputNode();
              t4.focus(), "INPUT" === t4.tagName && ((0, C.isKeyPrintable)(e5) ? t4.select() : (t4.focus(), t4.select()));
            }), (0, f.default)((0, s.default)(n2), "renderStatusIcon", function() {
              if (true === n2.state.isInvalid)
                return p.default.createElement("span", { className: "glyphicon glyphicon-remove form-control-feedback" });
            }), n2;
          }
          return (0, c.default)(t3, e3), (0, i.default)(t3, [{ key: "componentDidMount", value: function e4() {
            var t4 = this.getInputNode();
            void 0 !== t4 && (this.setTextInputFocus(), this.getEditor().disableContainerStyles || (t4.className += " editor-main", t4.style.height = this.props.height - 1 + "px"));
          } }, { key: "componentDidUpdate", value: function e4(t4) {
            t4.scrollLeft === this.props.scrollLeft && t4.scrollTop === this.props.scrollTop || this.commitCancel();
          } }, { key: "componentWillUnmount", value: function e4() {
            this.changeCommitted || this.changeCanceled || this.commit({ key: "Enter" });
          } }, { key: "render", value: function e4() {
            var t4 = this.props, n2 = t4.width, o2 = { position: "absolute", height: t4.height, width: n2, left: t4.left, top: t4.top, zIndex: v.EDITOR_CONTAINER };
            return p.default.createElement(b.default, { onClickOutside: this.commit }, p.default.createElement("div", { style: o2, className: this.getContainerClass(), onKeyDown: this.onKeyDown, onContextMenu: this.handleRightClick }, this.createEditor(), this.renderStatusIcon()));
          } }]), t3;
        }(p.default.Component);
        (0, f.default)(y, "displayName", "EditorContainer"), (0, f.default)(y, "propTypes", { rowIdx: g.default.number, rowData: g.default.object.isRequired, value: g.default.oneOfType([g.default.string, g.default.number, g.default.object, g.default.bool]).isRequired, column: g.default.object.isRequired, width: g.default.number.isRequired, height: g.default.number.isRequired, left: g.default.number.isRequired, top: g.default.number.isRequired, onGridKeyDown: g.default.func, onCommit: g.default.func, onCommitCancel: g.default.func, firstEditorKeyPress: g.default.string, scrollLeft: g.default.number, scrollTop: g.default.number }), e2.exports = y;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(1)), f = o(n(10)), p = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "isClickedInside", false), (0, s.default)((0, u.default)(n2), "handleDocumentClick", function(e5) {
              n2.isClickedInside ? n2.isClickedInside = false : n2.props.onClickOutside(e5);
            }), (0, s.default)((0, u.default)(n2), "handleClick", function() {
              n2.isClickedInside = true;
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "componentDidMount", value: function e4() {
            document.addEventListener("click", this.handleDocumentClick);
          } }, { key: "componentWillUnmount", value: function e4() {
            document.removeEventListener("click", this.handleDocumentClick);
          } }, { key: "render", value: function e4() {
            return c.default.cloneElement(c.default.Children.only(this.props.children), { onClickCapture: this.handleClick });
          } }]), t3;
        }(c.default.Component);
        t2.default = p, (0, s.default)(p, "propTypes", { children: f.default.element.isRequired, onClickOutside: f.default.func.isRequired });
      }, function(e2, t2, n) {
        (e2.exports = n(26)(false)).push([e2.i, ".react-grid-Container {\n  clear: both;\n  margin-top: 0;\n  padding: 0;\n}\n\n.react-grid-Main {\n  background-color: #ffffff;\n  color: inherit;\n  padding: 0px;\n  outline: 1px solid #e7eaec;\n  clear : both;\n}\n\n.react-grid-Grid {\n  background-color: #ffffff;\n  border: 1px solid #dddddd;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.react-grid-Canvas {\n  background-color: #ffffff;\n}\n", ""]);
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(1)), f = o(n(20)), p = o(n(10)), g = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "state", { isMounted: false }), (0, s.default)((0, u.default)(n2), "el", document.createElement("div")), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "componentDidMount", value: function e4() {
            this.props.target.appendChild(this.el), this.setState({ isMounted: true });
          } }, { key: "componentWillUnmount", value: function e4() {
            this.props.target.removeChild(this.el);
          } }, { key: "render", value: function e4() {
            return this.state.isMounted ? f.default.createPortal(this.props.children, this.el) : null;
          } }]), t3;
        }(c.default.Component);
        t2.default = g, (0, s.default)(g, "propTypes", { children: p.default.node.isRequired, target: p.default.instanceOf(Element).isRequired });
      }, function(e2, t2, n) {
        var o = n(237);
        "string" === typeof o && (o = [[e2.i, o, ""]]);
        var r = { hmr: true, transform: void 0, insertInto: void 0 };
        n(27)(o, r);
        o.locals && (e2.exports = o.locals);
      }, function(e2, t2, n) {
        (e2.exports = n(26)(false)).push([e2.i, ".rdg-selected {\n  border: 2px solid #66afe9;\n}\n\n.rdg-selected .drag-handle {\n  pointer-events: auto;\n  position: absolute;\n  bottom: -5px;\n  right: -4px;\n  background: #66afe9;\n  width: 8px;\n  height: 8px;\n  border: 1px solid #fff;\n  border-right: 0px;\n  border-bottom: 0px;\n  cursor: crosshair;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n  cursor: grab;\n}\n\n.rdg-selected:hover .drag-handle {\n  bottom: -8px;\n  right: -7px;\n  background: white;\n  width: 16px;\n  height: 16px;\n  border: 1px solid #66afe9;\n}\n\n.rdg-selected:hover .drag-handle .glyphicon-arrow-down {\n  display: 'block'\n}\n\n.react-grid-cell-dragged-over-up, .react-grid-cell-dragged-over-down {\n  border: 1px dashed black;\n  background: rgba(0, 0, 255, 0.2) !important;\n}\n\n.react-grid-cell-dragged-over-up {\n  border-bottom-width: 0;\n}\n\n.react-grid-cell-dragged-over-down {\n  border-top-width: 0;\n}\n\n.react-grid-cell-copied {\n  background: rgba(0, 0, 255, 0.2) !important;\n}\n\n.rdg-editor-container input.editor-main, select.editor-main {\n  display: block;\n  width: 100%;\n  height: 34px;\n  padding: 6px 12px;\n  font-size: 14px;\n  line-height: 1.42857143;\n  color: #555555;\n  background-color: #ffffff;\n  background-image: none;\n  border: 1px solid #cccccc;\n  border-radius: 4px;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);\n  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);\n}\n\ninput.editor-main:focus, select.editor-main:focus {\n  border-color: #66afe9;\n  border: 2px solid #66afe9;\n  background: #eee;\n  border-radius: 4px;\n}\n\n.rdg-editor-container input.editor-main::-moz-placeholder, select.editor-main::-moz-placeholder {\n  color: #999999;\n  opacity: 1;\n}\n\n.rdg-editor-container input.editor-main:-ms-input-placeholder, select.editor-main:-ms-input-placeholder {\n  color: #999999;\n}\n\n.rdg-editor-container input.editor-main::-webkit-input-placeholder, select.editor-main::-webkit-input-placeholder {\n  color: #999999;\n}\n\n.rdg-editor-container input.editor-main[disabled], select.editor-main[disabled], .rdg-editor-container input.editor-main[readonly], select.editor-main[readonly], fieldset[disabled] .rdg-editor-container input.editor-main, fieldset[disabled] select.editor-main {\n  cursor: not-allowed;\n  background-color: #eeeeee;\n  opacity: 1;\n}\n\ntextarea.rdg-editor-container input.editor-main, textareaselect.editor-main {\n  height: auto;\n}\n", ""]);
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getColumnScrollPosition = function o(e3, t3, n2, l) {
          for (var a = 0, i = 0, u = 0; u < t3; u++) {
            var d = (0, r.getColumn)(e3, u);
            d && (d.width && (a += d.width), (0, r.isFrozen)(d) && (i += d.width));
          }
          var s = (0, r.getColumn)(e3, t3);
          if (s) {
            var c = a - i - n2, f = a + s.width - n2;
            if (c < 0)
              return c;
            if (f > l) {
              var p = f - l;
              return p;
            }
          }
        };
        var r = n(25);
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getColOverscanEndIdx = t2.getColOverscanStartIdx = t2.getRowOverscanEndIdx = t2.getRowOverscanStartIdx = t2.getScrollDirection = t2.getVisibleBoundaries = t2.getNonFrozenRenderedColumnCount = t2.getNonFrozenVisibleColStartIdx = t2.findLastFrozenColumnIndex = t2.getGridState = t2.SCROLL_DIRECTION = t2.OVERSCAN_ROWS = void 0;
        var o = n(25);
        t2.OVERSCAN_ROWS = 2;
        var r = { UP: "upwards", DOWN: "downwards", LEFT: "left", RIGHT: "right", NONE: "none" };
        t2.SCROLL_DIRECTION = r;
        var l = Math.min, a = Math.max, i = Math.ceil;
        t2.getGridState = function e3(t3) {
          var n2 = (0, o.getSize)(t3.columnMetrics.columns), r2 = t3.minHeight - t3.rowOffsetHeight, a2 = i((t3.minHeight - t3.rowHeight) / t3.rowHeight);
          return { rowOverscanStartIdx: 0, rowOverscanEndIdx: l(t3.rowsCount, 2 * a2), rowVisibleStartIdx: 0, rowVisibleEndIdx: a2, height: r2, scrollTop: 0, scrollLeft: 0, colVisibleStartIdx: 0, colVisibleEndIdx: n2, colOverscanStartIdx: 0, colOverscanEndIdx: n2, isScrolling: false, lastFrozenColumnIndex: 0 };
        };
        var u = function e3(t3) {
          var n2 = -1;
          return t3.forEach(function(e4, t4) {
            (0, o.isFrozen)(e4) && (n2 = t4);
          }), n2;
        };
        t2.findLastFrozenColumnIndex = u;
        var d = function e3(t3, n2) {
          for (var r2 = n2, l2 = u(t3), a2 = t3.slice(l2 + 1), i2 = l2; r2 >= 0 && i2 < (0, o.getSize)(a2); ) {
            i2++;
            var d2 = (0, o.getColumn)(t3, i2);
            r2 -= d2 ? d2.width : 0;
          }
          return Math.max(i2, 0);
        };
        t2.getNonFrozenVisibleColStartIdx = d;
        t2.getNonFrozenRenderedColumnCount = function e3(t3, n2, r2) {
          var l2 = t3.columns;
          if (0 === (0, o.getSize)(l2))
            return 0;
          var a2 = d(t3.columns, r2), i2 = function e4(t4) {
            var n3 = u(t4);
            if (n3 > -1) {
              var r3 = (0, o.getColumn)(t4, n3);
              return r3.left + r3.width;
            }
            return 0;
          }(t3.columns), s = n2 > 0 ? n2 : t3.totalColumnWidth, c = (0, o.getColumn)(t3.columns, a2), f = i2 + r2, p = s - i2 + (f > c.left ? f - c.left : 0);
          return function e4(t4, n3, o2) {
            var r3 = { width: n3, count: 0 };
            return t4.slice(o2).reduce(function(e5, t5) {
              var n4 = e5.width, o3 = e5.count, r4 = n4 - t5.width;
              return { width: r4, count: r4 >= 0 ? o3 + 1 : o3 };
            }, r3);
          }(t3.columns, p, a2).count;
        };
        t2.getVisibleBoundaries = function e3(t3, n2, o2, r2) {
          var u2 = i(t3 / n2), d2 = a(0, Math.round(o2 / n2));
          return { rowVisibleStartIdx: d2, rowVisibleEndIdx: l(d2 + u2, r2) };
        };
        t2.getScrollDirection = function e3(t3, n2, o2) {
          return n2 !== t3.scrollTop && void 0 !== t3.scrollTop ? n2 - t3.scrollTop >= 0 ? r.DOWN : r.UP : o2 !== t3.scrollLeft && void 0 !== t3.scrollLeft ? o2 - t3.scrollLeft >= 0 ? r.RIGHT : r.LEFT : r.NONE;
        };
        t2.getRowOverscanStartIdx = function e3(t3, n2) {
          return a(0, t3 === r.UP ? n2 - 2 : n2);
        };
        t2.getRowOverscanEndIdx = function e3(t3, n2, o2) {
          return t3 === r.DOWN ? l(n2 + 2, o2) : n2;
        };
        t2.getColOverscanStartIdx = function e3(t3, n2, o2) {
          return t3 === r.LEFT || t3 === r.RIGHT ? o2 > -1 ? o2 + 1 : 0 : n2;
        };
        t2.getColOverscanEndIdx = function e3(t3, n2, o2) {
          return t3 === r.DOWN || t3 === r.UP ? n2 : o2;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = Object.getOwnPropertySymbols, r = Object.prototype.hasOwnProperty, l = Object.prototype.propertyIsEnumerable;
        e2.exports = function a() {
          try {
            if (!Object.assign)
              return false;
            var e3 = new String("abc");
            if (e3[5] = "de", "5" === Object.getOwnPropertyNames(e3)[0])
              return false;
            for (var t3 = {}, n2 = 0; n2 < 10; n2++)
              t3["_" + String.fromCharCode(n2)] = n2;
            if ("0123456789" !== Object.getOwnPropertyNames(t3).map(function(e4) {
              return t3[e4];
            }).join(""))
              return false;
            var o2 = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(e4) {
              o2[e4] = e4;
            }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, o2)).join("");
          } catch (r2) {
            return false;
          }
        }() ? Object.assign : function(e3, t3) {
          for (var n2, a, i = function u(e4) {
            if (null === e4 || void 0 === e4)
              throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(e4);
          }(e3), d = 1; d < arguments.length; d++) {
            for (var s in n2 = Object(arguments[d]))
              r.call(n2, s) && (i[s] = n2[s]);
            if (o) {
              a = o(n2);
              for (var c = 0; c < a.length; c++)
                l.call(n2, a[c]) && (i[a[c]] = n2[a[c]]);
            }
          }
          return i;
        };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r = o(n(4)), l = o(n(5)), a = o(n(7)), i = o(n(8)), u = o(n(13)), d = o(n(9)), s = o(n(11)), c = o(n(1)), f = o(n(10)), p = n(25), g = function(e3) {
          function t3() {
            var e4, n2;
            (0, r.default)(this, t3);
            for (var o2 = arguments.length, l2 = new Array(o2), d2 = 0; d2 < o2; d2++)
              l2[d2] = arguments[d2];
            return n2 = (0, a.default)(this, (e4 = (0, i.default)(t3)).call.apply(e4, [this].concat(l2))), (0, s.default)((0, u.default)(n2), "onAddSubRow", function() {
              n2.props.onAddSubRow(n2.props.parentRowId);
            }), n2;
          }
          return (0, d.default)(t3, e3), (0, l.default)(t3, [{ key: "getFrozenColumnsWidth", value: function e4() {
            for (var t4 = 0, n2 = (0, p.getSize)(this.props.columns), o2 = 0; o2 < n2; o2++) {
              var r2 = (0, p.getColumn)(this.props.columns, o2);
              r2 && (0, p.getValue)(r2, "frozen") && (t4 += (0, p.getValue)(r2, "width"));
            }
            return t4;
          } }, { key: "render", value: function e4() {
            var t4 = this, n2 = this.props, o2 = n2.cellHeight, r2 = 15 * n2.treeDepth, l2 = (o2 - 12) / 2, a2 = { height: o2, borderBottom: "1px solid #dddddd" }, i2 = (0, p.getColumn)(this.props.columns.filter(function(e5) {
              return e5.key === t4.props.expandColumnKey;
            }), 0), u2 = i2 ? i2.left : 0;
            return c.default.createElement("div", { className: "react-grid-Row rdg-add-child-row-container", style: a2 }, c.default.createElement("div", { className: "react-grid-Cell", style: { position: "absolute", height: o2, width: "100%", left: u2 } }, c.default.createElement("div", { className: "rdg-empty-child-row", style: { marginLeft: "30px", lineHeight: "".concat(o2, "px") } }, c.default.createElement("div", { className: "'rdg-child-row-action-cross rdg-child-row-action-cross-last" }), c.default.createElement("div", { style: { left: r2, top: l2, width: 12, height: 12 }, className: "rdg-child-row-btn", onClick: this.onAddSubRow }, c.default.createElement("div", { className: "glyphicon glyphicon-plus-sign" })))));
          } }]), t3;
        }(c.default.Component);
        g.propTypes = { treeDepth: f.default.number.isRequired, cellHeight: f.default.number.isRequired, onAddSubRow: f.default.func.isRequired, parentRowId: f.default.number, columns: f.default.array.isRequired, expandColumnKey: f.default.string.isRequired };
        var h = g;
        t2.default = h;
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3), r = o(n(135)), l = o(n(142));
        e2.exports = { SimpleCellFormatter: r.default, SelectAll: l.default };
      }, function(e2, t2, n) {
        "use strict";
        var o = n(3)(n(244));
        e2.exports = { test: { GridPropHelpers: o.default } };
      }, function(e2, t2, n) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.fakeCellMetaData = t2.default = void 0;
        for (var o = [], r = 0; r < 1e3; r++)
          o.push({ id: r, title: "Title " + r, count: 1e3 * r });
        var l = { columns: [{ key: "id", name: "ID", width: 100 }, { key: "title", name: "Title", width: 100 }, { key: "count", name: "Count", width: 100 }], rowGetter: function e3(t3) {
          return o[t3];
        }, rowsCount: function e3() {
          return o.length;
        }, cellMetaData: { selected: { idx: 2, rowIdx: 3 }, dragged: null, copied: null } };
        t2.default = l;
        t2.fakeCellMetaData = { rowKey: "id", onCellClick: function e3() {
          return null;
        }, onCellMouseDown: function e3() {
          return null;
        }, onColumnEvent: function e3() {
          return null;
        }, onCellExpand: function e3() {
          return null;
        }, onCellMouseEnter: function e3() {
          return null;
        }, onCellContextMenu: function e3() {
          return null;
        }, onRowExpandToggle: function e3() {
          return null;
        }, onCellDoubleClick: function e3() {
          return null;
        }, onDragEnter: function e3() {
          return null;
        } };
      }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(e2, t2, n) {
        e2.exports = n(204);
      }]);
    });
  }
});

// node_modules/react-data-grid/index.js
var require_react_data_grid2 = __commonJS({
  "node_modules/react-data-grid/index.js"(exports, module) {
    module.exports = require_react_data_grid();
  }
});

// app/routes/index.jsx
var import_react9 = __toESM(require_react());
var import_react_month_picker = __toESM(require_month_picker());
var import_db = __toESM(require_db());
var import_session = __toESM(require_session());
var import_react11 = __toESM(require_react());

// app/components/StationModel.jsx
var import_react2 = __toESM(require_react());
var import_react_modal = __toESM(require_lib());
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function StationModel(prop) {
  var _a;
  const { stationDetail, setIsOpenv } = prop;
  const [modalIsOpen, setIsOpen] = import_react2.default.useState(setIsOpenv ? true : false);
  const [stationName, setStationName] = import_react2.default.useState(
    (_a = stationDetail == null ? void 0 : stationDetail.stationName) == null ? void 0 : _a.statonName
  );
  const [stationDatas, setStationDatas] = import_react2.default.useState([]);
  const directus = directusLoaderLink;
  const navigate = useNavigate();
  const customStyles = {
    content: {
      top: "50%",
      left: "50%",
      right: "auto",
      bottom: "auto",
      marginRight: "-50%",
      transform: "translate(-50%, -50%)",
      minWidth: "300px"
    }
  };
  const closeModal = () => {
    setIsOpenv(false);
    setIsOpen(false);
  };
  import_react2.default.useEffect(() => {
    const stationDatas2 = async () => {
      var _a2, _b;
      await directus.items("Stations").readByQuery({
        fields: ["station_name_translation"],
        filter: {
          station_unique_id: {
            _eq: (_a2 = stationDetail == null ? void 0 : stationDetail.stationName) == null ? void 0 : _a2.StationUniqueId
          },
          id: { _eq: (_b = stationDetail == null ? void 0 : stationDetail.stationName) == null ? void 0 : _b.StationId }
        }
      }).then(
        (res) => {
          var _a3, _b2, _c;
          return ((_b2 = (_a3 = res == null ? void 0 : res.data[0]) == null ? void 0 : _a3.station_name_translation) == null ? void 0 : _b2.length) > 0 && setStationDatas((_c = res == null ? void 0 : res.data[0]) == null ? void 0 : _c.station_name_translation);
        }
      ).catch((err) => console.log(err));
    };
    stationDatas2();
  }, []);
  const stationNameUpdateHandle = async () => {
    var _a2, _b;
    const body = stationDatas == null ? void 0 : stationDatas.filter(
      (e) => (e == null ? void 0 : e.location_id) !== (stationDetail == null ? void 0 : stationDetail.locationId)
    );
    body.push({ location_id: stationDetail == null ? void 0 : stationDetail.locationId, name: stationName });
    if (((_a2 = stationName == null ? void 0 : stationName.trim()) == null ? void 0 : _a2.length) > 3) {
      await directus.items("Stations").updateOne((_b = stationDetail == null ? void 0 : stationDetail.stationName) == null ? void 0 : _b.StationId, {
        station_name_translation: body
      }).then((res) => {
        Q.success("Updated successfully");
        location == null ? void 0 : location.reload();
        closeModal();
      }).catch((err) => {
        Q.error("Something went wrong");
        location == null ? void 0 : location.reload();
        closeModal();
      });
    } else {
      Q.error("Minimum 3 letters required");
    }
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
    className: "w-100 h-100",
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react_modal.default, {
      isOpen: modalIsOpen,
      onRequestClose: closeModal,
      style: customStyles,
      contentLabel: "Station Preview Modal",
      ariaHideApp: false,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
        className: "rounded-[10px] shadow-lgpx-6 p-4 w-full",
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: "close-div",
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
              onClick: closeModal,
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("img", {
                src: closeIcon_default,
                alt: "close-icon"
              }, void 0, false, {
                fileName: "app/components/StationModel.jsx",
                lineNumber: 97,
                columnNumber: 15
              }, this)
            }, void 0, false, {
              fileName: "app/components/StationModel.jsx",
              lineNumber: 96,
              columnNumber: 13
            }, this)
          }, void 0, false, {
            fileName: "app/components/StationModel.jsx",
            lineNumber: 95,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h1", {
            className: "text-[18px] font-bold text-black mb-5",
            children: "Edit Station title"
          }, void 0, false, {
            fileName: "app/components/StationModel.jsx",
            lineNumber: 100,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("input", {
            value: stationName,
            onChange: (e) => {
              var _a2;
              return setStationName((_a2 = e == null ? void 0 : e.target) == null ? void 0 : _a2.value);
            },
            type: "text",
            id: "u-mail-id1",
            name: "otp",
            placeholder: "enter station name",
            required: true,
            className: "mt-2 mb-5 w-full px-2 py-3 flex justify-center items-center text-black shadow-sm rounded-lg border border-gray-300 focus:border-gray-600 placeholder:font-bold placeholder:text-[#bbb] placeholder:text-[14px] focus:outline-none focus:ring-1 focus:ring-gray-600 sm:text-sm"
          }, void 0, false, {
            fileName: "app/components/StationModel.jsx",
            lineNumber: 103,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
            type: "button",
            name: "updateButton",
            onClick: () => stationNameUpdateHandle(),
            className: "inline-flex w-full items-center justify-center h-[50px] text-[18px] rounded border bg-primary border-primary px-4 py-2 text-sm font-bold text-white shadow-sm hover:bg-primary focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2",
            children: "Update"
          }, void 0, false, {
            fileName: "app/components/StationModel.jsx",
            lineNumber: 113,
            columnNumber: 11
          }, this)
        ]
      }, void 0, true, {
        fileName: "app/components/StationModel.jsx",
        lineNumber: 94,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: "app/components/StationModel.jsx",
      lineNumber: 87,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: "app/components/StationModel.jsx",
    lineNumber: 86,
    columnNumber: 5
  }, this);
}

// app/components/foodWasteModals/tableDataModal.jsx
var import_react3 = __toESM(require_react());
var import_react_modal2 = __toESM(require_lib());
var import_lodash = __toESM(require_lodash());
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
if (typeof window === "undefined") {
} else {
  let TableDataModal = function(prop) {
    const { Details, setIsOpenv } = prop;
    const { data, foodWaste } = Details;
    const [modalIsOpen, setIsOpen] = import_react3.default.useState(setIsOpenv ? true : false);
    const [preventDouble, setPreventDouble] = import_react3.default.useState(false);
    const columns = [
      {
        key: "day",
        name: "Week Day",
        editable: false
      },
      {
        key: "no_users",
        name: "Number of users on that day",
        editable: true
      },
      {
        key: "palte_waste",
        name: "Plate Waste",
        editable: true
      },
      {
        key: "total_waste",
        name: "Total Waste",
        editable: true
      }
    ];
    const initialRows = [
      {
        day: "Monday",
        dayNo: 1,
        no_users: "",
        palte_waste: "",
        total_waste: "",
        editable: true,
        ID: ""
      },
      {
        day: "Tuesday",
        dayNo: 2,
        no_users: "",
        palte_waste: "",
        total_waste: "",
        editable: true,
        ID: ""
      },
      {
        day: "Wednesday",
        dayNo: 3,
        no_users: "",
        palte_waste: "",
        total_waste: "",
        editable: true,
        ID: ""
      },
      {
        day: "Thursday",
        dayNo: 4,
        no_users: "",
        palte_waste: "",
        total_waste: "",
        editable: true,
        ID: ""
      },
      {
        day: "Friday",
        dayNo: 5,
        no_users: "",
        palte_waste: "",
        total_waste: "",
        editable: true,
        ID: ""
      }
    ];
    (foodWaste == null ? void 0 : foodWaste.length) > 0 && foodWaste.map((e) => {
      const ind = initialRows.findIndex(
        (obj) => obj.dayNo === getDay(new Date(e == null ? void 0 : e.date))
      );
      initialRows[ind].no_users = e == null ? void 0 : e.number_of_users;
      initialRows[ind].palte_waste = e == null ? void 0 : e.food_waste;
      initialRows[ind].total_waste = e == null ? void 0 : e.total_waste;
      initialRows[ind].ID = `${e == null ? void 0 : e.id}`;
      return { day: getDay(new Date(e == null ? void 0 : e.date)), date: e == null ? void 0 : e.date, ind };
    });
    const [state, setState] = import_react3.default.useState({
      rows: initialRows,
      topLeft: {},
      botRight: {}
    });
    const directus = directusLoaderLink.items("Food_waste_information");
    const closeModal = () => {
      setIsOpenv(false);
      setIsOpen(false);
    };
    const customStyles = {
      content: {
        top: "50%",
        left: "50%",
        right: "auto",
        bottom: "auto",
        marginRight: "-50%",
        transform: "translate(-50%, -50%)",
        minWidth: "300px"
      }
    };
    const submitHandle = async () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
      setPreventDouble(true);
      var errorFlag2 = false;
      for (var [i, e] of rows == null ? void 0 : rows.entries()) {
        if (((_b = (_a = e == null ? void 0 : e.ID) == null ? void 0 : _a.trim()) == null ? void 0 : _b.length) === 0) {
          (((_d = (_c = e == null ? void 0 : e.no_users) == null ? void 0 : _c.trim()) == null ? void 0 : _d.length) > 0 || ((_f = (_e = e == null ? void 0 : e.palte_waste) == null ? void 0 : _e.trim()) == null ? void 0 : _f.length) > 0 || ((_h = (_g = e == null ? void 0 : e.total_waste) == null ? void 0 : _g.trim()) == null ? void 0 : _h.length) > 0) && await (directus == null ? void 0 : directus.createOne({
            date: addDays(new Date(data == null ? void 0 : data.startDate), i + 1),
            location_id: data == null ? void 0 : data.LocationId,
            number_of_users: ((_j = (_i = e == null ? void 0 : e.no_users) == null ? void 0 : _i.trim()) == null ? void 0 : _j.length) > 0 ? e == null ? void 0 : e.no_users : 0,
            food_waste: ((_l = (_k = e == null ? void 0 : e.palte_waste) == null ? void 0 : _k.trim()) == null ? void 0 : _l.length) > 0 ? e == null ? void 0 : e.palte_waste : 0,
            total_waste: ((_n = (_m = e == null ? void 0 : e.total_waste) == null ? void 0 : _m.trim()) == null ? void 0 : _n.length) > 0 ? e == null ? void 0 : e.total_waste : 0
          }).then(async (re) => {
          }).catch((e2) => {
            errorFlag2 = true;
            console.log(e2, "error");
          }));
        } else {
          (e == null ? void 0 : e.ID) && await (directus == null ? void 0 : directus.updateOne(Number(e == null ? void 0 : e.ID), {
            number_of_users: typeof (e == null ? void 0 : e.no_users) === "string" ? ((_o = e == null ? void 0 : e.no_users) == null ? void 0 : _o.trim().length) > 0 ? e == null ? void 0 : e.no_users : 0 : (e == null ? void 0 : e.no_users) > 0 ? e == null ? void 0 : e.no_users : 0,
            food_waste: typeof (e == null ? void 0 : e.palte_waste) === "string" ? ((_p = e == null ? void 0 : e.palte_waste) == null ? void 0 : _p.trim().length) > 0 ? e == null ? void 0 : e.palte_waste : 0 : (e == null ? void 0 : e.palte_waste) > 0 ? e == null ? void 0 : e.palte_waste : 0,
            total_waste: typeof (e == null ? void 0 : e.total_waste) === "string" ? ((_q = e == null ? void 0 : e.total_waste) == null ? void 0 : _q.trim().length) > 0 ? e == null ? void 0 : e.total_waste : 0 : (e == null ? void 0 : e.total_waste) > 0 ? e == null ? void 0 : e.total_waste : 0
          }).then(async (re) => {
          }).catch((e2) => {
            console.log(e2);
            errorFlag2 = true;
          }));
        }
      }
      if (errorFlag2 === true) {
        Q.error("Something went wrong");
      } else {
        closeModal();
        localStorage.setItem("foodWasteReload", true);
        Q.success("Updated successfully");
      }
      setPreventDouble(false);
    };
    import_react3.default.useEffect(() => {
      document.addEventListener("copy", handleCopy);
      document.addEventListener("paste", handlePaste);
      return () => {
        document.removeEventListener("copy", handleCopy);
        document.removeEventListener("paste", handlePaste);
      };
    }, [state]);
    const rowGetter = (i) => {
      const { rows: rows2 } = state;
      return rows2[i];
    };
    const updateRows = (startIdx, newRows) => {
      setState((state2) => {
        const rows2 = state2.rows.slice();
        for (let i = 0; i < (newRows == null ? void 0 : newRows.length); i++) {
          if (startIdx + i < (rows2 == null ? void 0 : rows2.length)) {
            rows2[startIdx + i] = { ...rows2[startIdx + i], ...newRows[i] };
          }
        }
        return { rows: rows2 };
      });
    };
    const handleCopy = (e) => {
      e.preventDefault();
      const { topLeft, botRight } = state;
      const text = (0, import_lodash.range)(topLeft.rowIdx, botRight.rowIdx + 1).map(
        (rowIdx) => columns.slice(topLeft.colIdx, botRight.colIdx + 1).map(
          (col) => rowGetter(rowIdx)[col.key]
        ).join("	")
      ).join("\n");
      e.clipboardData.setData("text/plain", text);
    };
    const handlePaste = (e) => {
      e.preventDefault();
      const { topLeft } = state;
      const newRows = [];
      const pasteData = defaultParsePaste(
        e.clipboardData.getData("text/plain")
      );
      const pasteDataIsNum = [];
      pasteData.forEach((row) => {
        const rowData = {};
        const start = topLeft.colIdx == 0 ? 1 : topLeft.colIdx;
        columns.slice(start, start + (row == null ? void 0 : row.length)).forEach((col, j) => {
          if (col.key !== "day") {
            rowData[col.key] = row[j];
            pasteDataIsNum.push(isNaN(row[j]) === false);
          }
        });
        newRows.push(rowData);
      });
      if ((pasteDataIsNum == null ? void 0 : pasteDataIsNum.includes(false)) !== true) {
        updateRows(topLeft.rowIdx, newRows);
      } else {
        setPreventDouble(true);
        Q.error("Paste valid digit values");
        setTimeout(() => {
          setPreventDouble(false);
        }, 1e3);
      }
    };
    const onGridRowsUpdated = ({ fromRow, toRow, updated, action }) => {
      var _a, _b;
      if (((_a = Object.keys(updated)) == null ? void 0 : _a[0]) !== "day" && action !== "COPY_PASTE") {
        if (isNaN((_b = Object.values(updated)) == null ? void 0 : _b[0]) === false) {
          setState((state2) => {
            const rows2 = state2.rows.slice();
            for (let i = fromRow; i <= toRow; i++) {
              rows2[i] = { ...rows2[i], ...updated };
            }
            return { rows: rows2 };
          });
        } else {
          setPreventDouble(true);
          Q.error("Enter valid digit");
          setTimeout(() => {
            setPreventDouble(false);
          }, 1e3);
        }
      }
    };
    const setSelection = (args) => {
      setState({
        ...state,
        topLeft: {
          rowIdx: args.topLeft.rowIdx,
          colIdx: args.topLeft.idx
        },
        botRight: {
          rowIdx: args.bottomRight.rowIdx,
          colIdx: args.bottomRight.idx
        }
      });
    };
    const { rows } = state;
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
      className: "w-100 h-100",
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react_modal2.default, {
        isOpen: modalIsOpen,
        onRequestClose: closeModal,
        style: customStyles,
        contentLabel: "Food Waste Modal",
        ariaHideApp: false,
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "food-waste-grid rounded-[10px] shadow-lgpx-6 py-4 w-full min-w-[900px] max-w-[900px]",
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "close-div",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
                onClick: closeModal,
                children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("img", {
                  src: closeIcon_default,
                  alt: "close-icon"
                }, void 0, false, {
                  fileName: "app/components/foodWasteModals/tableDataModal.jsx",
                  lineNumber: 322,
                  columnNumber: 17
                }, this)
              }, void 0, false, {
                fileName: "app/components/foodWasteModals/tableDataModal.jsx",
                lineNumber: 321,
                columnNumber: 15
              }, this)
            }, void 0, false, {
              fileName: "app/components/foodWasteModals/tableDataModal.jsx",
              lineNumber: 320,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h1", {
              className: "text-[18px] font-bold text-black mb-2 text-center",
              children: [
                "Week ",
                data == null ? void 0 : data.currentWeek
              ]
            }, void 0, true, {
              fileName: "app/components/foodWasteModals/tableDataModal.jsx",
              lineNumber: 325,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
              className: "mb-3 text-center block text-black",
              children: data == null ? void 0 : data.weekStartAndEnd
            }, void 0, false, {
              fileName: "app/components/foodWasteModals/tableDataModal.jsx",
              lineNumber: 328,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(ReactDataGrid, {
              columns,
              rowGetter: (i) => rows[i],
              rowsCount: rows == null ? void 0 : rows.length,
              onGridRowsUpdated,
              enableCellSelect: true,
              minColumnWidth: 40,
              cellRangeSelection: {
                onComplete: setSelection
              },
              enableRowSelect: null
            }, void 0, false, {
              fileName: "app/components/foodWasteModals/tableDataModal.jsx",
              lineNumber: 331,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
              type: "button",
              onClick: () => preventDouble === false && submitHandle(),
              className: "min-w-[112px] px-2 py-1.5 flex justify-center items-center uppercase bg-primary text-white font-semibold text-sm rounded save-btn mt-5 mr-[7px] float-right",
              children: "Submit"
            }, void 0, false, {
              fileName: "app/components/foodWasteModals/tableDataModal.jsx",
              lineNumber: 344,
              columnNumber: 13
            }, this)
          ]
        }, void 0, true, {
          fileName: "app/components/foodWasteModals/tableDataModal.jsx",
          lineNumber: 319,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: "app/components/foodWasteModals/tableDataModal.jsx",
        lineNumber: 312,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: "app/components/foodWasteModals/tableDataModal.jsx",
      lineNumber: 311,
      columnNumber: 7
    }, this);
  };
  TableDataModal2 = TableDataModal;
  ReactDataGrid = require_react_data_grid2();
  const defaultParsePaste = (str) => str.split(/\r\n|\n|\r/).map((row) => row.split("	"));
}
var ReactDataGrid;
var TableDataModal2;
var tableDataModal_default = TableDataModal2;

// app/components/foodWasteModals/foodWasteBannerModal.jsx
var import_react6 = __toESM(require_react());
var import_react_modal3 = __toESM(require_lib());

// app/components/foodWasteModals/foodWaste.jsx
var import_react5 = __toESM(require_react());

// node_modules/react-chartjs-2/dist/index.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range2 = 255;
  const r = v.r / range2;
  const g = v.g / range2;
  const b = v.b / range2;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  "": (v) => v,
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range2) {
  const roundedRange = Math.round(range2);
  range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
  const niceRange = Math.pow(10, Math.floor(log10(range2)));
  const fraction = range2 / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta2._sorted) {
    const { iScale, _parsed } = meta2;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        _lookupByKey(_parsed, axis, min).lo,
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      ), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta2) {
  const { xScale, yScale, _scaleRanges } = meta2;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta2._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta2, data, start, count) {
  const { iScale } = meta2;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta2) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta2.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta2) {
  return `${indexScale.id}.${valueScale.id}.${meta2.stack || meta2.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta2 of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta2.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta2.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta2 } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta2;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta2);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta2.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta2.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta2, items) {
  const datasetIndex = meta2.controller.index;
  const axis = meta2.vScale && meta2.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta2._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta2, chart) => canStack && !meta2.hidden && meta2._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta2 = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta2._stacked = isStacked(meta2.vScale, meta2);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta2 = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta2.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta2.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta2.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta2.indexAxis;
    const iid = meta2.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta2.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta2.xScale = this.getScaleForId(xid);
    meta2.yScale = this.getScaleForId(yid);
    meta2.rScale = this.getScaleForId(rid);
    meta2.iScale = this.getScaleForId(iid);
    meta2.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta2 = this._cachedMeta;
    return scale === meta2.iScale ? meta2.vScale : meta2.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta2 = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta2._stacked) {
      clearStacks(meta2);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta2 = this._cachedMeta;
        clearStacks(meta2);
        meta2._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta2 = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta2.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta2 = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta2._stacked;
    meta2._stacked = isStacked(meta2.vScale, meta2);
    if (meta2.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta2);
      meta2.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta2._stacked) {
      updateStacks(this, meta2._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta2, _data: data } = this;
    const { iScale, _stacked } = meta2;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta2._sorted;
    let prev = start > 0 && meta2._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta2._parsed = data;
      meta2._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta2, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta2, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta2, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta2._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta2._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta2, data, start, count) {
    const { iScale, vScale } = meta2;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta2, data, start, count) {
    const { xScale, yScale } = meta2;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta2, data, start, count) {
    const { xScale, yScale } = meta2;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta2 = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta2.index, {
      mode
    });
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range2.min = Math.min(range2.min, value);
    range2.max = Math.max(range2.max, value);
  }
  getMinMax(scale, canStack) {
    const meta2 = this._cachedMeta;
    const _parsed = meta2._parsed;
    const sorted = meta2._sorted && scale === meta2.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta2, this.chart);
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range2, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        break;
      }
    }
    return range2;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const iScale = meta2.iScale;
    const vScale = meta2.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta2 = this._cachedMeta;
    this.update(mode || "default");
    meta2._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta2.xScale, meta2.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta2 = this._cachedMeta;
    const elements2 = meta2.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta2.dataset) {
      meta2.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta2 = this._cachedMeta;
    const data = meta2.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta2._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta2 = this._cachedMeta;
    if (this._parsing) {
      const removed = meta2._parsed.splice(start, count);
      if (meta2._stacked) {
        clearStacks(meta2, removed);
      }
    }
    meta2.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta2) {
  const scale = meta2.iScale;
  const values = getAllScaleValues(scale, meta2.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta2, data, start, count) {
  const iScale = meta2.iScale;
  const vScale = meta2.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta2, data, start, count) {
    return parseArrayOrPrimitive(meta2, data, start, count);
  }
  parseArrayData(meta2, data, start, count) {
    return parseArrayOrPrimitive(meta2, data, start, count);
  }
  parseObjectData(meta2, data, start, count) {
    const { iScale, vScale } = meta2;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    super.updateRangeFromParsed(range2, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range2.min = Math.min(range2.min, custom.min);
      range2.max = Math.max(range2.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const { iScale, vScale } = meta2;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta2 = this._cachedMeta;
    meta2.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta2 = this._cachedMeta;
    this.updateElements(meta2.data, 0, meta2.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta2) => meta2.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta2) => {
      const parsed = meta2.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta2.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta2 of metasets) {
      if (dataIndex !== void 0 && skipNull(meta2)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta2.stack) === -1 || stacked === void 0 && meta2.stack === void 0) {
        stacks.push(meta2.stack);
      }
      if (meta2.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta2 = this._cachedMeta;
    const iScale = meta2.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta2.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta2);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
      size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta2 = this._cachedMeta;
    const vScale = meta2.vScale;
    const rects = meta2.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta2, data, start, count) {
    const parsed = super.parsePrimitiveData(meta2, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta2, data, start, count) {
    const parsed = super.parseArrayData(meta2, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta2, data, start, count) {
    const parsed = super.parseObjectData(meta2, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta2;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta2 = this._cachedMeta;
    if (this._parsing === false) {
      meta2._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta2._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta2 = this._cachedMeta;
    const arcs = meta2.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta2.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta2 = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta2._parsed[i] === null || meta2.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta2._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta2 = this._cachedMeta;
    const metaData = meta2.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta2._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta2._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta2, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta2 = chart.getDatasetMeta(i);
          arcs = meta2.data;
          controller = meta2.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta2 = chart.getDatasetMeta(0);
              const style = meta2.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta2 = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta2;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta2)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta2 = this._cachedMeta;
    const dataset = meta2.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta2.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta2 = this._cachedMeta;
    meta2.dataset.updateControlPoints(this.chart.chartArea, meta2.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta2._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta2, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta2, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta2 = this._cachedMeta;
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta2.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range2.min) {
          range2.min = parsed;
        }
        if (parsed > range2.max) {
          range2.max = parsed;
        }
      }
    });
    return range2;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta2 = this._cachedMeta;
    let count = 0;
    meta2.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta2 = chart.getDatasetMeta(0);
              const style = meta2.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta2, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta2, data, start, count);
  }
  update(mode) {
    const meta2 = this._cachedMeta;
    const line = meta2.dataset;
    const points = meta2.data || [];
    const labels = meta2.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
var ScatterController = class extends DatasetController {
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta2;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta2 = this._cachedMeta;
    const { data: points = [] } = meta2;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta2)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta2;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta2.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta2 = this._cachedMeta;
    const data = meta2.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta2.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  options;
  constructor(options) {
    this.options = options || {};
  }
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range2 = typeof el.getRange === "function" && el.getRange(axis);
      if (range2) {
        const start = lookupMethod(data, axis, value - range2);
        const end = lookupMethod(data, axis, value + range2);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta2) => {
        const index2 = items[0].index;
        const element = meta2.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta2.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element2 = class {
  x;
  y;
  active = false;
  options;
  $animations;
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element2, "defaults", {});
__publicField(Element2, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element2 {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range2;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range2 = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range2.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range2.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width;
            } else if (i > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta2 = metas[i];
      if (meta2[axisID] === this.id && (!type || meta2.type === type)) {
        result.push(meta2);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element2, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.2";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta2, chartArea) {
  const { xScale, yScale } = meta2;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta2, index2) => {
      if (datasets.filter((x) => x === meta2._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta2 = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta2.type && meta2.type !== type) {
        this._destroyDatasetMeta(i);
        meta2 = this.getDatasetMeta(i);
      }
      meta2.type = type;
      meta2.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta2.order = dataset.order || 0;
      meta2.index = i;
      meta2.label = "" + dataset.label;
      meta2.visible = this.isDatasetVisible(i);
      if (meta2.controller) {
        meta2.controller.updateIndex(i);
        meta2.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta2.controller = new ControllerClass(this, i);
        newControllers.push(meta2.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta2 = this.getDatasetMeta(index2);
    const args = {
      meta: meta2,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta2.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta2 = metasets[i];
      if (!filterVisible || meta2.visible) {
        result.push(meta2);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta2) {
    const ctx = this.ctx;
    const clip = meta2._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta2, this.chartArea);
    const args = {
      meta: meta2,
      index: meta2.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta2.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta2 = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta2) {
      meta2 = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta2);
    }
    return meta2;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta2 = this.getDatasetMeta(datasetIndex);
    return typeof meta2.hidden === "boolean" ? !meta2.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta2 = this.getDatasetMeta(datasetIndex);
    meta2.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta2 = this.getDatasetMeta(datasetIndex);
    const anims = meta2.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta2.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta2, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta2 = this._metasets[datasetIndex];
    if (meta2 && meta2.controller) {
      meta2.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta2, item, i, ilen;
    if (mode === "dataset") {
      meta2 = this.getDatasetMeta(items[0].datasetIndex);
      meta2.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta2 = this.getDatasetMeta(datasetIndex);
      if (!meta2) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta2.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element2 {
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element2 {
  parsed;
  skip;
  stop;
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
];
var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta2, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta2;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta2 = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta2.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta2.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta2, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta2 = metas[i];
    if (meta2.index === index2) {
      break;
    }
    if (!meta2.hidden) {
      below.unshift(meta2.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta2 = chart.getDatasetMeta(index2);
  const visible = meta2 && chart.isDatasetVisible(index2);
  return visible ? meta2.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta2, i, line, source;
    for (i = 0; i < count; ++i) {
      meta2 = chart.getDatasetMeta(i);
      line = meta2.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta2.controller.options.indexAxis,
          scale: meta2.vScale,
          line
        };
      }
      meta2.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element2 {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta2) => {
          const style = meta2.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta2.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta2.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta2.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element2 {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta2.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta2.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element2 {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta2 = this.chart.getDatasetMeta(datasetIndex);
      if (!meta2) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta2.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range2 = max - min;
  let rangeExp = log10Floor(range2);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format2) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format2 || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format2) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format2);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/react-chartjs-2/dist/index.js
var defaultDatasetIdKey = "label";
function reforwardRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function setOptions(chart, nextOptions) {
  const options = chart.options;
  if (options && nextOptions) {
    Object.assign(options, nextOptions);
  }
}
function setLabels(currentData, nextLabels) {
  currentData.labels = nextLabels;
}
function setDatasets(currentData, nextDatasets) {
  let datasetIdKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultDatasetIdKey;
  const addedDatasets = [];
  currentData.datasets = nextDatasets.map((nextDataset) => {
    const currentDataset = currentData.datasets.find((dataset) => dataset[datasetIdKey] === nextDataset[datasetIdKey]);
    if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
      return {
        ...nextDataset
      };
    }
    addedDatasets.push(currentDataset);
    Object.assign(currentDataset, nextDataset);
    return currentDataset;
  });
}
function cloneData(data) {
  let datasetIdKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultDatasetIdKey;
  const nextData = {
    labels: [],
    datasets: []
  };
  setLabels(nextData, data.labels);
  setDatasets(nextData, data.datasets, datasetIdKey);
  return nextData;
}
function ChartComponent(props, ref) {
  const { height = 150, width = 300, redraw = false, datasetIdKey, type, data, options, plugins: plugins2 = [], fallbackContent, updateMode, ...canvasProps } = props;
  const canvasRef = (0, import_react4.useRef)(null);
  const chartRef = (0, import_react4.useRef)();
  const renderChart = () => {
    if (!canvasRef.current)
      return;
    chartRef.current = new Chart(canvasRef.current, {
      type,
      data: cloneData(data, datasetIdKey),
      options: options && {
        ...options
      },
      plugins: plugins2
    });
    reforwardRef(ref, chartRef.current);
  };
  const destroyChart = () => {
    reforwardRef(ref, null);
    if (chartRef.current) {
      chartRef.current.destroy();
      chartRef.current = null;
    }
  };
  (0, import_react4.useEffect)(() => {
    if (!redraw && chartRef.current && options) {
      setOptions(chartRef.current, options);
    }
  }, [
    redraw,
    options
  ]);
  (0, import_react4.useEffect)(() => {
    if (!redraw && chartRef.current) {
      setLabels(chartRef.current.config.data, data.labels);
    }
  }, [
    redraw,
    data.labels
  ]);
  (0, import_react4.useEffect)(() => {
    if (!redraw && chartRef.current && data.datasets) {
      setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);
    }
  }, [
    redraw,
    data.datasets
  ]);
  (0, import_react4.useEffect)(() => {
    if (!chartRef.current)
      return;
    if (redraw) {
      destroyChart();
      setTimeout(renderChart);
    } else {
      chartRef.current.update(updateMode);
    }
  }, [
    redraw,
    options,
    data.labels,
    data.datasets,
    updateMode
  ]);
  (0, import_react4.useEffect)(() => {
    if (!chartRef.current)
      return;
    destroyChart();
    setTimeout(renderChart);
  }, [
    type
  ]);
  (0, import_react4.useEffect)(() => {
    renderChart();
    return () => destroyChart();
  }, []);
  return /* @__PURE__ */ import_react4.default.createElement("canvas", Object.assign({
    ref: canvasRef,
    role: "img",
    height,
    width
  }, canvasProps), fallbackContent);
}
var Chart2 = /* @__PURE__ */ (0, import_react4.forwardRef)(ChartComponent);
function createTypedChart(type, registerables2) {
  Chart.register(registerables2);
  return /* @__PURE__ */ (0, import_react4.forwardRef)((props, ref) => /* @__PURE__ */ import_react4.default.createElement(Chart2, Object.assign({}, props, {
    ref,
    type
  })));
}
var Line = /* @__PURE__ */ createTypedChart("line", LineController);

// node_modules/chart.js/auto/auto.js
Chart.register(...registerables);

// app/components/foodWasteModals/foodWaste.jsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function FoodWaste({ graphPoints, AnnualWaste, year }) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const Labels = ["0"];
  const palteWasteDataSet = [0];
  const totalWasteDataSet = [0];
  graphPoints == null ? void 0 : graphPoints.map((e, i) => {
    Labels.push(`${i + 1}`);
    palteWasteDataSet.push(e == null ? void 0 : e.plate_waste);
    totalWasteDataSet.push(e == null ? void 0 : e.total_waste);
  });
  const palteWasteData = {
    labels: Labels,
    datasets: [
      {
        label: "",
        data: palteWasteDataSet,
        borderColor: "#A9A8B8",
        backgroundColor: "#A9A8B8",
        pointStyle: "circle",
        fill: true,
        pointRadius: 0,
        lineTension: 0.5
      }
    ]
  };
  const totalWasteData = {
    labels: Labels,
    datasets: [
      {
        label: "",
        data: totalWasteDataSet,
        borderColor: "#A9A8B8",
        backgroundColor: "#A9A8B8",
        pointStyle: "circle",
        fill: true,
        pointRadius: 0,
        lineTension: 0.5
      }
    ]
  };
  const options = {
    responsive: true,
    bezierCurve: true,
    title: {
      display: false
    },
    plugins: {
      legend: {
        display: false
      }
    },
    legend: {
      display: false
    },
    tooltips: {
      enabled: false
    },
    scales: {
      x: {
        grid: {
          display: false
        },
        ticks: {
          display: false
        }
      },
      y: {
        grid: {
          display: false
        },
        ticks: {
          display: false
        }
      }
    }
  };
  const containerCall = ({
    title,
    val1,
    val2,
    graph,
    Increased,
    graphPresent
  }) => {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
      className: "felx-col ",
      children: [
        (val1 > 0 || val2 > 0 || graphPresent) && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "m-text f-2vw fs-1-6vw fw-700",
          children: title
        }, void 0, false, {
          fileName: "app/components/foodWasteModals/foodWaste.jsx",
          lineNumber: 96,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "flex text-center gap-5 justify-between py-2 items-end",
          children: [
            val1 > 0 && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "items-center justify-center align-middle",
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                  className: "mb-3 block text-sm font-medium",
                  children: "Last Week"
                }, void 0, false, {
                  fileName: "app/components/foodWasteModals/foodWaste.jsx",
                  lineNumber: 101,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: `${!Increased ? "text-red-600" : "text-emerald-600"} relative flex border-2 gap-1 rounded-full border-black w-[150px] max-w-[150px] h-[150px] max-h-[150px] justify-center items-center`,
                  children: [
                    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                      className: "text-4xl font-bold",
                      children: val1 == null ? void 0 : val1.toFixed(2)
                    }, void 0, false, {
                      fileName: "app/components/foodWasteModals/foodWaste.jsx",
                      lineNumber: 106,
                      columnNumber: 17
                    }, this),
                    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                      className: "font-medium flex text-3xl max-w-[18px] justify-center",
                      children: !Increased ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                        className: "ri-arrow-up-line ri-1x"
                      }, void 0, false, {
                        fileName: "app/components/foodWasteModals/foodWaste.jsx",
                        lineNumber: 109,
                        columnNumber: 21
                      }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                        className: "ri-arrow-down-line ri-1x"
                      }, void 0, false, {
                        fileName: "app/components/foodWasteModals/foodWaste.jsx",
                        lineNumber: 111,
                        columnNumber: 21
                      }, this)
                    }, void 0, false, {
                      fileName: "app/components/foodWasteModals/foodWaste.jsx",
                      lineNumber: 107,
                      columnNumber: 17
                    }, this)
                  ]
                }, void 0, true, {
                  fileName: "app/components/foodWasteModals/foodWaste.jsx",
                  lineNumber: 102,
                  columnNumber: 15
                }, this)
              ]
            }, void 0, true, {
              fileName: "app/components/foodWasteModals/foodWaste.jsx",
              lineNumber: 100,
              columnNumber: 13
            }, this),
            val2 > 0 && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "items-center justify-center flex",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                className: "max-w-[150px]",
                children: [
                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                    className: "mb-3 block text-sm font-medium",
                    children: [
                      "Annual ",
                      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("br", {}, void 0, false, {
                        fileName: "app/components/foodWasteModals/foodWaste.jsx",
                        lineNumber: 121,
                        columnNumber: 26
                      }, this),
                      " Weekly Average"
                    ]
                  }, void 0, true, {
                    fileName: "app/components/foodWasteModals/foodWaste.jsx",
                    lineNumber: 120,
                    columnNumber: 17
                  }, this),
                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                    className: "flex border-2 rounded-full border-black	w-[150px] max-w-[150px] h-[150px] max-h-[150px] justify-center items-center",
                    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                      className: "text-4xl font-bold",
                      children: val2
                    }, void 0, false, {
                      fileName: "app/components/foodWasteModals/foodWaste.jsx",
                      lineNumber: 124,
                      columnNumber: 19
                    }, this)
                  }, void 0, false, {
                    fileName: "app/components/foodWasteModals/foodWaste.jsx",
                    lineNumber: 123,
                    columnNumber: 17
                  }, this)
                ]
              }, void 0, true, {
                fileName: "app/components/foodWasteModals/foodWaste.jsx",
                lineNumber: 119,
                columnNumber: 15
              }, this)
            }, void 0, false, {
              fileName: "app/components/foodWasteModals/foodWaste.jsx",
              lineNumber: 118,
              columnNumber: 13
            }, this),
            graphPresent && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "",
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                  className: "mb-5"
                }, void 0, false, {
                  fileName: "app/components/foodWasteModals/foodWaste.jsx",
                  lineNumber: 131,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: "",
                  children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Line, {
                    data: graph == null ? void 0 : graph.data,
                    options: graph == null ? void 0 : graph.options,
                    width: "650px"
                  }, void 0, false, {
                    fileName: "app/components/foodWasteModals/foodWaste.jsx",
                    lineNumber: 133,
                    columnNumber: 17
                  }, this)
                }, void 0, false, {
                  fileName: "app/components/foodWasteModals/foodWaste.jsx",
                  lineNumber: 132,
                  columnNumber: 15
                }, this)
              ]
            }, void 0, true, {
              fileName: "app/components/foodWasteModals/foodWaste.jsx",
              lineNumber: 130,
              columnNumber: 13
            }, this)
          ]
        }, void 0, true, {
          fileName: "app/components/foodWasteModals/foodWaste.jsx",
          lineNumber: 98,
          columnNumber: 9
        }, this)
      ]
    }, void 0, true, {
      fileName: "app/components/foodWasteModals/foodWaste.jsx",
      lineNumber: 94,
      columnNumber: 7
    }, this);
  };
  const plate_waste_graph = graphPoints == null ? void 0 : graphPoints.filter(
    (e) => (e == null ? void 0 : e.plate_waste) !== 0 && (e == null ? void 0 : e.plate_waste) !== null
  );
  const total_waste_graph = graphPoints == null ? void 0 : graphPoints.filter(
    (e) => (e == null ? void 0 : e.total_waste) !== 0 && (e == null ? void 0 : e.total_waste) !== null
  );
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
    className: "",
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
        className: "mb-5",
        children: containerCall({
          title: "Plate Waste",
          val1: graphPoints !== void 0 && ((_a = graphPoints[1]) == null ? void 0 : _a.plate_waste),
          val2: (_b = Number(AnnualWaste == null ? void 0 : AnnualWaste.plate_waste)) == null ? void 0 : _b.toFixed(2),
          Increased: graphPoints !== void 0 && ((_c = graphPoints[1]) == null ? void 0 : _c.plate_waste) < ((_d = graphPoints[2]) == null ? void 0 : _d.plate_waste),
          graph: { data: palteWasteData, options },
          graphPresent: (plate_waste_graph == null ? void 0 : plate_waste_graph.length) > 0
        })
      }, void 0, false, {
        fileName: "app/components/foodWasteModals/foodWaste.jsx",
        lineNumber: 153,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
        className: "total-waste",
        children: containerCall({
          title: "Total Waste",
          val1: graphPoints !== void 0 && ((_e = graphPoints[1]) == null ? void 0 : _e.total_waste),
          val2: (_f = Number(AnnualWaste == null ? void 0 : AnnualWaste.total_waste)) == null ? void 0 : _f.toFixed(2),
          Increased: graphPoints !== void 0 && ((_g = graphPoints[1]) == null ? void 0 : _g.total_waste) < ((_h = graphPoints[2]) == null ? void 0 : _h.total_waste),
          graph: { data: totalWasteData, options },
          graphPresent: (total_waste_graph == null ? void 0 : total_waste_graph.length) > 0
        })
      }, void 0, false, {
        fileName: "app/components/foodWasteModals/foodWaste.jsx",
        lineNumber: 165,
        columnNumber: 7
      }, this)
    ]
  }, void 0, true, {
    fileName: "app/components/foodWasteModals/foodWaste.jsx",
    lineNumber: 152,
    columnNumber: 5
  }, this);
}
var foodWaste_default = FoodWaste;

// app/components/foodWasteModals/foodWasteBannerModal.jsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function FoodWasteBannerModal(prop) {
  const { Details, setIsOpenv } = prop;
  const [modalIsOpen, setIsOpen] = import_react6.default.useState(setIsOpenv ? true : false);
  const closeModal = () => {
    setIsOpenv(false);
    setIsOpen(false);
  };
  const CopyLink = () => {
    var _a;
    (_a = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _a.writeText(
      `${FRONTEND_URL}/banner/foodwaste/${Details == null ? void 0 : Details.LocationId}`
    );
    Q.success("Link copied to clipboard!");
  };
  const customStyles = {
    content: {
      top: "50%",
      left: "50%",
      right: "auto",
      bottom: "auto",
      marginRight: "-50%",
      transform: "translate(-50%, -50%)",
      padding: "0px",
      width: "96%"
    }
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
    className: "w-100 h-100",
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react_modal3.default, {
      isOpen: modalIsOpen,
      onRequestClose: closeModal,
      style: customStyles,
      contentLabel: "Food Waste Modal",
      ariaHideApp: false,
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "bg-[#FAFAFA] rounded-[10px] shadow-lg px-6 py-12 w-full relative lg:px-9 station-preview",
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "close-div",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
                onClick: closeModal,
                className: "float-right",
                children: [
                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("img", {
                    src: closeIcon_default,
                    alt: "close-icon"
                  }, void 0, false, {
                    fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
                    lineNumber: 45,
                    columnNumber: 15
                  }, this),
                  " "
                ]
              }, void 0, true, {
                fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
                lineNumber: 44,
                columnNumber: 13
              }, this)
            }, void 0, false, {
              fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
              lineNumber: 43,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: `banner-fluid food-waste-banner w-full`,
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                className: "content-vh ",
                children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: `container !w-full`,
                  children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(foodWaste_default, {
                    graphPoints: Details == null ? void 0 : Details.graphPoints,
                    AnnualWaste: Details == null ? void 0 : Details.AnnualWaste,
                    year: Details == null ? void 0 : Details.year
                  }, void 0, false, {
                    fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
                    lineNumber: 51,
                    columnNumber: 17
                  }, this)
                }, void 0, false, {
                  fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
                  lineNumber: 50,
                  columnNumber: 15
                }, this)
              }, void 0, false, {
                fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
                lineNumber: 49,
                columnNumber: 13
              }, this)
            }, void 0, false, {
              fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
              lineNumber: 48,
              columnNumber: 11
            }, this)
          ]
        }, void 0, true, {
          fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
          lineNumber: 42,
          columnNumber: 9
        }, this),
        (Details == null ? void 0 : Details.isAdminuser) && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: `bottom-row banner-button`,
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
            onClick: CopyLink,
            children: [
              "Copy Link ",
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                className: "ri-clipboard-line"
              }, void 0, false, {
                fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
                lineNumber: 63,
                columnNumber: 25
              }, this)
            ]
          }, void 0, true, {
            fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
            lineNumber: 62,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
          lineNumber: 61,
          columnNumber: 11
        }, this)
      ]
    }, void 0, true, {
      fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
      lineNumber: 35,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: "app/components/foodWasteModals/foodWasteBannerModal.jsx",
    lineNumber: 34,
    columnNumber: 5
  }, this);
}
var foodWasteBannerModal_default = FoodWasteBannerModal;

// app/components/datePicker/cellCopy.jsx
var import_react7 = __toESM(require_react());
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function CellCopy(prop) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const stationData = prop == null ? void 0 : prop.station;
  const divShow = (prop == null ? void 0 : prop.copyMealClickIndex) != void 0 && (prop == null ? void 0 : prop.copyMealClickIndex) != "" && (prop == null ? void 0 : prop.childIndex) == ((_a = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _a.key) && (stationData == null ? void 0 : stationData.date) == ((_b = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _b.date) && (stationData == null ? void 0 : stationData.stationId) == ((_c = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _c.sId) && ((_d = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _d.type) !== "paste" ? true : false;
  const modalShow = (prop == null ? void 0 : prop.copyMealClickIndex) != void 0 && (prop == null ? void 0 : prop.copyMealClickIndex) != "" && (prop == null ? void 0 : prop.childIndex) == ((_e = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _e.key) && (stationData == null ? void 0 : stationData.date) == ((_f = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _f.date) && (stationData == null ? void 0 : stationData.stationId) == ((_g = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _g.sId) && ((_h = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _h.type) === "paste" && ((_i = prop == null ? void 0 : prop.copyMealClickIndex) == null ? void 0 : _i.modal) ? true : false;
  const [isDivVisible, setDivVisible] = (0, import_react7.useState)(divShow);
  const [modalIsOpen, setIsOpen] = (0, import_react7.useState)(modalShow);
  const [bannerModalIsOpen, setBannerIsOpen] = (0, import_react7.useState)(modalShow);
  const [modalLoader, setModalLoader] = (0, import_react7.useState)(false);
  const divRef = (0, import_react7.useRef)(null);
  (0, import_react7.useEffect)(() => {
    const handleClickOutside = (event) => {
      if (divRef.current && !divRef.current.contains(event.target)) {
        setDivVisible(false);
        (prop == null ? void 0 : prop.CopyMealClickIndex) != void 0 && (prop == null ? void 0 : prop.CopyMealClickIndex(""));
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);
  const toggleDiv = async () => {
    var _a2, _b2;
    const PasteData = await ((_b2 = (_a2 = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _a2.readText()) == null ? void 0 : _b2.then((clipText) => {
      const arr = [
        "stationId",
        "stationUniqueId",
        "stationName",
        "locationId",
        "date",
        "contentId",
        "updateId"
      ];
      const val = arr == null ? void 0 : arr.map((e) => clipText == null ? void 0 : clipText.includes(e));
      return (val == null ? void 0 : val.includes(false)) !== true ? JSON == null ? void 0 : JSON.parse(clipText) : "";
    }));
    (prop == null ? void 0 : prop.CopyMealClickIndex) != void 0 && (prop == null ? void 0 : prop.CopyMealClickIndex({
      key: prop == null ? void 0 : prop.childIndex,
      date: stationData == null ? void 0 : stationData.date,
      sId: stationData == null ? void 0 : stationData.stationId,
      modal: (PasteData == null ? void 0 : PasteData.stationId) === (stationData == null ? void 0 : stationData.stationId)
    }));
    setDivVisible(!isDivVisible);
  };
  const CopyHandle = async (e) => {
    var _a2, _b2;
    if ((stationData == null ? void 0 : stationData.updateId) !== void 0) {
      const data = {
        stationId: stationData == null ? void 0 : stationData.stationId,
        stationUniqueId: stationData == null ? void 0 : stationData.stationUniqueId,
        stationName: stationData == null ? void 0 : stationData.stationName,
        locationId: stationData == null ? void 0 : stationData.locationId,
        date: stationData == null ? void 0 : stationData.date,
        contentId: stationData == null ? void 0 : stationData.contentId,
        updateId: stationData == null ? void 0 : stationData.updateId,
        plateImg: (_a2 = stationData == null ? void 0 : stationData.plateImg) == null ? void 0 : _a2.id
      };
      (_b2 = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _b2.writeText(JSON.stringify(data));
      Q.success("Data copied to clipboard!");
    } else {
      Q.error(
        "Unable to perform Copy Meal since the respective station doesn't have a data."
      );
    }
    (prop == null ? void 0 : prop.CopyMealClickIndex) != void 0 && (prop == null ? void 0 : prop.CopyMealClickIndex(""));
    setDivVisible(false);
  };
  const PasteHandle = async () => {
    var _a2, _b2, _c2, _d2, _e2;
    setModalLoader(true);
    let PasteData = await ((_b2 = (_a2 = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _a2.readText()) == null ? void 0 : _b2.then((clipText) => JSON == null ? void 0 : JSON.parse(clipText)));
    if ((PasteData == null ? void 0 : PasteData.stationId) === (stationData == null ? void 0 : stationData.stationId)) {
      if ((PasteData == null ? void 0 : PasteData.updateId) !== void 0) {
        const currentStationMenuId = await directusLoaderLink.items("screen_display").readByQuery({
          fields: ["*.*."],
          filter: {
            location_id: { _eq: stationData == null ? void 0 : stationData.locationId },
            date: { _eq: stationData == null ? void 0 : stationData.date },
            station_name: { _eq: stationData == null ? void 0 : stationData.stationId }
          }
        }).then((e) => e == null ? void 0 : e.data[0]);
        if ((currentStationMenuId == null ? void 0 : currentStationMenuId.id) > 0) {
          await ((_c2 = directusLoaderLink.items("screen_display")) == null ? void 0 : _c2.updateOne(currentStationMenuId == null ? void 0 : currentStationMenuId.id, {
            recipe_id: PasteData == null ? void 0 : PasteData.updateId,
            app_resultant_image: !!(PasteData == null ? void 0 : PasteData.plateImg) ? PasteData == null ? void 0 : PasteData.plateImg : null
          }).then((re) => {
          }).catch((e) => {
            console.log(e);
            errorFlag = true;
          }));
        } else {
          await ((_d2 = directusLoaderLink.items("screen_display")) == null ? void 0 : _d2.createOne({
            station_name: stationData == null ? void 0 : stationData.stationId,
            date: stationData == null ? void 0 : stationData.date,
            location_id: stationData == null ? void 0 : stationData.locationId,
            recipe_id: PasteData == null ? void 0 : PasteData.updateId,
            app_resultant_image: !!(PasteData == null ? void 0 : PasteData.plateImg) ? PasteData == null ? void 0 : PasteData.plateImg : null
          }).then((re) => {
            return re == null ? void 0 : re.id;
          }).catch((e) => {
            console.log(e, "error");
          }));
        }
        localStorage.setItem(
          "LastWacthedWeek",
          ((_e2 = new Date(stationData == null ? void 0 : stationData.date)) == null ? void 0 : _e2.getDay()) == 0 ? format(addDays(new Date(stationData == null ? void 0 : stationData.date), -2), "yyyy-MM-dd") : stationData == null ? void 0 : stationData.date
        );
      } else {
        Q.error(
          "Unable to paste the data since the copied station doesn't have any data."
        );
      }
    } else {
      Q.error(
        "Unable to perform paste meal since copy and paste station is the same date."
      );
    }
    prop.CopyMealClickIndex !== void 0 && (prop == null ? void 0 : prop.CopyMealClickIndex(""));
    setIsOpen(false);
    prop == null ? void 0 : prop.setRefresh(!(prop == null ? void 0 : prop.refresh));
  };
  const ModelOpenHandle = async () => {
    var _a2, _b2;
    setDivVisible(false);
    let PasteData = await ((_b2 = (_a2 = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _a2.readText()) == null ? void 0 : _b2.then((clipText) => JSON == null ? void 0 : JSON.parse(clipText)));
    (prop == null ? void 0 : prop.CopyMealClickIndex) != void 0 && (prop == null ? void 0 : prop.CopyMealClickIndex({
      type: "paste",
      key: prop == null ? void 0 : prop.childIndex,
      date: stationData == null ? void 0 : stationData.date,
      sId: stationData == null ? void 0 : stationData.stationId,
      modal: (PasteData == null ? void 0 : PasteData.stationId) === (stationData == null ? void 0 : stationData.stationId)
    }));
    if ((PasteData == null ? void 0 : PasteData.date) !== (stationData == null ? void 0 : stationData.date)) {
      (PasteData == null ? void 0 : PasteData.stationUniqueId) === (stationData == null ? void 0 : stationData.stationUniqueId) ? setIsOpen(true) : Q.error(
        "Unable to perform paste meal due to different station selection"
      );
    } else {
      Q.error(
        "Unable to perform paste meal since copy and paste station is the same date."
      );
    }
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
    className: " ",
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
        onClick: toggleDiv,
        className: "cursor-pointer  ri-more-2-fill right-0 "
      }, void 0, false, {
        fileName: "app/components/datePicker/cellCopy.jsx",
        lineNumber: 192,
        columnNumber: 7
      }, this),
      isDivVisible && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
        className: "div-block",
        ref: divRef,
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: `
          flex flex-col p-4 font-normal absolute min-w-[150px] bg-[#f4f4f4] border-1 right-0 z-10 gap-3 text-sm meal-popup`,
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              onClick: () => CopyHandle(),
              className: "font-normal cursor-pointer text-black",
              children: "Copy meal"
            }, void 0, false, {
              fileName: "app/components/datePicker/cellCopy.jsx",
              lineNumber: 202,
              columnNumber: 13
            }, this),
            " ",
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              onClick: () => ModelOpenHandle(),
              className: "font-normal cursor-pointer text-black",
              children: "Paste meal"
            }, void 0, false, {
              fileName: "app/components/datePicker/cellCopy.jsx",
              lineNumber: 208,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              onClick: () => {
                setDivVisible(false);
                setBannerIsOpen(true);
              },
              className: "font-normal cursor-pointer text-black",
              children: "Preview slide"
            }, void 0, false, {
              fileName: "app/components/datePicker/cellCopy.jsx",
              lineNumber: 214,
              columnNumber: 13
            }, this)
          ]
        }, void 0, true, {
          fileName: "app/components/datePicker/cellCopy.jsx",
          lineNumber: 198,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: "app/components/datePicker/cellCopy.jsx",
        lineNumber: 197,
        columnNumber: 9
      }, this),
      modalIsOpen && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(confirmationModal_default, {
        modalIsOpen,
        setIsOpen,
        content: "Are you sure to paste station data?",
        callFunction: PasteHandle,
        CopyMealClickIndex: prop == null ? void 0 : prop.CopyMealClickIndex,
        Loader: modalLoader
      }, void 0, false, {
        fileName: "app/components/datePicker/cellCopy.jsx",
        lineNumber: 229,
        columnNumber: 9
      }, this),
      bannerModalIsOpen && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(bannerPopup_default, {
        modalIsOpenParent: bannerModalIsOpen,
        setIsOpenParent: setBannerIsOpen,
        data: stationData,
        isAdminUser: prop == null ? void 0 : prop.isAdminUser,
        calorie: stationData == null ? void 0 : stationData.calorie,
        co2: stationData == null ? void 0 : stationData.co2
      }, void 0, false, {
        fileName: "app/components/datePicker/cellCopy.jsx",
        lineNumber: 239,
        columnNumber: 9
      }, this)
    ]
  }, void 0, true, {
    fileName: "app/components/datePicker/cellCopy.jsx",
    lineNumber: 191,
    columnNumber: 5
  }, this);
}
var cellCopy_default = CellCopy;

// app/components/banner/lunchBanner.jsx
var import_react8 = __toESM(require_react());
var import_react_modal4 = __toESM(require_lib());
var import_react_responsive_carousel = __toESM(require_js());
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function LunchBanner(props) {
  const { setIsOpenParent, data, isAdminUser, modalIsOpenParent, LocationId } = props;
  const [modalIsOpen, setIsOpen] = (0, import_react8.useState)(
    modalIsOpenParent === true ? true : false
  );
  const customStyles = {
    overlay: {
      zIndex: 12
    },
    content: {
      top: "50%",
      left: "50%",
      right: "auto",
      bottom: "auto",
      marginRight: "-50%",
      transform: "translate(-50%, -50%)",
      padding: "0px",
      width: "96%",
      maxWidth: "1200px",
      maxHeight: "94vh"
    }
  };
  const copyText = ({ language, type }) => {
    var _a;
    (_a = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _a.writeText(
      `${FRONTEND_URL}/banner/today-menu/${LocationId}/${language}/${type}`
    );
    Q.success("Link copied to clipboard!");
  };
  const closeModal = () => {
    setIsOpenParent(false);
    setIsOpen(false);
  };
  const arr = [];
  const renderSingleItem = ({ language, Value, part }) => {
    arr.push(
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(lunchContent_default, {
        copyText,
        language,
        isAdminUser,
        data: Value,
        part,
        LocationId
      }, Math.random(), false, {
        fileName: "app/components/banner/lunchBanner.jsx",
        lineNumber: 45,
        columnNumber: 7
      }, this)
    );
  };
  const renderItems = () => {
    for (let m = 0; m < 2; m++) {
      const lang = m === 0 ? "da" : "en";
      for (let i = 0, j = 1; i < ((data == null ? void 0 : data.length) > 0 ? data == null ? void 0 : data.length : 1); i = i + 5, j++) {
        renderSingleItem({
          language: lang,
          Value: (data == null ? void 0 : data.length) > 0 ? data == null ? void 0 : data.slice(i, j * 5) : [],
          part: j
        });
      }
    }
    return arr;
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
    className: "w-100,h-100",
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react_modal4.default, {
      isOpen: modalIsOpen,
      onRequestClose: closeModal,
      style: customStyles,
      ariaHideApp: false,
      contentLabel: "Banner Preview",
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
        className: "w-full min-h-[86%] lunch-preview",
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: "close-div",
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
              onClick: closeModal,
              className: "float-right",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("img", {
                src: closeIcon_default,
                alt: "close-icon"
              }, void 0, false, {
                fileName: "app/components/banner/lunchBanner.jsx",
                lineNumber: 85,
                columnNumber: 15
              }, this)
            }, void 0, false, {
              fileName: "app/components/banner/lunchBanner.jsx",
              lineNumber: 84,
              columnNumber: 13
            }, this)
          }, void 0, false, {
            fileName: "app/components/banner/lunchBanner.jsx",
            lineNumber: 83,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react_responsive_carousel.Carousel, {
            showArrows: true,
            useKeyboardArrows: true,
            autoPlay: true,
            interval: 15e3,
            showThumbs: false,
            children: renderItems()
          }, void 0, false, {
            fileName: "app/components/banner/lunchBanner.jsx",
            lineNumber: 88,
            columnNumber: 11
          }, this)
        ]
      }, void 0, true, {
        fileName: "app/components/banner/lunchBanner.jsx",
        lineNumber: 82,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: "app/components/banner/lunchBanner.jsx",
      lineNumber: 75,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: "app/components/banner/lunchBanner.jsx",
    lineNumber: 74,
    columnNumber: 5
  }, this);
}
var lunchBanner_default = LunchBanner;

// app/routes/index.jsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function meta() {
  return { title: "Dashboard" };
}
function IndexPage() {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w;
  const loaderData = useLoaderData();
  const [datas, setDatas] = import_react11.default.useState(loaderData);
  const LocationId = datas == null ? void 0 : datas.locationId;
  const DateFormat = "yyyy-MM-dd";
  const directus = directusLoaderLink;
  const [currentMonth, setCurrentMonth] = (0, import_react9.useState)(new Date());
  const [currentWeek, setCurrentWeek] = (0, import_react9.useState)(getWeek(currentMonth));
  const [selectedDate, setSelectedDate] = (0, import_react9.useState)(new Date());
  const [loading, setLoading] = (0, import_react9.useState)(false);
  const [currentBanner, setCurrentBanner] = (0, import_react9.useState)();
  const [menucurrentBanner, setMenuCurrentBanner] = (0, import_react9.useState)();
  const [allergens, setAllergens] = (0, import_react9.useState)();
  const [modalStationOpen, setModalStationOpen] = (0, import_react9.useState)(false);
  const [menuModalIsOpen, setMenuIsOpen] = (0, import_react9.useState)(false);
  const [stationDetail, setStationDetail] = (0, import_react9.useState)("");
  const [refresh, setRefresh] = (0, import_react9.useState)(true);
  const [preventDouble, setPreventDouble] = (0, import_react9.useState)(false);
  const [preventDouble1, setPreventDouble1] = (0, import_react9.useState)(false);
  const [tableDataModelOpen, setTableDataModel] = (0, import_react9.useState)(false);
  const [tableData, setTableData] = (0, import_react9.useState)("");
  const [tableDataPreviewModelOpen, setTableDataPreviewModel] = (0, import_react9.useState)(false);
  const [tablePreviewData, setTablePreviewData] = (0, import_react9.useState)("");
  const [copyMealClickIndex, setCopyMealClickIndex] = (0, import_react9.useState)("");
  var renderStations = [];
  let stationCount = 0;
  (_a = datas.res) == null ? void 0 : _a.map(
    (e) => (e == null ? void 0 : e.is_not_main_station) !== true ? stationCount += 1 : null
  );
  (0, import_react9.useEffect)(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    const LastWacthedWeek = localStorage.getItem("LastWacthedWeek");
    const isUserExist = localStorage.getItem("isUserExist");
    if (!isUserExist) {
      Q.success("You are successfully logged in");
      localStorage.setItem("isUserExist", true);
    }
    if (LastWacthedWeek) {
      try {
        setCurrentMonth(new Date(LastWacthedWeek));
        setCurrentWeek(getWeek(new Date(LastWacthedWeek)));
        setSelectedDate(new Date(LastWacthedWeek));
        datafetch({ date: new Date(LastWacthedWeek) });
        localStorage.removeItem("LastWacthedWeek");
      } catch (err) {
        console.log(err);
      }
    }
    const lastLocation = ((_a2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _a2.selected_locations) !== null ? (_b2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _b2.selected_locations : (_c2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _c2.allowed_locations[0].Locations_id;
    localStorage.setItem("admin", (_d2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _d2.is_admin);
    localStorage.setItem("conference", (_e2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _e2.conference);
    localStorage.setItem("activity", (_f2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _f2.activity);
    localStorage.setItem("spa", (_g2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _g2.spa);
    localStorage.setItem("selectedLocation", JSON.stringify(lastLocation));
    localStorage.setItem("showDietary", JSON.stringify((_h2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _h2.show_dietary));
  }, [refresh, tableDataModelOpen === false]);
  const pickerRef = (0, import_react9.useRef)();
  const showLoader = () => {
    setLoading(true);
    setTimeout(() => {
      setLoading(false);
    }, 2500);
  };
  const Urldate = (prop) => {
    var d = prop.getDate();
    var m = prop.getMonth() + 1;
    var y = prop.getFullYear();
    const date = y + "-" + (m <= 9 ? "0" + m : m) + "-" + (d <= 9 ? "0" + d : d);
    return date;
  };
  const datafetch = async (prop) => {
    var _a2;
    const startDate = format(startOfWeek(prop == null ? void 0 : prop.date, { weekStartsOn: 1 }), DateFormat);
    const endDate = format(startOfWeek(addDays(prop == null ? void 0 : prop.date, 7), { weekStartsOn: 0 }), DateFormat);
    const year = getYear(prop == null ? void 0 : prop.date);
    const yearEnd = format(endOfYear(new Date(year, 11, 31)), DateFormat);
    const foodWasteReload = localStorage.getItem("foodWasteReload");
    const NotCurrentYear = true;
    let graphPoints = [];
    let Annual_Plate_waste = 0;
    let Annual_Total_waste = 0;
    const presentWeek = getWeek(new Date(prop == null ? void 0 : prop.date));
    if (NotCurrentYear) {
      localStorage.removeItem("foodWasteReload");
    }
    const filterBody = ((_a2 = datas == null ? void 0 : datas.allowedStationUniqueId) == null ? void 0 : _a2.length) > 0 ? {
      is_not_main_station: { _neq: true },
      station_unique_id: { _in: datas == null ? void 0 : datas.allowedStationUniqueId }
    } : { is_not_main_station: { _neq: true } };
    await directus.items("Stations").readByQuery({
      fields: [
        "*.*.*",
        "child_list.related_Stations_id.screen_display_info.*",
        "child_list.related_Stations_id.screen_display_info.station_name.*",
        "child_list.related_Stations_id.screen_display_info.recipe_id.*.*.*",
        "screen_display_info.recipe_id.allergens_list.Allergens_id.*",
        "screen_display_info.recipe_id.dietary_list.Dietary_id.*",
        "screen_display_info.station_name.station_image_1.*.*",
        "screen_display_info.station_name.station_image_2.*.*"
      ],
      filter: filterBody,
      deep: {
        child_list: {
          related_Stations_id: {
            screen_display_info: {
              _filter: {
                date: { _between: [startDate, endDate] }
              }
            }
          }
        },
        screen_display_info: {
          _filter: {
            date: { _between: [startDate, endDate] }
          }
        }
      }
    }).then((e) => {
      setDatas((prev) => {
        var _a3;
        return {
          res: (_a3 = e == null ? void 0 : e.data) == null ? void 0 : _a3.sort((a, b) => parseFloat(a == null ? void 0 : a.sequence) - parseFloat(b == null ? void 0 : b.sequence)),
          locationId: LocationId,
          currentUser: datas == null ? void 0 : datas.currentUser,
          getAllStations: datas == null ? void 0 : datas.getAllStations,
          allowedStationUniqueId: datas == null ? void 0 : datas.allowedStationUniqueId
        };
      });
    }).catch((e) => console.log(e));
  };
  const changeWeekHandle = async (btnType) => {
    showLoader();
    if (btnType === "prev") {
      await datafetch({ date: subWeeks(currentMonth, 1) });
      setCurrentMonth(subWeeks(currentMonth, 1));
      setCurrentWeek(getWeek(subWeeks(currentMonth, 1)));
    }
    if (btnType === "next") {
      await datafetch({ date: addWeeks(currentMonth, 1) });
      setCurrentMonth(addWeeks(currentMonth, 1));
      setCurrentWeek(getWeek(addWeeks(currentMonth, 1)));
    }
  };
  const RenderDays = () => {
    const dateFormat = "EEEE";
    const days = [];
    let startDate = startOfWeek(currentMonth, { weekStartsOn: 1 });
    for (let i2 = 0; i2 < 7; i2++) {
      days.push(
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: `col col-center  ${i2 !== 6 ? "border-r" : null} bordersky  border-[#C2C2C2] border-collapse p-2 min-w-[110px] table-head`,
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: `col col-center text-sm font-bold text-black`,
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "flex justify-between flex-row px-1 align-middle day-options text-white relative",
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: "day text-xs",
                  children: format(addDays(startDate, i2), dateFormat)
                }, void 0, false, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 409,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: "flex gap-1 text-white bg-sky-200/75 px-0.5 rounded-md absolute right-[-8px] top-[-2px]",
                  children: [
                    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(NavLink, {
                      to: `/edit-menu-of-the-day/${format(
                        addDays(startDate, i2),
                        DateFormat
                      )}`,
                      children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                        className: "cursor-pointer ri-pencil-line"
                      }, void 0, false, {
                        fileName: "app/routes/index.jsx",
                        lineNumber: 419,
                        columnNumber: 19
                      }, this)
                    }, void 0, false, {
                      fileName: "app/routes/index.jsx",
                      lineNumber: 413,
                      columnNumber: 17
                    }, this),
                    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                      className: "relative font-normal px-0.5",
                      onClick: () => todayMenu(format(addDays(startDate, i2), "yyyy-MM-dd")),
                      children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                        className: "cursor-pointer ri-eye-line ri-1x"
                      }, void 0, false, {
                        fileName: "app/routes/index.jsx",
                        lineNumber: 422,
                        columnNumber: 17
                      }, this)
                    }, void 0, false, {
                      fileName: "app/routes/index.jsx",
                      lineNumber: 421,
                      columnNumber: 17
                    }, this),
                    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                      className: "relative font-normal",
                      children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(clickOutsideDiv_default, {
                        setRefresh,
                        refresh,
                        Id: i2,
                        startDate: addDays(startDate, i2),
                        locationId: LocationId,
                        type: "station"
                      }, i2, false, {
                        fileName: "app/routes/index.jsx",
                        lineNumber: 425,
                        columnNumber: 17
                      }, this)
                    }, void 0, false, {
                      fileName: "app/routes/index.jsx",
                      lineNumber: 424,
                      columnNumber: 17
                    }, this)
                  ]
                }, void 0, true, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 412,
                  columnNumber: 15
                }, this)
              ]
            }, void 0, true, {
              fileName: "app/routes/index.jsx",
              lineNumber: 408,
              columnNumber: 13
            }, this)
          }, void 0, false, {
            fileName: "app/routes/index.jsx",
            lineNumber: 407,
            columnNumber: 11
          }, this)
        }, i2, false, {
          fileName: "app/routes/index.jsx",
          lineNumber: 402,
          columnNumber: 9
        }, this)
      );
    }
    days.unshift(
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
        className: `col col-center border-r bordersky border-[#C2C2C2] border-collapse p-2 min-w-[110px] table-head`,
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: `col col-center text-sm font-bold text-black`,
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: "flex justify-between flex-row px-1 align-middle",
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: " text-white",
              children: "Station"
            }, void 0, false, {
              fileName: "app/routes/index.jsx",
              lineNumber: 440,
              columnNumber: 13
            }, this)
          }, void 0, false, {
            fileName: "app/routes/index.jsx",
            lineNumber: 439,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: "app/routes/index.jsx",
          lineNumber: 438,
          columnNumber: 9
        }, this)
      }, 10, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 434,
        columnNumber: 7
      }, this)
    );
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
      className: "days row",
      children: days
    }, void 0, false, {
      fileName: "app/routes/index.jsx",
      lineNumber: 445,
      columnNumber: 12
    }, this);
  };
  const todayMenu = (prop) => {
    var _a2, _b2;
    setMenuCurrentBanner((_b2 = (_a2 = datas == null ? void 0 : datas.res) == null ? void 0 : _a2.map((e) => {
      var _a3;
      return (_a3 = e == null ? void 0 : e.screen_display_info) == null ? void 0 : _a3.find((re) => (re == null ? void 0 : re.date) === prop);
    })) == null ? void 0 : _b2.filter((e) => e == null ? void 0 : e.id));
    setMenuIsOpen(true);
  };
  const RenderSubStations = ({ date, ChildIds, childList }) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    const dayData = childList == null ? void 0 : childList.map((subStation) => {
      var _a3, _b3;
      var listData = (_b3 = (_a3 = subStation == null ? void 0 : subStation.related_Stations_id) == null ? void 0 : _a3.screen_display_info) == null ? void 0 : _b3.filter(
        (info) => {
          var _a4, _b4;
          return (info == null ? void 0 : info.date) == date && (info == null ? void 0 : info.location_id) == ((_b4 = (_a4 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _a4.selected_locations) == null ? void 0 : _b4.id);
        }
      );
      return listData[0];
    });
    const titleCheck = (_c2 = (_b2 = (_a2 = childList[0]) == null ? void 0 : _a2.Stations_id) == null ? void 0 : _b2.station_name_translation) == null ? void 0 : _c2.filter((e) => (e == null ? void 0 : e.location_id) == LocationId);
    const ParentStationName = ((_e2 = (_d2 = titleCheck == null ? void 0 : titleCheck[0]) == null ? void 0 : _d2.name) == null ? void 0 : _e2.length) > 0 ? (_f2 = titleCheck == null ? void 0 : titleCheck[0]) == null ? void 0 : _f2.name : (_h2 = (_g2 = childList[0]) == null ? void 0 : _g2.Stations_id) == null ? void 0 : _h2.station_name;
    const menu = getStationDetails1(dayData);
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
      className: "px-2",
      children: menu == null ? void 0 : menu.map((content, index2) => {
        var _a3, _b3, _c3, _d3, _e3, _f3, _g3, _h3;
        return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: `relative${index2 === (copyMealClickIndex == null ? void 0 : copyMealClickIndex.key) ? " active" : ""}`,
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "absolute right-0 z-10 top-[3px]",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(cellCopy_default, {
                station: {
                  stationId: (_b3 = (_a3 = childList[index2]) == null ? void 0 : _a3.related_Stations_id) == null ? void 0 : _b3.id,
                  stationUniqueId: (_d3 = (_c3 = childList[index2]) == null ? void 0 : _c3.related_Stations_id) == null ? void 0 : _d3.station_unique_id,
                  locationId: LocationId,
                  date,
                  contentId: content == null ? void 0 : content.id,
                  menuInfo: content == null ? void 0 : content.menuInfo,
                  menuInfo1: content == null ? void 0 : content.menuInfo1,
                  allergens: content == null ? void 0 : content.allergens,
                  dietary: content == null ? void 0 : content.dietaryList,
                  updateId: content == null ? void 0 : content.recipeId,
                  stationName: `${ParentStationName} - ${(_f3 = (_e3 = childList[index2]) == null ? void 0 : _e3.related_Stations_id) == null ? void 0 : _f3.station_name}`,
                  plateImg: content == null ? void 0 : content.plateImg,
                  RecipePlateImg: content == null ? void 0 : content.RecipePlateImg,
                  co2: content == null ? void 0 : content.co2,
                  calorie: content == null ? void 0 : content.calorie
                },
                setRefresh,
                refresh,
                Loader: showLoader,
                childIndex: index2,
                copyMealClickIndex,
                CopyMealClickIndex: setCopyMealClickIndex,
                isAdminUser: (_g3 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _g3.is_admin
              }, void 0, false, {
                fileName: "app/routes/index.jsx",
                lineNumber: 471,
                columnNumber: 12
              }, this)
            }, void 0, false, {
              fileName: "app/routes/index.jsx",
              lineNumber: 470,
              columnNumber: 12
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {
              className: `relative tasksname p-2 pl-0 pr-0 text-left border-b-2 font-bold bordersky${(content == null ? void 0 : content.menuInfo) == void 0 || ((_h3 = content == null ? void 0 : content.menuInfo) == null ? void 0 : _h3.length) == 0 ? " no-data" : ""} ${(menu == null ? void 0 : menu.length) == index2 + 1 ? " border-b-transparent" : " border-b border-[#C2C2C2]"}`,
              children: !!(content == null ? void 0 : content.menuInfo) ? content == null ? void 0 : content.menuInfo : "Add meal..."
            }, void 0, false, {
              fileName: "app/routes/index.jsx",
              lineNumber: 492,
              columnNumber: 10
            }, this)
          ]
        }, index2, true, {
          fileName: "app/routes/index.jsx",
          lineNumber: 469,
          columnNumber: 17
        }, this);
      })
    }, void 0, false, {
      fileName: "app/routes/index.jsx",
      lineNumber: 467,
      columnNumber: 7
    }, this);
  };
  const getStationDetails1 = (prop) => {
    const val = prop == null ? void 0 : prop.map((e) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2;
      return {
        id: e == null ? void 0 : e.id,
        date: e == null ? void 0 : e.date,
        menuInfo: (_a2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _a2.menu_info,
        menuInfo1: (_b2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _b2.menu_info_1,
        allergens: (_c2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _c2.allergens_list,
        dietaryList: (_d2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _d2.dietary_list,
        stationUniqueId: (_e2 = e == null ? void 0 : e.station_name) == null ? void 0 : _e2.station_unique_id,
        stationName: (_f2 = e == null ? void 0 : e.station_name) == null ? void 0 : _f2.station_name,
        stationImage: (_h2 = (_g2 = e == null ? void 0 : e.station_name) == null ? void 0 : _g2.station_image_1) == null ? void 0 : _h2.id,
        plateImg: e == null ? void 0 : e.app_resultant_image,
        RecipePlateImg: (_i2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _i2.app_resultant_image,
        recipeId: (_j2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _j2.id,
        location_id: (_k2 = e == null ? void 0 : e.location_id) == null ? void 0 : _k2.id,
        calorie: (_l2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _l2.total_calories,
        co2: (_m2 = e == null ? void 0 : e.recipe_id) == null ? void 0 : _m2.total_co2
      };
    });
    return val;
  };
  const filteredDateContentValues = ({ arraydate, cloneDay }) => {
    var _a2;
    const value = (_a2 = arraydate == null ? void 0 : arraydate.filter((item) => item.date == Urldate(cloneDay))) == null ? void 0 : _a2.filter((location2) => {
      var _a3, _b2;
      return (location2 == null ? void 0 : location2.location_id) == ((_b2 = (_a3 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _a3.selected_locations) == null ? void 0 : _b2.id);
    });
    return value[0];
  };
  const renderCells = (props) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2;
    const startDate = startOfWeek(currentMonth, { weekStartsOn: 1 });
    var endDate = lastDayOfWeek(currentMonth, { weekStartsOn: 6 });
    const rows = [];
    let days = [];
    let day = startDate;
    var colorCode = (_a2 = datas == null ? void 0 : datas.res) == null ? void 0 : _a2.map((e) => e.tagColor);
    renderStations = [];
    while (day < endDate) {
      for (let i2 = 0; i2 < 7; i2++) {
        const cloneDay = day;
        let arrayDate = getStationDetails1((_b2 = props == null ? void 0 : props.content) == null ? void 0 : _b2.screen_display_info);
        const menu = filteredDateContentValues({
          arraydate: arrayDate,
          cloneDay
        });
        const ChildIds = ((_c2 = PARENT_STATION_IDS) == null ? void 0 : _c2.includes(Number(props == null ? void 0 : props.stationUniqueID))) && ((_f2 = (_e2 = (_d2 = datas == null ? void 0 : datas.getAllStations) == null ? void 0 : _d2.find((e) => (e == null ? void 0 : e.station_unique_id) == (props == null ? void 0 : props.stationUniqueID))) == null ? void 0 : _e2.child_list) == null ? void 0 : _f2.map((e) => {
          var _a3;
          return (_a3 = e == null ? void 0 : e.related_Stations_id) == null ? void 0 : _a3.station_unique_id;
        }));
        const station = {
          stationId: props == null ? void 0 : props.stationID,
          stationUniqueId: props == null ? void 0 : props.stationUniqueID,
          stationName: props == null ? void 0 : props.stationName,
          stationImage: menu == null ? void 0 : menu.stationImage,
          plateImg: menu == null ? void 0 : menu.plateImg,
          RecipePlateImg: menu == null ? void 0 : menu.RecipePlateImg,
          locationId: LocationId,
          date: Urldate(cloneDay),
          contentId: menu == null ? void 0 : menu.id,
          menuInfo: menu == null ? void 0 : menu.menuInfo,
          menuInfo1: menu == null ? void 0 : menu.menuInfo1,
          allergens: menu == null ? void 0 : menu.allergens,
          dietary: menu == null ? void 0 : menu.dietaryList,
          updateId: menu == null ? void 0 : menu.recipeId,
          co2: menu == null ? void 0 : menu.co2,
          calorie: menu == null ? void 0 : menu.calorie
        };
        if (((_g2 = menu == null ? void 0 : menu.menuInfo) == null ? void 0 : _g2.length) || (ChildIds == null ? void 0 : ChildIds.length) > 0) {
          days.push(
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: `col cell border-r   border-b bordersky border-[#C2C2C2]... border-collapse`,
              children: [
                ((_i2 = (_h2 = props == null ? void 0 : props.content) == null ? void 0 : _h2.child_list) == null ? void 0 : _i2.length) == 0 ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {
                  className: `tasksname pt-[20px] p-2 text-left font-bold ${((_j2 = menu == null ? void 0 : menu.menuInfo) == null ? void 0 : _j2.length) == 0 ? "no-data" : ""}`,
                  children: ((_k2 = menu == null ? void 0 : menu.menuInfo) == null ? void 0 : _k2.length) > 0 ? menu == null ? void 0 : menu.menuInfo : "Add meal..."
                }, void 0, false, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 579,
                  columnNumber: 17
                }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(RenderSubStations, {
                  childList: (_l2 = props == null ? void 0 : props.content) == null ? void 0 : _l2.child_list,
                  date: Urldate(cloneDay),
                  ChildIds
                }, void 0, false, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 583,
                  columnNumber: 17
                }, this),
                !((_m2 = PARENT_STATION_IDS) == null ? void 0 : _m2.includes(Number(props == null ? void 0 : props.stationUniqueID))) && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: "absolute right-0 top-[16px]",
                  children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(cellCopy_default, {
                    station,
                    setRefresh,
                    refresh,
                    Loader: showLoader,
                    isAdminUser: (_n2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _n2.is_admin
                  }, void 0, false, {
                    fileName: "app/routes/index.jsx",
                    lineNumber: 591,
                    columnNumber: 19
                  }, this)
                }, void 0, false, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 590,
                  columnNumber: 17
                }, this)
              ]
            }, Math.random(), true, {
              fileName: "app/routes/index.jsx",
              lineNumber: 572,
              columnNumber: 13
            }, this)
          );
        } else {
          days.push(
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: `relative col cell border-r  border-b bordersky border-[#C2C2C2]... border-collapse`,
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_jsx_dev_runtime.Fragment, {
                children: [
                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {
                    className: "tasksname pt-[20px] p-2 text-left font-bold no-data",
                    children: [
                      " ",
                      "Add meal..."
                    ]
                  }, void 0, true, {
                    fileName: "app/routes/index.jsx",
                    lineNumber: 606,
                    columnNumber: 17
                  }, this),
                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                    className: "absolute right-0 top-[16px]",
                    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(cellCopy_default, {
                      station,
                      setRefresh,
                      refresh,
                      Loader: showLoader,
                      isAdminUser: (_o2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _o2.is_admin
                    }, void 0, false, {
                      fileName: "app/routes/index.jsx",
                      lineNumber: 608,
                      columnNumber: 17
                    }, this)
                  }, void 0, false, {
                    fileName: "app/routes/index.jsx",
                    lineNumber: 607,
                    columnNumber: 17
                  }, this)
                ]
              }, void 0, true, {
                fileName: "app/routes/index.jsx",
                lineNumber: 605,
                columnNumber: 15
              }, this)
            }, Math.random(), false, {
              fileName: "app/routes/index.jsx",
              lineNumber: 599,
              columnNumber: 13
            }, this)
          );
        }
        day = addDays(day, 1);
      }
      if (renderStations.indexOf(props == null ? void 0 : props.stationName) < 0) {
        renderStations.push(props == null ? void 0 : props.stationName);
        days.unshift(
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: `${`col cell border-r   border-b bordersky border-[#C2C2C2]... border-collapse`}`,
            style: { backgroundColor: colorCode[i] + "20" },
            onClick: () => {
            },
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "task-list",
              style: {
                borderLeftColor: colorCode[i],
                borderLeftWidth: "6px",
                height: "100%"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                  className: "number",
                  children: props == null ? void 0 : props.title
                }, void 0, false, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 638,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {
                  className: "tasksname p-2 text-left pl-[12px] uppercase",
                  children: [
                    props == null ? void 0 : props.stationName,
                    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                      onClick: () => {
                        var _a3, _b3;
                        return handleStationModel({ statonName: props == null ? void 0 : props.stationName, StationUniqueId: (_a3 = props == null ? void 0 : props.content) == null ? void 0 : _a3.station_unique_id, StationId: (_b3 = props == null ? void 0 : props.content) == null ? void 0 : _b3.id });
                      },
                      children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                        className: "cursor-pointer ri-pencil-line ml-[3px]"
                      }, void 0, false, {
                        fileName: "app/routes/index.jsx",
                        lineNumber: 642,
                        columnNumber: 15
                      }, this)
                    }, void 0, false, {
                      fileName: "app/routes/index.jsx",
                      lineNumber: 639,
                      columnNumber: 95
                    }, this)
                  ]
                }, void 0, true, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 639,
                  columnNumber: 15
                }, this)
              ]
            }, void 0, true, {
              fileName: "app/routes/index.jsx",
              lineNumber: 630,
              columnNumber: 13
            }, this)
          }, Math.random(), false, {
            fileName: "app/routes/index.jsx",
            lineNumber: 620,
            columnNumber: 11
          }, this)
        );
        rows.push(
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: "row",
            children: days
          }, Math.random(), false, {
            fileName: "app/routes/index.jsx",
            lineNumber: 649,
            columnNumber: 11
          }, this)
        );
        days = [];
      }
    }
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
      className: "row1",
      children: rows
    }, Math.random(), false, {
      fileName: "app/routes/index.jsx",
      lineNumber: 658,
      columnNumber: 7
    }, this);
  };
  const foodWasteCall = async (prop) => {
    const foodWaste = await directus.items("Food_waste_information").readByQuery({
      fields: ["date", "food_waste", "number_of_users", "total_waste", "id", "location_id"],
      sort: "date",
      filter: {
        location_id: { _eq: LocationId },
        date: { _between: [addDays(new Date(prop), 1), addDays(new Date(prop), 5)] }
      }
    }).then((e) => e == null ? void 0 : e.data).catch((e) => console.log(e, "err"));
    return foodWaste;
  };
  const tableDataHandle = async (prop) => {
    const foodWaste = await foodWasteCall(prop == null ? void 0 : prop.startDate);
    setTableData({ data: prop, foodWaste });
    setTableDataModel(!tableDataModelOpen);
    localStorage.setItem("LastWacthedWeek", prop == null ? void 0 : prop.startDate);
  };
  const tableDataPreviewHandle = (prop) => {
    var _a2;
    setTablePreviewData({
      graphPoints: datas == null ? void 0 : datas.graphPoints,
      AnnualWaste: datas == null ? void 0 : datas.AnnualWaste,
      LocationId,
      isAdminuser: (_a2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _a2.is_admin,
      year: prop == null ? void 0 : prop.year
    });
    setTableDataPreviewModel(!tableDataPreviewModelOpen);
  };
  function handleMonth(pickedMonth) {
    var _a2;
    (_a2 = pickerRef.current) == null ? void 0 : _a2.dismiss();
  }
  async function updatedYear(updated) {
    var _a2, _b2;
    showLoader();
    var selectedISODate = "";
    selectedISODate = new Date(updated.year, updated.month - 1, 1);
    if (((_a2 = new Date(updated.year, updated.month - 1, 1)) == null ? void 0 : _a2.getDay()) == 0) {
      selectedISODate = new Date(updated.year, updated.month - 1, 2);
    }
    if (((_b2 = new Date(updated.year, updated.month - 1, 1)) == null ? void 0 : _b2.getDay()) == 6) {
      selectedISODate = new Date(updated.year, updated.month - 1, 3);
    }
    setSelectedDate(selectedDate);
    setCurrentMonth(selectedISODate);
    setCurrentWeek(getWeek(selectedISODate));
    await datafetch({ date: selectedISODate });
  }
  const renderHeader = () => {
    var _a2, _b2;
    const pickerLang = {
      months: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      from: "From",
      to: "To"
    };
    var dateFormat = "dd";
    const startDate = startOfWeek(currentMonth, { weekStartsOn: 1 }, { days: 7 });
    const Week_start_end = `${currentWeek == getWeek(new Date()) && (currentMonth == null ? void 0 : currentMonth.getFullYear()) == ((_a2 = new Date()) == null ? void 0 : _a2.getFullYear()) ? "This week /" : ""} ${format(startDate, dateFormat)} th ${pickerLang.months[startDate.getMonth()]} - ${format(addDays(startDate, 6), dateFormat)} th ${pickerLang.months[(_b2 = addDays(startDate, 6)) == null ? void 0 : _b2.getMonth()]}`;
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
      className: "header row justify-between",
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "col",
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: "icon cursor-pointer",
            onClick: () => changeWeekHandle("prev"),
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                className: "ri-arrow-left-line ri-1x  "
              }, void 0, false, {
                fileName: "app/routes/index.jsx",
                lineNumber: 747,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                className: "font-nunito font-medium",
                children: "Previous Week"
              }, void 0, false, {
                fileName: "app/routes/index.jsx",
                lineNumber: 748,
                columnNumber: 13
              }, this)
            ]
          }, void 0, true, {
            fileName: "app/routes/index.jsx",
            lineNumber: 743,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: "app/routes/index.jsx",
          lineNumber: 742,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "flex flex-col mobile-full",
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "flex flex-row custom-date",
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: "mr-2",
                  children: [
                    pickerLang.months[currentMonth.getMonth()],
                    ",",
                    " ",
                    currentMonth.getFullYear()
                  ]
                }, void 0, true, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 753,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                  className: "edit cursor-pointer",
                  children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react_month_picker.default, {
                    ref: pickerRef,
                    years: {
                      min: { year: new Date().getFullYear() - 40 },
                      max: { year: new Date().getFullYear() + 40 }
                    },
                    value: {
                      year: new Date().getFullYear(),
                      month: new Date().getMonth() + 1
                    },
                    lang: pickerLang.months,
                    onChange: handleMonth,
                    onDismiss: updatedYear,
                    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                      onClick: () => pickerRef.current.show(),
                      className: "ri-edit-fill"
                    }, void 0, false, {
                      fileName: "app/routes/index.jsx",
                      lineNumber: 772,
                      columnNumber: 17
                    }, this)
                  }, void 0, false, {
                    fileName: "app/routes/index.jsx",
                    lineNumber: 758,
                    columnNumber: 15
                  }, this)
                }, void 0, false, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 757,
                  columnNumber: 13
                }, this)
              ]
            }, void 0, true, {
              fileName: "app/routes/index.jsx",
              lineNumber: 752,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "px-3 font-normal text-center text-base week",
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                  className: "font-medium",
                  children: "The Food Place"
                }, void 0, false, {
                  fileName: "app/routes/index.jsx",
                  lineNumber: 780,
                  columnNumber: 13
                }, this),
                " / Week ",
                currentWeek
              ]
            }, void 0, true, {
              fileName: "app/routes/index.jsx",
              lineNumber: 779,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
              className: "px-3 mt-2 font-normal text-center this-week",
              children: Week_start_end
            }, void 0, false, {
              fileName: "app/routes/index.jsx",
              lineNumber: 782,
              columnNumber: 11
            }, this)
          ]
        }, void 0, true, {
          fileName: "app/routes/index.jsx",
          lineNumber: 751,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "col col-end flex flex-col justify-between items-end",
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: "icon cursor-pointer",
            onClick: () => changeWeekHandle("next"),
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                className: "font-nunito font-medium",
                children: "Next Week"
              }, void 0, false, {
                fileName: "app/routes/index.jsx",
                lineNumber: 791,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                className: "ri-arrow-right-line ri-1x ml-1 "
              }, void 0, false, {
                fileName: "app/routes/index.jsx",
                lineNumber: 792,
                columnNumber: 13
              }, this)
            ]
          }, void 0, true, {
            fileName: "app/routes/index.jsx",
            lineNumber: 787,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: "app/routes/index.jsx",
          lineNumber: 786,
          columnNumber: 9
        }, this)
      ]
    }, void 0, true, {
      fileName: "app/routes/index.jsx",
      lineNumber: 741,
      columnNumber: 7
    }, this);
  };
  const handleStationModel = (prop) => {
    setStationDetail({ stationName: prop, locationId: datas == null ? void 0 : datas.locationId });
    setModalStationOpen(true);
  };
  var stations = [];
  var j = 0;
  for (var i = 0; i < stationCount; i++) {
    var findExistDataIndex = (_d = (_b = datas.getAllStations) == null ? void 0 : _b.map((e) => e == null ? void 0 : e.id)) == null ? void 0 : _d.indexOf((_c = datas.getAllStations[i]) == null ? void 0 : _c.id);
    if (findExistDataIndex == -1) {
      stations.push(
        renderCells({
          title: `STATION ${i + 1}`,
          stationName: (_e = datas.res[i]) == null ? void 0 : _e.station_name,
          content: {},
          index: i,
          stationUniqueID: (_f = datas.res[i]) == null ? void 0 : _f.station_unique_id
        })
      );
    } else {
      const presentStations = (_i = (_h = (_g = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _g.selected_locations) == null ? void 0 : _h.allowed_stations) == null ? void 0 : _i.map((e) => {
        var _a2;
        return (_a2 = e == null ? void 0 : e.Stations_id) == null ? void 0 : _a2.station_unique_id;
      });
      const stationnameCheck = (_k = (_j = datas.res[i]) == null ? void 0 : _j.station_name_translation) == null ? void 0 : _k.filter((e) => (e == null ? void 0 : e.location_id) == (datas == null ? void 0 : datas.locationId));
      if (((_l = presentStations == null ? void 0 : presentStations.filter((e) => {
        var _a2;
        return e === ((_a2 = datas == null ? void 0 : datas.res[i]) == null ? void 0 : _a2.station_unique_id);
      })) == null ? void 0 : _l[0]) ? true : false) {
        stations.push(
          renderCells({
            title: `STATION ${i + 1}`,
            stationName: ((_n = (_m = stationnameCheck == null ? void 0 : stationnameCheck[0]) == null ? void 0 : _m.name) == null ? void 0 : _n.length) ? (_o = stationnameCheck == null ? void 0 : stationnameCheck[0]) == null ? void 0 : _o.name : (_p = datas.res[i]) == null ? void 0 : _p.station_name,
            stationUniqueID: (_q = datas.res[i]) == null ? void 0 : _q.station_unique_id,
            stationID: (_r = datas.res[i]) == null ? void 0 : _r.id,
            plateImg: (_s = datas.res[i]) == null ? void 0 : _s.app_resultant_image,
            content: datas.res[j],
            index: i,
            extraDressingData: ((_t = datas.getAllStations[i]) == null ? void 0 : _t.station_name) == "Harvest Salads" ? [datas.res[j + 1], datas.res[j + 2]] : null
          })
        );
      }
      j++;
    }
  }
  const updateUserProperties = async (newLocationId) => {
    var _a2;
    const directus2 = directusLoaderLink;
    await directus2.users.updateOne((_a2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _a2.id, {
      selected_locations: { id: newLocationId }
    }).then((res) => {
      Q.success("Updated successfully");
      setLoading(true);
      setTimeout(() => {
        window.location.reload(true);
      }, 1700);
    }).catch((err) => {
      Q.error("Something went wrong");
    });
  };
  const Print = () => {
    let printContents = document.getElementById("printContent").innerHTML;
    let originalContents = document.body.innerHTML;
    document.body.innerHTML = printContents;
    window.print();
    document.body.innerHTML = originalContents;
    window.location.reload();
  };
  const CopyLink = () => {
    var _a2;
    (_a2 = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _a2.writeText(`${FRONTEND_URL}/banner/weekmenu/${LocationId}`);
    Q.success("Link copied to clipboard!");
  };
  const clearCache = async () => {
    setPreventDouble(true);
    var files = [
      `${FRONTEND_URL}/`
    ];
    const msg = {
      "files": {
        "files": files
      }
    };
    await fetch(PURGE_CACHE_URL, {
      method: "POST",
      mode: "cors",
      cache: "no-cache",
      credentials: "same-origin",
      headers: {
        "Content-Type": "application/json"
      },
      redirect: "follow",
      referrerPolicy: "no-referrer",
      body: JSON.stringify(msg)
    }).then(
      (e) => Q.success("Cache clear triggered successfuly. Reload the page after 30 seconds", {
        onClose: () => setPreventDouble(false)
      })
    ).catch((e) => Q.error("Try again later", {
      onClose: () => setPreventDouble(false)
    }));
  };
  const clearScreencloudCache = async () => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    setPreventDouble1(true);
    if (((_c2 = (_b2 = (_a2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _a2.selected_locations) == null ? void 0 : _b2.screen_ids) == null ? void 0 : _c2.length) > 0) {
      const arrayOfScreenIds = (_f2 = (_e2 = (_d2 = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _d2.selected_locations) == null ? void 0 : _e2.screen_ids) == null ? void 0 : _f2.split(",");
      await fetch(SCREENCLOUD_CACHE_CLEAR_API_URL, {
        method: "POST",
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json"
        },
        redirect: "follow",
        referrerPolicy: "no-referrer",
        body: JSON.stringify(arrayOfScreenIds)
      }).then((response) => {
        var _a3;
        (_a3 = response == null ? void 0 : response.json()) == null ? void 0 : _a3.then((json) => {
          Q.success(json == null ? void 0 : json.output, {
            onClose: () => setPreventDouble1(false)
          });
        });
      }).catch((e) => {
        Q.error("Something went wrong! Try again later", {
          onClose: () => setPreventDouble1(false)
        });
      });
    } else {
      Q.error("Please configure the screenID for this location to clear cache.", {
        onClose: () => setPreventDouble1(false)
      });
    }
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react11.default.Fragment, {
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(HeaderFile, {
        title: true,
        logout: true,
        current: datas == null ? void 0 : datas.currentUser,
        location: datas == null ? void 0 : datas.currentUser,
        changeLocation: updateUserProperties,
        noLeftLogo: ((_u = ISS_DENMARK_HQ) == null ? void 0 : _u.includes(LocationId)) ? true : false
      }, void 0, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 978,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
        className: "main-content-area",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          className: "justify-center items-center px-5 py-4 lg:px-10 p-10 pt-12",
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
            className: "items-right ",
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                className: "pb-7  items-center lg:px-1",
                children: renderHeader()
              }, void 0, false, {
                fileName: "app/routes/index.jsx",
                lineNumber: 989,
                columnNumber: 13
              }, this),
              loading ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Loader, {}, void 0, false, {
                fileName: "app/routes/index.jsx",
                lineNumber: 991,
                columnNumber: 15
              }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react11.default.Fragment, {
                children: [
                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                    className: "calendar rounded-md border-gray-500 ... border-collapse overflow-hidden",
                    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                      id: "printContent",
                      children: [
                        RenderDays(),
                        stations
                      ]
                    }, void 0, true, {
                      fileName: "app/routes/index.jsx",
                      lineNumber: 995,
                      columnNumber: 19
                    }, this)
                  }, void 0, false, {
                    fileName: "app/routes/index.jsx",
                    lineNumber: 994,
                    columnNumber: 17
                  }, this),
                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                    className: "flex items-center justify-between print-copy",
                    children: [
                      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                        className: "row-content flex justify-start items-center my-5 flex-wrap gap-5 print-list",
                        children: [
                          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                            className: "text-black font-medium text-xs inline-flex",
                            children: [
                              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("svg", {
                                viewBox: "0 0 24 24",
                                width: "16",
                                height: "16",
                                stroke: "currentColor",
                                strokeWidth: "2",
                                fill: "none",
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                className: "css-i6dzq1",
                                children: [
                                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("polyline", {
                                    points: "6 9 6 2 18 2 18 9"
                                  }, void 0, false, {
                                    fileName: "app/routes/index.jsx",
                                    lineNumber: 1014,
                                    columnNumber: 25
                                  }, this),
                                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("path", {
                                    d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"
                                  }, void 0, false, {
                                    fileName: "app/routes/index.jsx",
                                    lineNumber: 1015,
                                    columnNumber: 25
                                  }, this),
                                  /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("rect", {
                                    x: "6",
                                    y: "14",
                                    width: "12",
                                    height: "8"
                                  }, void 0, false, {
                                    fileName: "app/routes/index.jsx",
                                    lineNumber: 1016,
                                    columnNumber: 25
                                  }, this)
                                ]
                              }, void 0, true, {
                                fileName: "app/routes/index.jsx",
                                lineNumber: 1003,
                                columnNumber: 23
                              }, this),
                              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                                className: "ml-2 cursor-pointer",
                                onClick: () => Print(),
                                children: "PRINT WEEKLY MENU"
                              }, void 0, false, {
                                fileName: "app/routes/index.jsx",
                                lineNumber: 1018,
                                columnNumber: 23
                              }, this)
                            ]
                          }, void 0, true, {
                            fileName: "app/routes/index.jsx",
                            lineNumber: 1002,
                            columnNumber: 21
                          }, this),
                          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                            className: "text-black font-medium text-xs inline-flex",
                            children: [
                              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                                className: "ri-file-copy-line"
                              }, void 0, false, {
                                fileName: "app/routes/index.jsx",
                                lineNumber: 1023,
                                columnNumber: 23
                              }, this),
                              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("span", {
                                className: "ml-2 cursor-pointer",
                                onClick: () => CopyLink(),
                                children: "COPY LINK TO INTRANET"
                              }, void 0, false, {
                                fileName: "app/routes/index.jsx",
                                lineNumber: 1024,
                                columnNumber: 23
                              }, this)
                            ]
                          }, void 0, true, {
                            fileName: "app/routes/index.jsx",
                            lineNumber: 1022,
                            columnNumber: 21
                          }, this)
                        ]
                      }, void 0, true, {
                        fileName: "app/routes/index.jsx",
                        lineNumber: 1001,
                        columnNumber: 19
                      }, this),
                      ((_v = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _v.is_admin) && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                        className: "row-content",
                        children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
                          className: "text-black font-medium text-xs my-3 inline-flex",
                          children: [
                            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
                              className: "float-right pl-4 cache-btn text-primary capitalize font-normal text-sm",
                              style: { opacity: preventDouble1 ? 0.5 : 1 },
                              disabled: preventDouble1,
                              onClick: () => clearScreencloudCache(),
                              children: [
                                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                                  className: "ri-refresh-line"
                                }, void 0, false, {
                                  fileName: "app/routes/index.jsx",
                                  lineNumber: 1054,
                                  columnNumber: 228
                                }, this),
                                " CLEAR LOCATION SCREENCLOUD CACHE "
                              ]
                            }, void 0, true, {
                              fileName: "app/routes/index.jsx",
                              lineNumber: 1054,
                              columnNumber: 25
                            }, this),
                            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("button", {
                              className: "float-right pl-4 cache-btn text-primary capitalize font-normal text-sm",
                              style: { opacity: preventDouble ? 0.5 : 1 },
                              disabled: preventDouble,
                              onClick: () => clearCache(),
                              children: [
                                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("i", {
                                  className: "ri-refresh-line"
                                }, void 0, false, {
                                  fileName: "app/routes/index.jsx",
                                  lineNumber: 1055,
                                  columnNumber: 215
                                }, this),
                                " CLEAR SITE CLOUDFLARE CACHE "
                              ]
                            }, void 0, true, {
                              fileName: "app/routes/index.jsx",
                              lineNumber: 1055,
                              columnNumber: 25
                            }, this)
                          ]
                        }, void 0, true, {
                          fileName: "app/routes/index.jsx",
                          lineNumber: 1053,
                          columnNumber: 23
                        }, this)
                      }, void 0, false, {
                        fileName: "app/routes/index.jsx",
                        lineNumber: 1052,
                        columnNumber: 21
                      }, this)
                    ]
                  }, void 0, true, {
                    fileName: "app/routes/index.jsx",
                    lineNumber: 1e3,
                    columnNumber: 17
                  }, this)
                ]
              }, Math.random(), true, {
                fileName: "app/routes/index.jsx",
                lineNumber: 993,
                columnNumber: 15
              }, this)
            ]
          }, void 0, true, {
            fileName: "app/routes/index.jsx",
            lineNumber: 988,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: "app/routes/index.jsx",
          lineNumber: 987,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 986,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Footer, {}, void 0, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 1065,
        columnNumber: 7
      }, this),
      menuModalIsOpen ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(lunchBanner_default, {
        setIsOpenParent: setMenuIsOpen,
        modalIsOpenParent: menuModalIsOpen,
        data: menucurrentBanner,
        isAdminUser: (_w = datas == null ? void 0 : datas.currentUser) == null ? void 0 : _w.is_admin,
        LocationId
      }, void 0, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 1068,
        columnNumber: 11
      }, this) : null,
      modalStationOpen ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StationModel, {
        setIsOpenv: setModalStationOpen,
        stationDetail
      }, void 0, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 1078,
        columnNumber: 9
      }, this) : null,
      tableDataModelOpen ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(tableDataModal_default, {
        setIsOpenv: setTableDataModel,
        Details: tableData
      }, void 0, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 1084,
        columnNumber: 9
      }, this) : null,
      tableDataPreviewModelOpen ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(foodWasteBannerModal_default, {
        setIsOpenv: setTableDataPreviewModel,
        Details: tablePreviewData
      }, void 0, false, {
        fileName: "app/routes/index.jsx",
        lineNumber: 1090,
        columnNumber: 9
      }, this) : null
    ]
  }, Math.random(), true, {
    fileName: "app/routes/index.jsx",
    lineNumber: 977,
    columnNumber: 5
  }, this);
}
export {
  IndexPage as default,
  meta
};
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v4.4.2
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
//# sourceMappingURL=/build/routes/index-M4DRHSPA.js.map
